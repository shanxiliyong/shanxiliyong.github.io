<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2019/09/10/aa_category/review/se/"/>
      <url>/2019/09/10/aa_category/review/se/</url>
      
        <content type="html"><![CDATA[<ul><li>w</li><li><a href="https://blog.csdn.net/zhangsanfeng2009/article/details/81001567" target="_blank" rel="noopener">https://blog.csdn.net/zhangsanfeng2009/article/details/81001567</a></li><li><a href="https://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247484877&amp;idx=1&amp;sn=f54d41b68f0cd6cc7c0348a2fddbda9f&amp;chksm=cea24a06f9d5c3102bfef946ba6c7cc5df9a503ccb14b9b141c54e179617e4923c260c0b0a01&amp;token=1082669959&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247484877&amp;idx=1&amp;sn=f54d41b68f0cd6cc7c0348a2fddbda9f&amp;chksm=cea24a06f9d5c3102bfef946ba6c7cc5df9a503ccb14b9b141c54e179617e4923c260c0b0a01&amp;token=1082669959&amp;lang=zh_CN&amp;scene=21#wechat_redirect</a></li><li><a href="https://www.jianshu.com/p/0df3d5641c1c" target="_blank" rel="noopener">https://www.jianshu.com/p/0df3d5641c1c</a></li><li></li></ul><h1 id="线程池相关"><a href="#线程池相关" class="headerlink" title="线程池相关"></a>线程池相关</h1><p><a href="https://www.jianshu.com/p/6c6f396fc88e" target="_blank" rel="noopener">https://www.jianshu.com/p/6c6f396fc88e</a></p><p><strong>单机上一个线程池正在处理服务，如果忽然断电了怎么办（正在处理和阻塞队列里的请求怎么处理）？</strong></p><p><strong>说说几种常见的线程池及使用场景</strong></p><p>newSingleThreadExecutor   newFixedThreadPool    堆积的请求处理队列可能会耗费非常大的内存，甚至OOM</p><p>newCachedThreadPool  newScheduledThreadPool   线程数最大数是Integer.MAX_VALUE</p><p><strong>线程池都有哪几种工作队列</strong></p><p>ArrayBlockingQueue    LinkedBlockingQueue  SynchronousQueue  PriorityBlockingQueue</p><p> <strong>jdk8移除了PermGen，取而代之的是MetaSpace</strong></p><p>1、字符串存在永久代中，容易出现性能问题和内存溢出。</p><p>2、类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</p><p>3、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低</p><p><strong>ThreadLocal使用原理、注意问题、使用场景</strong></p><p>java.lang.Thread#threadLocals   脏数据  内存泄漏     读写分离上下文   日志traceid  </p><p><strong>为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？</strong></p><p>栈是运行时的单位 , 而堆是存储的单元</p><p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据</p><p>堆解决的是数据存储的问题，即数据怎么放，放在哪儿</p><p><strong>一个空Object对象的占多大空间</strong></p><p>64位虚拟机还是32位，如果是64位还要看有没有开启CompressedOops，还要看 ObjectAlignmentInBytes </p><p><strong>Java中，栈的大小通过什么参数来设置</strong></p><p>-Xss     -XX:ThreadStackSize</p><p><strong>对象引用类型分为哪几类</strong></p><p>强引用、软引用、弱引用和虚引用</p><p><strong>垃圾回收算法</strong></p><p> 标记-清除  复制 标记-整理</p><p><strong>如何解决内存碎片的问题</strong></p><p><strong>为什么要分代</strong></p><p>不同的对象的生命周期是不一样的</p><p>不同声明周期的对象可以采取不同的收集方式，以便提高回收效率</p><p><strong>什么情况下触发垃圾回收</strong></p><p>young GC：eden区分配满的时候触发</p><p>full GC ：调用System.gc时；老年代空间不足；方法区空间不足；</p><p><strong>如何选择合适的垃圾收集算法</strong></p><p><a href="https://www.cnblogs.com/cxxjohnson/p/8625713.html" target="_blank" rel="noopener">https://www.cnblogs.com/cxxjohnson/p/8625713.html</a></p><ul><li>Serial收，复制，单线程，暂停</li><li>ParNew收集器，Serial收集器的多线程版本</li><li>Parallel Scavenge，吞吐量优先，复制算法</li><li>Serial Old,标记-整理”算法（Mark-Sweep-Compact）</li><li>Parallel Old,标记-整理（Mark-Sweep-Compact）</li><li>CMS,标记-清除,并发收集、低停顿<ul><li>对 CPU 资源敏感，无法处理浮动垃圾，会产生空间碎片</li><li>foreground collector，遇到对象分配但空间不够，就会直接触发 </li><li>background collector，默认时间间隔2s<ul><li>GC cause 是 gclocker 且配置了 GCLockerInvokesConcurrent ;GC cause 是javalangsystemgc（就是 System.gc()调用）and 且配置了 ExplicitGCInvokesConcurrent </li><li>根据统计数据动态计算<ul><li>未配置 UseCMSInitiatingOccupancyOnly 时，会根据统计数据动态判断是否需要进行一次 CMS GC。判断逻辑是，如果预测 CMS GC 完成所需要的时间大于预计的老年代将要填满的时间，则进行 GC，第一次根据Old Gen 的使用占比（50%）来判断是否要进行 GC</li></ul></li><li>根据 Old Gen 情况判断</li><li>根据增量 GC 是否可能会失败</li><li>根据 meta space 情况判断</li></ul></li><li>GC过程<ul><li>初始标记、并发标记</li><li>预清理，处理并发标记期间的新生代晋升老年代、直接进入老年代、更新老年代的引用关系</li><li>可中断的预清理，这个阶段其实跟上一个阶段做的东西一样，也是为了减少下一个STW重新标记阶段的工作量。增加这一阶段是为了让我们可以控制这个阶段的结束时机，比如扫描多长时间（默认5秒）或者Eden区使用占比达到期望比例（默认50%）就结束本阶段</li><li>并发清理、并发重置</li></ul></li></ul></li><li>G1收集器。<ul><li>G1把内存分成一块块的Region，每块的Region的大小都是一样的。</li><li>G1保留了YGC并加上了一种全新的MIXGC用于收集老年代，G1中的Full GC是采用serial old Full GC。在MIXGC中的Cset是选定所有young gen里的region，外加根据global concurrent marking统计得出收集收益高的若干old gen region。在YGC中的Cset是选定所有young gen里的region。通过控制young gen的region个数来控制young GC的开销。YGC与MIXGC都是采用多线程复制清除，整个过程会STW。</li><li>G1的低延迟原理在于其回收的区域变得精确并且范围变小了</li><li>全局并发标记分的五个阶段</li><li>用STAB来维持并发GC的准确性</li><li>当一个对象大于Region大小的50%，称为巨型对象</li><li>针对于拥有多核处理器和大内存的机器</li><li>RSet记录了其他Region中的对象引用本Region中对象的关系</li></ul></li></ul><p><strong>伪共享</strong></p><p>缓存是以缓存行(Cache Line)为单位的。一般缓存行的大小是64字节。小于64字节的变量，是有可能存在于同一条缓存行的。例如变量X大小32字节，变量Y大小32字节，那么他们有可能会存在于一条缓存行上。</p><p>多个线程同时修改共享在同一个缓存行里的独立变量，无意中影响了性能</p><p><strong>Busy spin</strong></p><p>Busy spin 是一种在不释放 CPU 的基础上等待事件的技术。它经常用于避免丢失 CPU 缓存中的数据</p><p><strong>能创建一个包含可变对象的不可变对象吗</strong></p><p>是的。不要共享可变对象的引用就可以了，如果返回可变对象，就返回原对象的一个拷贝</p><p><strong>JVM 出现 fullGC 很频繁</strong></p><p>触发fullgc的条件</p><p>jmap  mat</p><p>单摘出一台机子做测试 </p><p><strong>jvm中一次完整的GC流程（从ygc到fgc）是怎样的</strong></p><p>对象优先在新生代区中分配，若没有足够    空间，Minor GC</p><p>大对象（需要大量连续内存空间）直接进入老年态</p><p>长期存活的对象进入老年</p><p>如果新生代的大小，小于则不进行fullgc  </p><p>如果新生代的大小，大于则看是否有担保，如果有看老年代连续大小是否大于历次晋升到老年代的平均大小</p><p><strong>废弃的类</strong></p><p>classloader class instance</p><p><strong>内存溢出</strong> </p><ul><li>java.lang.OutOfMemoryError: Java heap space<ul><li>增加jvm的内存大小  优化程序，释放垃圾</li><li>内存中加载的数据量过于庞大，导出功能；集合类中有对对象的引用，使用完后未清空；或循环产生过多重复的对象实体；第三方软件的bug；启动参数内存值设定的过小</li></ul></li><li>StackOverflowError 栈深度。通过代码限制深度，通常是代码问题</li><li>OutOfMemoryError  适当减小栈的深度</li></ul><p><strong>类加载机制</strong></p><p>加载-&gt;连接（验证、准备、解析）-&gt;初始化-&gt;使用-&gt;卸载</p><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p><strong>BeanFactory 和 FactoryBean</strong></p><p><strong>application的生命周期</strong></p><ul><li>BeanFactoryPostProcessor</li><li>BeanPostProcessor</li><li>finishBeanFactoryInitialization</li></ul><p><strong>springbean 的生命周期</strong></p><ul><li>创建bean</li><li>设置属性</li><li>aware</li><li>postProcessBeforeInitialization</li><li>init</li><li>postProcessAfterInitialization</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/09/10/aa_category/front/vue/vue%E5%85%A5%E9%97%A8/"/>
      <url>/2019/09/10/aa_category/front/vue/vue%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue入门"><a href="#Vue入门" class="headerlink" title="Vue入门"></a>Vue入门</h1><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><p>处理http请求</p><p><a href="https://www.npmjs.com/package/axios" target="_blank" rel="noopener">https://www.npmjs.com/package/axios</a></p><h2 id="VueRouter"><a href="#VueRouter" class="headerlink" title="VueRouter"></a>VueRouter</h2><p>路由处理</p><h2 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h2><p><a href="https://router.vuejs.org/en/" target="_blank" rel="noopener">https://router.vuejs.org/en/</a></p><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>处理模块化</p><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>解决组件之间数据共享的问题</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/09/10/aa_category/db/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88/"/>
      <url>/2019/09/10/aa_category/db/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库架构原则"><a href="#数据库架构原则" class="headerlink" title="数据库架构原则"></a>数据库架构原则</h1><ul><li>高可用</li><li>高性能</li><li>一致性</li><li>扩展性</li></ul><h1 id="常见的架构方案"><a href="#常见的架构方案" class="headerlink" title="常见的架构方案"></a>常见的架构方案</h1><h2 id="主备架构"><a href="#主备架构" class="headerlink" title="主备架构"></a>主备架构</h2><p>只有主库提供读写服务，备库冗余作故障转移用</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p> 1、高可用分析： 高可用，主库挂了，keepalive（只是一种工具）会自动切换到备库。这个过程对业务层是透明的，无需修改代码或配置。</p><p>2、高性能分析： 读写都操作主库，很容易产生瓶颈。大部分互联网应用读多写少，读会先成为瓶颈，进而影响写性能。另外，备库只是单纯的备份，资源利用率50%，这点方案二可解决。</p><p>3、一致性分析： 读写都操作主库，不存在数据一致性问题。</p><p>4、扩展性分析： 无法通过加从库来扩展读性能，进而提高整体性能。</p><p>5、可落地分析：两点影响落地使用。第一，性能一般，这点可以通过建立高效的索引和引入缓存来增加读性能，进而提高性能。这也是通用的方案。第二，扩展性差，这点可以通过分库分表来扩展。</p><h2 id="双主架构"><a href="#双主架构" class="headerlink" title="双主架构"></a>双主架构</h2><p>两个主库同时提供服务，负载均衡</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>1、高可用分析： 高可用，一个主库挂了，不影响另一台主库提供服务。这个过程对业务层是透明的，无需修改代码或配置。</p><p>2、高性能分析： 读写性能相比于方案一都得到提升，提升一倍。</p><p>3、一致性分析： 存在数据一致性问题。请看下面的一致性解决方案。</p><p>4、扩展性分析： 当然可以扩展成三主循环，但笔者不建议（会多一层数据同步，这样同步的时间会更长）。如果非得在数据库架构层面扩展的话，扩展为方案四。</p><p>5、可落地分析： 两点影响落地使用。第一，数据一致性问题，一致性解决方案可解决问题。第二，主键冲突问题，ID统一地由分布式ID生成服务来生成可解决问题。</p><h2 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h2><p>一主多从，读写分离</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>高可用分析： 主库单点，从库高可用。一旦主库挂了，写服务也就无法提供。</p><p>2、高性能分析：大 部分互联网应用读多写少，读会先成为瓶颈，进而影响整体性能。读的性能提高了，整体性能也提高了。另外，主库可以不用索引，线上从库和线下从库也可以建立不同的索引（线上从库如果有多个还是要建立相同的索引，不然得不偿失；线下从库是平时开发人员排查线上问题时查的库，可以建更多的索引）。</p><p>3、一致性分析： 存在数据一致性问题。请看下面介绍的一致性解决方案。</p><p>4、扩展性分析： 可以通过加从库来扩展读性能，进而提高整体性能。（带来的问题是，从库越多需要从主库拉取binlog日志的端就越多，进而影响主库的性能，并且数据同步完成的时间也会更长）</p><p>5、可落地分析： 两点影响落地使用。第一，数据一致性问题，一致性解决方案可解决问题。第二，主库单点问题，笔者暂时没想到很好的解决方案。</p><h2 id="双主-主从架构"><a href="#双主-主从架构" class="headerlink" title="双主+主从架构"></a>双主+主从架构</h2><p>1、高可用分析： 高可用。</p><p>2、高性能分析： 高性能。</p><p>3、一致性分析： 存在数据一致性问题。请看，一致性解决方案。</p><p>4、扩展性分析： 可 以通过加从库来扩展读性能，进而提高整体性能。（带来的问题同方案二）</p><p>5、可落地分析： 同方案二，但数据同步又多了一层，数据延迟更严重。</p><h1 id="一致性解决方案"><a href="#一致性解决方案" class="headerlink" title="一致性解决方案"></a>一致性解决方案</h1><ul><li>直接忽略</li><li>强制读主</li><li>选择读主，写操作时根据库+表+业务特征生成一个key放到Cache里并设置超时时间（大于等于主从数据同步时间）。读请求时，同样的方式生成key先去查Cache，再判断是否命中。若命中，则读主库，否则读从库。代价是多了一次缓存读写，基本可以忽略</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/09/10/aa_category/review/md/"/>
      <url>/2019/09/10/aa_category/review/md/</url>
      
        <content type="html"><![CDATA[<h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><h2 id="redis-amp-Memcached"><a href="#redis-amp-Memcached" class="headerlink" title="redis&amp;Memcached"></a>redis&amp;Memcached</h2><ul><li>redis 支持复杂的数据结构</li><li>redis 原生支持集群模式</li><li>Redis支持数据的持久化</li><li>Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型</li></ul><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><ul><li><p>RDB周期性，适用于做冷备</p><ul><li>fork子进程生成快照数据文件，如果文件大，客户端可能有暂停</li></ul></li><li><p>AOF，每条命令作为日志，append-only写入日志文件中 </p></li><li><p>通常会启用两种持久化，AOF作为恢复的第一选择，RDB作为冷备</p></li></ul><h2 id="如何使用缓存"><a href="#如何使用缓存" class="headerlink" title="如何使用缓存"></a>如何使用缓存</h2><ul><li><p>为什么使用</p><ul><li>高性能（执行时间），高并发</li></ul></li><li><p>不良后果</p><ul><li>缓存和数据库不一致<ul><li>更新缓存代价比较大；懒加载思想，某一时间段，写多读少</li><li>先删，再更新，缓存为空（高并发下是旧）；先更新，再删除，缓存是旧的</li></ul></li><li>雪崩，挂掉，大量key失效<ul><li>前，高可用（哨兵，集群）；中，缓存+限流；后，持久化</li></ul></li><li>击穿（不存在），穿透（热点key）</li><li>并发竞争，先获取锁，写之前判断当前value中的时间戳大于缓存里的时间戳</li></ul><h2 id="redis效率高"><a href="#redis效率高" class="headerlink" title="redis效率高"></a>redis效率高</h2><p> 纯内存操作；基于非阻塞的IO多路复用机制；单线程避免了多线程的上下文切换问题</p></li></ul><h2 id="过期策略，内存淘汰机制"><a href="#过期策略，内存淘汰机制" class="headerlink" title="过期策略，内存淘汰机制"></a>过期策略，内存淘汰机制</h2><ul><li>定时删除，惰性删除</li><li>allkeys-lru、volatile-lru、volatile-ttl</li><li>LRU LRUCache&lt;K, V&gt; extends LinkedHashMap</li></ul><h2 id="redis-cluster"><a href="#redis-cluster" class="headerlink" title="redis cluster"></a>redis cluster</h2><ul><li><p>通信原理</p><ul><li>集中式，读取更新，时效性好，存储有压力</li><li>gossip，更新有延时，分散存储压力</li></ul></li><li><p>寻址算法。hash 算法；一致性 hash 算法；hash slot 算法</p></li><li><p>主备切换原理</p><ul><li>sdown-主观宕机,odown客观宕机,如果 quorum 数量的哨兵都觉得一个 master 宕机了，那么就是客观宕机</li></ul></li></ul><h2 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h2><ul><li>集群监控、消息通知、故障转移、配置中心</li><li>哨兵至少需要3个实例，哨兵+redis主从架构不保证数据零丢失</li><li>数据丢失，异步复制丢失，脑裂的丢失<ul><li>至少有一个slave数据复制和同步的延迟不能超过10s</li></ul></li><li>slave 配置的自动纠正</li><li>slave-&gt;master 选举算法  master断开时间,优先级,offset,run id </li></ul><h1 id="db"><a href="#db" class="headerlink" title="db"></a>db</h1><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><ul><li><p>单表500万左右性能就开始差了</p></li><li><p>单库最高并发2000</p></li><li><p>迁移方案</p><ul><li>晚上停机</li><li>双写，注意老数据覆盖新数据，一轮以后如果不一致，校验，针对不一致的再次写</li></ul></li><li><p>orderId 模 32 = 库，orderId / 32 模 32 = 表</p></li><li><p>使用雪花算法</p></li></ul><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><ul><li>主库将变更写入binlog,从库将主库的binglog写入自己的relay日志，执行日志中的语句</li><li>半同步，主写入binglog后强制将日志同步到从库，从库写入realy log以后返回ack给主库，至少一个从库ack之后才会认为写完成。</li><li>并行复制，指的是从库开启多个线程，并行读取 relay log 中不同库的日志，然后并行重放不同库的日志</li><li>一个主库拆分成多个主库，代码控制，查主库</li></ul><h1 id="zk"><a href="#zk" class="headerlink" title="zk"></a>zk</h1><p><a href="https://www.jianshu.com/p/2bceacd60b8a" target="_blank" rel="noopener">https://www.jianshu.com/p/2bceacd60b8a</a></p><ul><li>场景,分布式协调,分布式锁,分布式队列,配置信息管理</li><li>协议,zab,Zookeeper Atomic Broadcast （Zookeeper原子广播）</li><li>watcher机制<ul><li>Watch是一次性的，每次都需要重新注册，并且客户端在会话异常结束时不会收到任何通知，而快速重连接时仍不影响接收通知</li><li>Watch的回调执行都是顺序执行的，并且客户端在没有收到关注数据的变化事件通知之前是不会看到最新的数据</li><li>Watch是轻量级的，WatchEvent是最小的通信单元，结构上只包含通知状态、事件类型和节点路径。</li></ul></li><li>部署模式单机模式、伪集群模式、集群模式</li><li>集群角色：leader、Follower、observer。</li><li>集群最少要几台机器，集群规则是怎样的?集群规则为2N+1台，N&gt;0，即3台</li><li>集群如果有3台机器，挂掉一台集群还能工作吗？挂掉两台呢？集群需要一半以上的机器可用，所以，3台挂掉1台还能工作，2台不能</li><li>ZooKeeper保证的是CP</li></ul><h2 id="zab"><a href="#zab" class="headerlink" title="zab"></a>zab</h2><ul><li>什么是Zab协议<ul><li>Zookeeper Atomic Broadcast ,保证分布式事务的最终一致性</li></ul></li><li>Zab 的作用<ul><li>使用一个单一的主进程（Leader）来接收并处理客户端的事务请求； </li><li>保证一个全局的变更序列被顺序引用</li><li>当主进程出现异常的时候，整个zk集群依旧能正常工作</li></ul></li><li>Zab协议原理;<ul><li>发现：要求zookeeper集群必须选举出一个 Leader 进程，同时 Leader 会维护一个 Follower 可用客户端列表</li><li>同步：Leader 要负责将本身的数据与 Follower 完成同步，做到多副本存储。</li><li>广播：Leader 可以接受客户端新的事务Proposal请求，将新的Proposal请求广播给所有的 Follower。</li></ul></li><li>协议内容<ul><li>协议过程<ul><li>崩溃恢复模式、消息广播模式</li><li>新加入的机子是崩溃恢复模式，等找到leader,完成数据同步后成为消息广播模式</li></ul></li><li>消息有序；每一个事务请求转换成对应的 proposal （zxid）来进行广播，将每一个proposal按照其zxid的先后顺序进行排序和处理</li></ul></li><li>Zab 崩溃恢复要求满足。确保已经被 Leader 提交的 Proposal 必须最终被所有的 Follower 服务器提交;确保丢弃已经被 Leader 提出的但是没有被提交的 Proposal</li><li>消息广播具体<ul><li>客户端发起一个写操作请求</li><li>Leader 服务器将客户端的请求转化为事务 Proposal 提案</li><li>Leader 服务器为每个 Follower 服务器分配一个单独的队列，然后将需要广播的 Proposal 依次放到队列中取</li><li>Follower接收到 Proposal 后，以事务日志的方式写入本地磁盘，写入成功后向 Leader 反馈一个 Ack 响应消息</li><li>Leader 接收到超过半数以上 Follower 的 Ack 响应消息后，即认为消息发送成功，可以发送 commit 消息</li><li>Leader 向所有 Follower 广播 commit 消息，同时自身也会完成事务提交。Follower 接收到 commit 消息后，会将上一条事务提交</li></ul></li><li>Zab 协议如何保证数据一致性<ul><li>确保已经被 Leader 提交的 Proposal 必须最终被所有的 Follower 服务器提交</li><li>确保丢弃已经被 Leader 提出的但是没有被提交的 Proposal。</li></ul></li><li>Zab 如何数据同步<ul><li>完成 Leader 选举后,Leader 服务器会首先确认事务日志中的所有的 Proposal 是否已经被集群中过半的服务器 Commit</li><li>Leader 服务器需要确保所有的 Follower 服务器能够接收到每一条事务的 Proposal ，并且能将所有已经提交的事务 Proposal 应用到内存数据中</li></ul></li><li>Zab 数据同步过程中，如何处理需要丢弃的 Proposal（提出没有提交）？<ul><li>leader和follow对比，比对的结果没有一半以上commit所以进行回退</li></ul></li><li>Zab 的四个阶段？选举、发现、同步、广播<ul><li>同步，follower会主动将自己最大的zxid发送给leader，leader会将follower的zxid与自身zxid间的所有被Commit过的消息同步给follower</li><li>广播,leader会向follower发送NEWLEADER命令并等待大多数服务器的ACK,然后向所有服务器广播UPTODATE命令。收到该命令后的服务器即可对外提供服务</li></ul></li><li>未Commit过的消息对客户端不可见<ul><li>B在成为Leader后，先判断自身未Commit的消息,是否存在于大多数服务器中从而决定是否要将其Commit</li></ul></li></ul><h1 id="dubbo"><a href="#dubbo" class="headerlink" title="dubbo"></a>dubbo</h1><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><ol><li>service,提供服务者和消费者实现</li><li>config</li><li>proxy,生成consumer,和provide的代理层</li><li>registry,注册和发现</li><li>cluster,将多个实例组成一个服务，服务的路由及负载均衡</li><li>monitor</li><li>protocal,远程调用层，封装rpc调用</li><li>exchange,信息交互层，封装请求和响应模式</li><li>transprot 层网络传输，抽象netty</li><li>serialize,数据序列化</li></ol><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>provide向注册中心注册；consumer在注册中心订阅服务； consume 调用provide</p><h3 id="dubbo-负载均衡策略"><a href="#dubbo-负载均衡策略" class="headerlink" title="dubbo 负载均衡策略"></a>dubbo 负载均衡策略</h3><ul><li>random ,roundrobin ,leastactive ,consistanthash </li></ul><h3 id="容错策略"><a href="#容错策略" class="headerlink" title="容错策略"></a>容错策略</h3><p>failover （读）、failfast （写）、failsafe （出现异常忽略，不重要的接口，记录日志）、failback（失败了自动记录请求，定时重发，写消息队列）、forking(并行调用多个provide,只要一个成功就成功)、broadcacst （逐个调用所有的provider）</p><p>降级使用hystrix  </p><h3 id="Dubbo-的-RPC-框架"><a href="#Dubbo-的-RPC-框架" class="headerlink" title="Dubbo 的 RPC 框架"></a>Dubbo 的 RPC 框架</h3><ul><li>服务提供者去注册中心注册   -zk</li><li>消费者拿到服务信息</li><li>基于动态代理生成一个本地类，然后找服务对应的地址</li><li>找那台机子请求，负载算法</li><li>找到机子怎么发送 netty,发送格式 hesssion protobuf,msgpack</li><li>服务器那边一样的，需要针对你自己的服务生成一个动态代理，监听某个网络端口了，然后代理你本地的服务代码。接收到请求的时候，就调用对应的服务代码，对吧</li></ul><h1 id="hystrix"><a href="#hystrix" class="headerlink" title="hystrix"></a>hystrix</h1><h2 id="调用fllback"><a href="#调用fllback" class="headerlink" title="调用fllback"></a>调用fllback</h2><p>断路器打开  资源已满 接口异常  接口超时</p><h2 id="资源隔离"><a href="#资源隔离" class="headerlink" title="资源隔离"></a>资源隔离</h2><ul><li><p>线程池  支持超时      支持异步    开销大  网络访问</p></li><li><p>信号量  不支持超时  不支持异步  开销小 内部访问  超大并发量</p></li></ul><h2 id="经典降级方案"><a href="#经典降级方案" class="headerlink" title="经典降级方案"></a>经典降级方案</h2><ul><li>返回一个默认值</li><li>内存中维护一个cache,基于LRU自动清理的缓存，如果异常直接从缓存中获取</li></ul><h2 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h2><p>创建comand;调用comand;request cache;circuit breaker;线程池是否已满;执行command;断路健康检查（成功、失败、reject、timeout）;</p><h1 id="es"><a href="#es" class="headerlink" title="es"></a>es</h1><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul><li>index -&gt; type -&gt; mapping(表的定义) -&gt; document（一行数据） -&gt; field（一个字段的值）</li><li>一个index对应多个shard.每个shard存储部分数据。shard数据有多个备份。primary_shard（写入）、replica_shard.</li><li>master管理工作。维护索引元数据，切换primary_shard和replica_shard身份。master挂机了，重新选举一个master节点</li><li>非master宕机，宕机的primary_shard身份切换到其他replica_shard上。重启以后，修复后的节点也不再是 primary shard，而是 replica shard</li></ul><h2 id="写过程"><a href="#写过程" class="headerlink" title="写过程"></a>写过程</h2><ul><li>客户端给 coordinating node发送请求</li><li>coordinating node 对 document 进行路由，将请求转发给对应primary shard</li><li>primary shard 处理请求，然后将数据同步到 replica node</li><li>coordinating node 如果发现 primary node 和所有 replica node 都搞定之后，就返回响应结果给客户端</li></ul><h2 id="读过程"><a href="#读过程" class="headerlink" title="读过程"></a>读过程</h2><ul><li>客户端给 coordinating node发送请求</li><li>coordinate node 对 doc id 进行哈希路由，得到所在的shard，然后使负载算法确定node</li><li>接收请求的 node 返回 document 给 coordinate node,oordinate node 返回 document 给客户端</li></ul><h2 id="es-搜索过程"><a href="#es-搜索过程" class="headerlink" title="es 搜索过程"></a>es 搜索过程</h2><ul><li>客户端发送请求到一个 coordinate node</li><li>协调节点将搜索请求转发到所有的 shard</li><li>query phase：每个 shard 将自己的搜索结果（其实就是一些 doc id）返回给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果</li><li>fetch phase：接着由协调节点根据 doc id 去各个节点上拉取实际的 document 数据，最终返回给客户端</li></ul><h2 id="提高查询效率"><a href="#提高查询效率" class="headerlink" title="提高查询效率"></a>提高查询效率</h2><ul><li>filesystem cache</li><li>es+hbase  先用es按照非主键在es中搜索，然后根据主键在hbas中查找</li><li>数据预热</li><li>冷热分离，冷数据写入一个索引中，然后热数据写入另外一个索引中</li><li>document 模型设计。不要做复杂的查询；关联查询，将关联好的塑胶写入es中</li><li>分页，越到后面越慢;不允许深度分页;scroll api/search_after</li></ul><h1 id="mq"><a href="#mq" class="headerlink" title="mq"></a>mq</h1><ul><li><p>为什么使用消息队列?解耦、异步、削峰</p></li><li><p>消息队列有什么优点和缺点?可用性降级，系统复杂度提高，一致性问题</p></li><li><p>Kafka、ActiveMQ、RabbitMQ、RocketMQ都有什么区别，以及适合哪些场景。</p><ul><li>ActiveMQ用的不多了，没经过大规模吞吐量场景的验证</li><li>RabbitMQ， erlang 语言阻止 Java 工程师去深入研究，对公司而言，几乎处于不可控的状态</li><li>RocketMQ，毕竟是阿里出品，但社区可能有突然黄掉的风险对自己公司技术实力有绝对自信的，推荐用</li></ul></li><li><p>如何保证消息队列的高可用？</p><ul><li>RabbitMQ 的高可用性。单机模式；普通集群模式，元数据同步到多个实例上；镜像集群模式（高可用性），元数据和queue存在多个实例上</li><li>Kafka 的高可用性。天然的分布式消息队列；写数据的时候，生产者就写 leader，然后 leader 将数据落地写本地磁盘，接着其他 follower 自己主动从 leader 来 pull 数据。一旦所有 follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者；消费的时候，只会从 leader 去读，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到</li></ul></li><li><p>如何保证消息不被重复消费。消息有唯一id;先根据主键查一下，如果这数据都有了，你就别插入了</p></li><li><p>如何处理消息丢失的问题.</p><ul><li>生产者弄丢了数据.RabbitMQ .confirm异步，事务机制同步；一般使用confirm</li><li>RabbitMQ 弄丢了数据。开启持久化+confirm.持久化以后发送ack确认数据。</li><li>消费端弄丢了数据。RabbitMQ关闭自动ack,手动调用api;</li></ul></li><li><p>如何保证消息的顺序性.</p><ul><li>拆分多个 queue，每个 queue 一个 consumer</li><li>一个 大queue是对应一个 consumer，然后这个 consumer 写 N 个内存 queue，具有相同 key 的数据都到同一个内存 queue；N 个线程，每个线程分别消费一个内存 queue 即可</li></ul></li><li><p>大量消息在 mq 里积压了几个小时了还没解决</p><ul><li>申请空间是之前10倍的queue；写个临时couseme程序，消费积压消息，写入临时queue;当程序修复后用10倍的机器消费临时queue.</li></ul></li><li><p>mq 中的消息过期失效了.如果丢失的数据能找出来，晚上重新灌入mq</p></li><li><p>mq 都快写满了。临时写程序，接入数据来消费，消费一个丢弃一个，都不要了，快速消费掉所有的消息。然后，到了晚上再补数据吧</p></li><li><p>如果让你写一个消息队列，该如何进行架构设计？</p><ul><li><p>伸缩性.broker -&gt; topic -&gt; partition，每个 partition 放一个机器，就存一部分数据.</p></li><li><p>数据落地磁盘.顺序写,这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的</p></li><li><p>可用性.多副本 -&gt; leader &amp; follower -&gt; broker 挂了重新选举 leader 即可对外服务</p></li></ul></li></ul><ul><li><p>使用场景、缺点、重复、丢失、有序、高可用</p></li><li><p>积压、写满、过期</p></li><li><p>设计</p></li></ul><h1 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h1><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><ul><li>数据库乐观锁</li><li>redis  SET my:lock 随机值 NX PX 30000   或者回字型lua脚本删除，需要自己不断去尝试获取锁，比较消耗性能</li><li>redis RedLock .如果一台机子断电重启，启动以后不要对外提供RedLock的功能</li><li>zk</li><li>分析</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><ul><li><p>冗余</p><ul><li>es，备份shard</li><li>redis哨兵+主从</li><li>RabbitMQ镜像集群模式通过全量备份，kafka通过备份partition</li><li>zk,通过leader,follow</li></ul></li><li><p>异步</p><ul><li>zk,通过队列</li></ul></li></ul><h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><ul><li>hash<ul><li>es doc id hash</li><li>kafka通过hash决定路由哪个partition</li><li>redis 一致性hash</li></ul></li></ul><h2 id="少数服从多数"><a href="#少数服从多数" class="headerlink" title="少数服从多数"></a>少数服从多数</h2><ul><li>redis 客观宕机</li><li>redis的redlock</li><li>zk选举</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/09/10/aa_category/review/%E6%B1%87%E6%80%BB/"/>
      <url>/2019/09/10/aa_category/review/%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><ul><li><p>JDBC 流程</p><ul><li>加载驱动、获取连接、创建statement、设置sql语句传入参数、执行sql语句、处理返回结果、释放链接</li></ul></li><li><p>语法糖</p><ul><li>switch 支持 String 与枚举、自动装箱与拆箱、变长参数、枚举类</li></ul></li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul><li><p>Arraylist （get/set）与 LinkedList (add/remove)</p></li><li><p>ConcurrentHashMap 的工作原理及代码实现。</p><ul><li>对于put操作，如果Key对应的数组元素为null，则通过<a href="http://www.jasongj.com/java/thread_safe/#CAS%EF%BC%88compare-and-swap%EF%BC%89" target="_blank" rel="noopener">CAS操作</a>将其设置为当前值。如果Key对应的数组元素（也即链表表头或者树的根元素）不为null，则对该元素使用synchronized关键字申请锁，然后进行操作。如果该put操作使得当前链表长度超过一定阈值，则将该链表转换为树，从而提高寻址效率。</li></ul></li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul><li>sleep() 、join（）、yield（）有什么区别</li><li>说说 CountDownLatch 原理,内部维护了一个整数n,<code>await()</code> 方法阻塞当前线,countDown执行一次n减1</li><li>说说 CyclicBarrier 原理，每当线程执行await，内部变量count减1，如果count！= 0，说明有线程还未到屏障处，则在锁条件变量trip上等待。当count == 0时，说明所有线程都已经到屏障处，执行条件变量的signalAll方法唤醒等待的线程</li><li>说说 Semaphore 原理</li><li>线程的生命周期;新建,就绪;运行;阻塞;死亡</li></ul><h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><ul><li>volatile 实现原理 ,内存屏障，缓存一致性协议</li><li>synchronized 与 lock 的区别.隐式锁,显式锁;悲观,乐观</li><li>CAS 乐观锁,内存位置（V）、预期原值（A）和新值(B)</li></ul><h1 id="核心篇"><a href="#核心篇" class="headerlink" title="核心篇"></a>核心篇</h1><h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><ul><li><a href="http://blog.720ui.com/2017/mysql_core_04_index_item/" target="_blank" rel="noopener">MySQL 索引使用的注意事项</a><ul><li>列上函数和运算;否定操作符;or;最左前缀；覆盖索引；</li></ul></li><li><a href="http://blog.720ui.com/2017/mysql_core_09_multi_db_table2/" target="_blank" rel="noopener">分库与分表带来的分布式困境与应对之策</a><ul><li>分表。垂直，不常用的字段在一张表，大文本一张表，关联查询的字段一张表</li></ul></li><li>MySQL 遇到的死锁问题<ul><li>大事务拆小；添加合理索引；尽可能一次锁定资源；</li><li>业务日志，是否有回滚；找dba查看最近死锁的记录</li></ul></li><li>为什么要用 B+tree<ul><li>索引大存储到磁盘上，查找的时候尽量减少磁盘io次数。预读，一次只读一页。</li></ul></li><li><a href="http://blog.720ui.com/2017/db_better_db_use/" target="_blank" rel="noopener">选择合适的数据存储方案</a><ul><li>es全文搜索代替like;mongodb高伸缩性，日志系统</li></ul></li><li>倒排索引，搜索引擎用到，根据歌词搜索歌名</li></ul><h1 id="框架篇"><a href="#框架篇" class="headerlink" title="框架篇"></a>框架篇</h1><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><ul><li>BeanFactory 和 ApplicationContext 有什么区别</li><li>Spring 事务底层原理，connection,datasource,transaction</li><li>Spring MVC 执行流程<ul><li>DispatcherServlet收到请求调用HandlerMapping</li><li>HandlerMapping根据请求url找到具体的处理器，生成HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet</li><li>DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作</li><li>执行处理器Handler，前置处理，执行，后置处理</li><li>Handler执行完成返回ModelAndView</li><li>HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet</li><li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li><li>ViewReslover解析后返回具体View</li><li>DispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中</li><li>DispatcherServlet响应用户。</li></ul></li><li>Spring 框架中用到了哪些设计模式。工厂，单例，责任链，代理-aop，观察者-listener,策略</li></ul><h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><ul><li>为什么选择 Netty。相比原生nio,简洁易用，相比mina,文档清晰，更新周期短，使用起来简单</li><li>说说业务中，Netty 的使用场景。jsf</li><li>原生的 NIO 在 JDK 1.7 版本存在 epoll bug. Selector 空轮询，最终导致 CPU 100%</li><li>什么是TCP 粘包/拆包.缓存区的大小是一定的如果小于缓存去就行粘包，大于进行拆包</li><li>TCP粘包/拆包的解决办法，消息头的协议，定长消息，消息边界</li><li>Netty 线程模型。<a href="https://www.jianshu.com/p/38b56531565d" target="_blank" rel="noopener">https://www.jianshu.com/p/38b56531565d</a><ul><li>网络处理accept、read、decode、process、encode、send</li><li>事件驱动，Task对应特定网络事件</li><li>角色。Reactor：负责响应事件，将事件分发给绑定了该事件的Handler处理；Handler：事件处理器；Acceptor：Handler的一种，绑定了connect事件</li><li>单线程Reactor；多线程Reactor；主从多线程；netty线程模型多线程Reactor模型类似。</li></ul></li><li>说说 Netty 的零拷贝。传统的零拷贝数据在用户空间与内核中间之间的拷贝；使用传统的堆内存分配，当我们需要将数据通过socket发送的时候，就需要从堆内存拷贝到直接内存，然后再由直接内存拷贝到网卡接口层；Composite Buffers，只是保存两个buffer的引用</li></ul><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><ul><li>上下文切换？<ul><li>上下文，寄存器、程序计数器</li><li>线程是调度单位，进程是资源拥有单位</li><li>分片执行、资源不足、优先级高的抢占、硬件中断</li><li>vmstat</li></ul></li></ul><h1 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h1><ul><li>优化<ul><li>索引，不要再列上进行运算，不用not in </li><li>sql优化，不用*，用连接替换子查询，join小表驱动大表，limit的offset不要过大</li><li>表，字段尽可能 not null,分表</li></ul></li></ul><h1 id="微服务篇"><a href="#微服务篇" class="headerlink" title="微服务篇"></a>微服务篇</h1><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><ul><li><a href="http://blog.720ui.com/2017/restful_api/" target="_blank" rel="noopener">说说如何设计一个良好的 API</a>，版本号，正常返回，异常返回</li><li>说说 CAP 定理、 BASE 理论;基本可用，软状态，最终一致</li><li><a href="http://blog.720ui.com/2017/msa_soa/" target="_blank" rel="noopener">微服务与 SOA 的区别</a>，服务总线，服务治理；单体架构，功能独立</li></ul><h2 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h2><ul><li><a href="http://blog.720ui.com/2016/security_web/" target="_blank" rel="noopener">防范常见的 Web 攻击</a>，XSS攻击（输入恶意的脚本），sql注入，CSRF攻击（）</li><li><a href="http://blog.720ui.com/2016/security_https/" target="_blank" rel="noopener">HTTPS 原理剖析</a><ul><li>客户端输入SSL 3.0 加密协议；</li><li>服务端返回证书</li><li>客户端解析证书，生成随机数，加密发送</li><li>服务端用私钥进行解密随机数</li><li>服务端用私钥进行加密随机数发送给客户端</li><li>客户端解密信息</li></ul></li><li><a href="http://blog.720ui.com/2016/security_https_tls/" target="_blank" rel="noopener">HTTPS 降级攻击</a><ul><li>利用SSL 3.0 漏洞，获取加密后的明文内容；因为兼容性问题，当浏览器进行 HTTPS 连接失败的时候会降级。禁用SSL 3.0 加密协议</li></ul></li></ul><h1 id="工程篇"><a href="#工程篇" class="headerlink" title="工程篇"></a>工程篇</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ul><li>你如何对需求原型进行理解和拆分</li><li>说说你对功能性需求的理解。业务需求转化成er图</li><li>说说你对非功能性需求的理解。安全，可靠性，可移植性、可重用性，可扩展性</li><li>你针对产品提出哪些交互和改进意见。过度追求精准，死板遵循设计法则，过度假设用户行为，过多展示内在业务逻辑，过多展示内在业务逻辑，过于把用户当「小白」</li></ul><h2 id="设计能力"><a href="#设计能力" class="headerlink" title="设计能力"></a>设计能力</h2><ul><li>说说你在项目中使用过的 UML 图，活动图，序列图，部署图</li><li>说说概要设计</li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul><li>你项目中有使用哪些设计模式。构建，责任链，代理，策略，单例，</li><li>说说常用开源框架中设计模式使用分析。缓存使用装饰模式，mapperbuiler构建模式，SqlSessionFactory工厂，日志适配模式，plugin代理模式，拦截器责任链</li><li>说说你对设计原则的理解。单一，开闭，里氏代换，依赖倒转，接口隔离，合成复用，迪米特</li></ul><h2 id="业务工程"><a href="#业务工程" class="headerlink" title="业务工程"></a>业务工程</h2><ul><li>你和团队是如何沟通的</li><li>说说你对技术与业务的理解</li><li>说说你在项目中经常遇到的 Exception。ClassCastException、ClassNotFoundException、IllegalAccessException、NullPointerException、IndexOutOfBoundsException</li><li>说说你在项目中遇到印象最深困难，怎么解决的</li><li>你觉得你们项目还有哪些不足的地方。</li><li>你是否遇到过 CPU 100% ，如何排查与解决   进程，线程，查看线程堆栈信息，定位问题代码</li><li>你是否遇到过 内存 OOM ，如何排查与解决，HeapDumpOnOutOfMemoryError</li><li>介绍下工作中的一个对自己最有价值的项目，以及在这个过程中的角色</li></ul><h2 id="软实力"><a href="#软实力" class="headerlink" title="软实力"></a>软实力</h2><ul><li>说说你的亮点。专业技能，发展潜力，软实力</li><li>说说你觉得最有意义的技术书籍。深入理解java虚拟机</li><li>说说个人发展方向方面的思考。架构师，技术专家。</li><li>说说你认为的服务端开发工程师应该具备哪些能力。初级可以写简单的业务代码，中级可以写复杂的业务代码，高级写公用性的底层代码</li><li>架构师主要做什么？架构师需要参与项目开发的全部过程，包括需求分析、架构设计、系统实现、集成、测试和部署各个阶段，负责在整个项目中对技术活动和技术说明进行指导和协调</li></ul><h1 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h1><ul><li>Native OOM最好的方法就是用google perftools</li><li>java 内存mat +btrace</li></ul><h1 id="HR-篇"><a href="#HR-篇" class="headerlink" title="HR 篇"></a>HR 篇</h1><ul><li><p>谈一谈你的一次失败经历。分表hash</p></li><li><p>你觉得你最大的缺点是什么。不是名校</p></li><li><p>你觉得自己那方面能力最急需提高</p></li><li><p>你来我们公司最希望得到什么，你希望从这份工作中获得什么</p><ul><li>自己学习的东西能落地，认识一些大牛，</li></ul></li><li><p>您还有什么想问的，你对现在应聘的职位有什么了解</p><ul><li>有哪些需要继续提升的</li><li>工作内容，参与什么项目，直接领导</li><li>主要用哪些技术</li><li>我如果能来，是什么角色</li><li>咱们部门的规划是？</li><li>未来如果我要加入这个团队，你对我的期望是什么</li><li>团队现在面临的最大挑战是什么</li></ul></li><li><p>你怎么看待自己的职涯</p></li><li><p>你有什么业余爱好。运动类</p></li></ul><h1 id="方案篇"><a href="#方案篇" class="headerlink" title="方案篇"></a>方案篇</h1><h2 id="秒杀"><a href="#秒杀" class="headerlink" title="秒杀"></a>秒杀</h2><ul><li>配置静态页面</li><li>静态资源(JS,CSS,图片)刷新到CDN</li><li>服务器上进行熔断，限流，降级，</li><li>数据库使用乐观锁，比悲观锁性能好</li><li>reids，单个key的流量不能超过单台缓存服务器的流量，单个key并发访问量*对应value的大小&lt;单台缓存服务器的流量限制</li></ul><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>两阶段提交（2PC）、补偿事务（TCC）</p><h2 id="分布式ID"><a href="#分布式ID" class="headerlink" title="分布式ID"></a>分布式ID</h2><ul><li>UUID;优点，性能高；缺点，太长不易于存储，信息不安全（造成MAC地址泄露）</li><li>数据库生成；优点，简单。缺点，性能限制在单台mysql的性能</li><li>redis;优点，缺点，需要引入redis</li><li>zookeeper主要通过其znode数据版本来生成序列号</li><li>雪花算法，时间戳，机器码，序列号</li></ul><h1 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h1><p><strong>在浏览器中输入url地址到显示主页的过程,整个过程会使用哪些协议</strong></p><p>DNS解析，TCP连接，发送HTTP请求，服务器处理请求并返回HTTP报文，浏览器解析渲染页面，连接结束</p><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>分层、分割、分布式、集群、缓存、异步、冗余、自动化、安全。</p><ul><li>缓存，CDN,反向代理，本地缓存，分布式缓存</li></ul><h2 id="架构要素"><a href="#架构要素" class="headerlink" title="架构要素"></a>架构要素</h2><p>性能、可用性、伸缩性、扩展性、安全性</p><h2 id="高性能架构"><a href="#高性能架构" class="headerlink" title="高性能架构"></a>高性能架构</h2><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><ul><li>测试指标；响应时间，吞吐量，错误率，并发数，资源利用率</li><li>基准测试，负载测试，压力测试，并发测试，稳定性测试</li></ul><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ul><li>web前端<ul><li>浏览器，减少请求，浏览器缓存，压缩，减少cookie</li><li>cdn加速</li><li>反向代理</li><li>页面静态化</li></ul></li><li>服务器<ul><li>缓存，本地缓存，分布式缓存</li><li>异步操作</li><li>集群</li><li>代码优化，sql调优</li></ul></li><li>存储优化<ul><li>机械硬盘vs固态硬盘</li></ul></li></ul><h2 id="高可用架构"><a href="#高可用架构" class="headerlink" title="高可用架构"></a>高可用架构</h2><ul><li><p>高可用的架构</p><ul><li>硬件故障是常态，软件高可用主要是保障硬件故障软件依然可用</li><li>高可用架构的手段冗余备份，故障转移</li></ul></li><li><p>高可用的应用，通过负载均衡进行无状态服务端的失效转移</p></li><li><p>高可用的服务</p><ul><li>分级管理，核心服务用好的硬件</li><li>异步调用，服务降级、幂等性</li></ul></li><li><p>高可用的数据</p><ul><li>cap原理</li><li>数据备份，冷备，热备</li><li>失效转移</li></ul></li><li><p>监控，监控数据收集，监控管理</p></li></ul><h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/31250861" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31250861</a> </li><li><a href="https://www.funtl.com/zh/interview/" target="_blank" rel="noopener">https://www.funtl.com/zh/interview/</a></li><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/essential-content-for-interview/PreparingForInterview/%E7%BE%8E%E5%9B%A2%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.md" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/blob/master/docs/essential-content-for-interview/PreparingForInterview/%E7%BE%8E%E5%9B%A2%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.md</a></li><li></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/09/10/aa_category/review/algorithm/"/>
      <url>/2019/09/10/aa_category/review/algorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md</a></p><h1 id="LeetCodeAnimation"><a href="#LeetCodeAnimation" class="headerlink" title="LeetCodeAnimation"></a>LeetCodeAnimation</h1><p><a href="https://github.com/MisterBooo/LeetCodeAnimation?utm_source=gold_browser_extension" target="_blank" rel="noopener">https://github.com/MisterBooo/LeetCodeAnimation?utm_source=gold_browser_extension</a></p><table><thead><tr><th>序号</th><th>题目&amp;题解</th><th>掌握</th><th>思</th></tr></thead><tbody><tr><td>0</td><td><a href="https://mp.weixin.qq.com/s/vn3KiV-ez79FmbZ36SX9lg" target="_blank" rel="noopener">十大经典排序算法动画与解析，看我就够了！（配代码完全版）</a></td><td></td><td>冒泡、选择、插入、希尔、归并、快速、堆排序、计数、桶、基数。</td></tr><tr><td>1</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC1%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.md" target="_blank" rel="noopener">两数之和</a></td><td></td><td>通过map来存储，key是数组的值，value是数组的下标</td></tr><tr><td>2</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC2%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0.md" target="_blank" rel="noopener">两数相加</a></td><td></td><td>value = (a + b + carry) % 10，carry= (a + b + carry) / 10</td></tr><tr><td>3</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC3%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2.md" target="_blank" rel="noopener">无重复字符的最长子串</a></td><td></td><td>int freq[256] = {0}; int l = 0, r = -1; //滑动窗口为s[l…r]; int res = 0;</td></tr><tr><td>9</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC9%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%9B%9E%E6%96%87%E6%95%B0.md" target="_blank" rel="noopener">回文数</a></td><td></td><td>div   int left = x / div; int right = x % 10;</td></tr><tr><td>15</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC15%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.md" target="_blank" rel="noopener">三数之和</a></td><td></td><td>三数之和转变成两数之和</td></tr><tr><td>19</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC19%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.md" target="_blank" rel="noopener">删除链表的倒数第 N 个节点</a></td><td></td><td>end移动n+1;pre,end移动直至end==null</td></tr><tr><td>20</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC20%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.md" target="_blank" rel="noopener">有效的括号</a></td><td></td><td>栈</td></tr><tr><td>21</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC21%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8.md" target="_blank" rel="noopener">合并两个有序链表</a></td><td></td><td>哨兵</td></tr><tr><td>23</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC23%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8.md" target="_blank" rel="noopener">合并 K 个排序链表</a></td><td></td><td>链表排序，优先级队列，分治</td></tr><tr><td>24</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC24%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.md" target="_blank" rel="noopener">两两交换链表中的节点</a></td><td>放后</td><td></td></tr><tr><td>26</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC26%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9.md" target="_blank" rel="noopener">删除排序数组中的重复项</a></td><td></td><td>快慢指针</td></tr><tr><td>66</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC66%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%8A%A0%E4%B8%80.md" target="_blank" rel="noopener">加一</a></td><td></td><td>和9做比较  a[i]++</td></tr><tr><td>75</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC75%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB.md" target="_blank" rel="noopener">颜色分类</a></td><td></td><td>三路快速排序,计数法</td></tr><tr><td>86</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC86%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8.md" target="_blank" rel="noopener">分割链表</a></td><td></td><td>拆分成两个链表，合并</td></tr><tr><td>92</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC92%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II.md" target="_blank" rel="noopener">反转链表 II</a></td><td></td><td></td></tr><tr><td>94</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC94%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.md" target="_blank" rel="noopener">二叉树的中序遍历</a></td><td></td><td>栈</td></tr><tr><td>101</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC101%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.md" target="_blank" rel="noopener">对称二叉树</a></td><td></td><td>递归</td></tr><tr><td>102</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC102%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.md" target="_blank" rel="noopener">二叉树的层序遍历</a></td><td></td><td>队列</td></tr><tr><td>103</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC103%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86.md" target="_blank" rel="noopener">二叉树的锯齿形层次遍历</a></td><td>放后</td><td></td></tr><tr><td>107</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC107%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86II.md" target="_blank" rel="noopener">二叉树的层次遍历 II</a></td><td></td><td>类似二叉树的右视图</td></tr><tr><td>118</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC118%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92.md" target="_blank" rel="noopener">杨辉三角</a></td><td></td><td>1，11,121,1331</td></tr><tr><td>119</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC119%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92II.md" target="_blank" rel="noopener">杨辉三角II</a></td><td>放后</td><td></td></tr><tr><td>110</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC110%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.md" target="_blank" rel="noopener">平衡二叉树</a></td><td></td><td>递归</td></tr><tr><td>121</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC121%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.md" target="_blank" rel="noopener">买卖股票的最佳时机</a></td><td></td><td></td></tr><tr><td>122</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC122%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.md" target="_blank" rel="noopener">买卖股票的最佳时机II</a></td><td>忽略</td><td></td></tr><tr><td>123</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC123%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.md" target="_blank" rel="noopener">买卖股票的最佳时机III</a></td><td>忽略</td><td></td></tr><tr><td>125</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC125%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2.md" target="_blank" rel="noopener">验证回文串</a></td><td></td><td></td></tr><tr><td>131</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC131%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.md" target="_blank" rel="noopener">分割回文串</a></td><td>放后</td><td></td></tr><tr><td>136</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC136%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.md" target="_blank" rel="noopener">只出现一次的数字</a></td><td></td><td>异或运算</td></tr><tr><td>138</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC138%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88.md" target="_blank" rel="noopener">复制带随机指针</a></td><td></td><td></td></tr><tr><td>139</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC139%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86.md" target="_blank" rel="noopener">单词拆分</a></td><td>放后</td><td></td></tr><tr><td>144</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC144%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.md" target="_blank" rel="noopener">二叉树的前序遍历</a></td><td></td><td>栈，右，左。插入集合末尾</td></tr><tr><td>145</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC145%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.md" target="_blank" rel="noopener">二叉树的后序遍历</a></td><td></td><td>栈，左，右。插入集合头</td></tr><tr><td>146</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC146%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9ALRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6.md" target="_blank" rel="noopener">LRU缓存机制</a></td><td></td><td>LinkedHashMap，initialCapacity，loadFactor，accessOrde</td></tr><tr><td>150</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC150%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.md" target="_blank" rel="noopener">逆波兰表达式求值</a></td><td>放后</td><td></td></tr><tr><td>167</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC167%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84.md" target="_blank" rel="noopener">两数之和 II - 输入有序数组</a></td><td></td><td>双指针</td></tr><tr><td>172</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC172%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6.md" target="_blank" rel="noopener">阶乘后的零</a></td><td></td><td>n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);</td></tr><tr><td>187</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC187%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E9%87%8D%E5%A4%8D%E7%9A%84DNA%E5%BA%8F%E5%88%97.md" target="_blank" rel="noopener">重复的 DNA 序列</a></td><td>放后</td><td></td></tr><tr><td>191</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC191%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0.md" target="_blank" rel="noopener">位1的个数</a></td><td></td><td>count += n &amp; 1; n = n &gt;&gt; 1;</td></tr><tr><td>199</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC199%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE.md" target="_blank" rel="noopener">二叉树的右视图</a></td><td></td><td></td></tr><tr><td>201</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC201%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E6%95%B0%E5%AD%97%E8%8C%83%E5%9B%B4%E6%8C%89%E4%BD%8D%E4%B8%8E.md" target="_blank" rel="noopener">数字范围按位与</a></td><td></td><td></td></tr><tr><td>203</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC203%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.md" target="_blank" rel="noopener">移除链表元素</a></td><td></td><td></td></tr><tr><td>206</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC206%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.md" target="_blank" rel="noopener">反转链表</a></td><td></td><td></td></tr><tr><td>209</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC209%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.md" target="_blank" rel="noopener">长度最小的子数组</a></td><td></td><td></td></tr><tr><td>219</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC219%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II.md" target="_blank" rel="noopener">存在重复元素 II</a></td><td></td><td></td></tr><tr><td>231</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC231%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A2%E7%9A%84%E5%B9%82.md" target="_blank" rel="noopener">2的幂</a></td><td></td><td>n&amp;(n-1)==0</td></tr><tr><td>237</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC237%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.md" target="_blank" rel="noopener">删除链表中的节点</a></td><td></td><td></td></tr><tr><td>239</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC239%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.md" target="_blank" rel="noopener">滑动窗口最大值</a></td><td>忽略</td><td></td></tr><tr><td>268</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC268%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97.md" target="_blank" rel="noopener">缺失数字</a></td><td></td><td>异或运算</td></tr><tr><td>279</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC279%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.md" target="_blank" rel="noopener">完全平方数</a></td><td>放后</td><td></td></tr><tr><td>283</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC283%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E7%A7%BB%E5%8A%A8%E9%9B%B6.md" target="_blank" rel="noopener">移动零</a></td><td></td><td>a[i]!=0  a[k++]=a[i];</td></tr><tr><td>295</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC295%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.md" target="_blank" rel="noopener">数据流的中位数</a></td><td>忽略</td><td></td></tr><tr><td>301</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC301%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%88%A0%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.md" target="_blank" rel="noopener">删除无效的括号</a></td><td>忽略</td><td></td></tr><tr><td>326</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC326%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A3%E7%9A%84%E5%B9%82.md" target="_blank" rel="noopener">3 的幂</a></td><td></td><td>3 的幂次的质因子只有 3</td></tr><tr><td>328</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC328%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8.md" target="_blank" rel="noopener">奇偶链表</a></td><td></td><td></td></tr><tr><td>342</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC342%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A4%E7%9A%84%E5%B9%82.md" target="_blank" rel="noopener">4的幂</a></td><td></td><td></td></tr><tr><td>344</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC344%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.md" target="_blank" rel="noopener">反转字符串</a></td><td></td><td></td></tr><tr><td>349</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC349%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.md" target="_blank" rel="noopener">两个数组的交集</a></td><td></td><td></td></tr><tr><td>350</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC350%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II.md" target="_blank" rel="noopener">两个数组的交集 II</a></td><td></td><td></td></tr><tr><td>445</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC445%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0II.md" target="_blank" rel="noopener">两数相加 II</a></td><td></td><td>双指针</td></tr><tr><td>447</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC447%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%9B%9E%E6%97%8B%E9%95%96%E7%9A%84%E6%95%B0%E9%87%8F.md" target="_blank" rel="noopener">回旋镖的数量</a></td><td>放后</td><td></td></tr><tr><td>454</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC454%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II.md" target="_blank" rel="noopener">四数相加 II</a></td><td>忽略</td><td></td></tr><tr><td>642</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC642%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%90%9C%E7%B4%A2%E8%87%AA%E5%8A%A8%E5%AE%8C%E6%88%90%E7%B3%BB%E7%BB%9F.md" target="_blank" rel="noopener">设计一个搜索自动完成系统</a></td><td>忽略</td><td></td></tr><tr><td>690</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC690%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%91%98%E5%B7%A5%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7.md" target="_blank" rel="noopener">员工的重要性</a></td><td></td><td>HashMap 队列 广度优先</td></tr><tr><td>877</td><td><a href="https://github.com/MisterBooo/LeetCodeAnimation/tree/master/notes/LeetCode%E7%AC%AC877%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F.md" target="_blank" rel="noopener">石子游戏</a></td><td>忽略</td><td></td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/09/10/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/14Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0Synchronzide/"/>
      <url>/2019/09/10/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/14Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0Synchronzide/</url>
      
        <content type="html"><![CDATA[<hr><p>title: 14Java虚拟机是如何实现Synchronzide<br>date: 2019-03-11 10:08:22<br>tags: [se,jvm]<br>categories: se<br>toc: true<br>—​    </p><p>monitorenter 和 monitorexit 的作用，我们可以抽象地理解为每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针。</p><p>当执行 monitorenter 时，如果目标锁对象的计数器为 0，那么说明它没有被其他线程所持有。在这个情况下，Java 虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加 1。</p><p>在目标锁对象的计数器不为 0 的情况下，如果锁对象的持有线程是当前线程，那么 Java 虚拟机可以将其计数器加 1，否则需要等待，直至持有线程释放该锁。</p><p>当执行 monitorexit 时，Java 虚拟机则需将锁对象的计数器减 1。当计数器减为 0 时，那便代表该锁已经被释放掉了。</p><p>之所以采用这种计数器的方式，是为了允许同一个线程重复获取同一把锁。举个例子，如果一个 Java 类中拥有多个 synchronized 方法，那么这些方法之间的相互调用，不管是直接的还是间接的，都会涉及对同一把锁的重复加锁操作。因此，我们需要设计这么一个可重入的特性，来避免编程里的隐式约束。</p><a id="more"></a><h1 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h1><p>重量级锁是 Java 虚拟机中最为基础的锁实现。在这种状态下，Java 虚拟机会阻塞加锁失败的线程，并且在目标锁被释放的时候，唤醒这些线程。</p><p>Java 线程的阻塞以及唤醒，都是依靠操作系统来完成的。举例来说，对于符合 posix 接口的操作系统（如 macOS 和绝大部分的 Linux），上述操作是通过 pthread 的互斥锁（mutex）来实现的。此外，这些操作将涉及系统调用，需要从操作系统的用户态切换至内核态，其开销非常之大。</p><h1 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h1><p>获取轻量锁的过程与偏向锁不同，竞争锁的线程首先需要拷贝对象头中的Mark Word到帧栈的锁记录中。拷贝成功后使用CAS操作尝试将对象的Mark Word更新为指向当前线程的指针。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁。如果更新失败，那么意味着有多个线程在竞争。 当竞争线程尝试占用轻量级锁失败多次之后（使用自旋）轻量级锁就会膨胀为重量级锁，重量级线程指针指向竞争线程，竞争线程也会阻塞，等待轻量级线程释放锁后唤醒他。</p><h1 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h1><p>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令。<br>当只有一个线程去竞争锁的时候，我们不需要阻塞，也不需要自旋，因为只有一个线程在竞争，我们只要去判断该偏向锁中的ThreadID是否为当前线程即可。如果是就执行同步代码，不是就尝试使用CAS修改ThreadID，修改成功执行同步代码，不成功就将偏向锁升级成轻量锁。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/HotSpot/Synchronization</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/09/10/aa_category/review/project/"/>
      <url>/2019/09/10/aa_category/review/project/</url>
      
        <content type="html"><![CDATA[<h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>  计算机专业，2012年毕业，16年到北京。第一家公司赢时胜主要做金融产品TA.2018年来到了京东，职位为小组长。主要参与的项目有常旅客、网关、慧销、辅营。参与了部门从0到1的过程</p><p>  特长，研究的比较深入的是jvm,mybatis,spring.</p><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><h3 id="常旅客"><a href="#常旅客" class="headerlink" title="常旅客"></a>常旅客</h3><p>京东的第一个项目。打通机、酒、火等各个业务线之间的数据。使用hash,求模的方式分表。使用责任链加策略的方式校验参数的合法性。设计的失败，使用数据库配置的方式做一些校验，每次上线的担惊受怕。关键信息尽量用配置文件，不要用数据库配置。如果用数据库配置也要有版本的概念</p><h4 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h4><p>主要实现了http转rpc协议。服务端、客户端。服务端功能有，json解析成map对象，降级，白名单、黑名单、mock、ab,泛化调用客户端的方法。客户端入参转换，方法调用，出参转换。</p><h3 id="慧销"><a href="#慧销" class="headerlink" title="慧销"></a>慧销</h3><h4 id="召回活动"><a href="#召回活动" class="headerlink" title="召回活动"></a>召回活动</h4><p>​     南京AI团队，把高潜用户发送到数据库。业务人员配置召回活动。到了召回触发时间分布式worker触发慧销系统。比如有两台机器，分布式worker,给A的参数是2个任务，任务号0，B的参数是2个任务，任务好1，考虑到不能重复发，采取取模的方式 给指定的用户发送短信和优惠券</p><h4 id="营销活动"><a href="#营销活动" class="headerlink" title="营销活动"></a>营销活动</h4><p>​    用户访问页面的时候根据用户活动以及配置的标签展示优惠券。不同的业务线可以设置不同的用户标标签。用户在指定时间访问A页面n次，访问B页面的时候展示优惠券。storm，和redis list 队列。key为用户标签，value为时间戳。判断30分钟访问3次。先看看队列大小是否够3，其次用当前时间 n-1 n-2  n-3 节点的时间是否小于等于30分钟。</p><p>缓存，使用二级缓存，接受一个请求，先看guaua是否命中，然后看redis，再看数据库。</p><p>幂等一致性</p><h3 id="辅营"><a href="#辅营" class="headerlink" title="辅营"></a>辅营</h3><h4 id="简单的规则引擎"><a href="#简单的规则引擎" class="headerlink" title="简单的规则引擎"></a>简单的规则引擎</h4><p>   规则，组件类型，值类型，值之间的关系。规则项，编码，标签，权重，比较方式。编码，值，比较方式。规则和规则直接的关系为&amp;</p><p>基于自研的轻量级规则引擎实现的辅助营收平台。可选套餐，配置规则元数据，基于规则元数据建立活动，根据业务线， 根据入参和规则匹配活动，如果匹配展示相关券，在业务线下单。辅营监控业务线订单MQ,根据订单状态发放优惠券</p><h4 id="指定规则"><a href="#指定规则" class="headerlink" title="指定规则"></a>指定规则</h4><p>根据业务线，查找活动，根据入参和规则匹配，如果匹配进行优惠券发放</p><h4 id="可选套餐"><a href="#可选套餐" class="headerlink" title="可选套餐"></a>可选套餐</h4><p>根据业务线，查找活动，根据入参和规则匹配，如果匹配展示优惠券，在业务线下单。辅营监控业务线订单MQ,根据订单状态发放优惠券</p><h4 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h4><p>   man端的某些统计功能使用到读写分离。</p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul><li>思考、坚持、英语、广度、深度、实战、认识一些大牛（占小狼、翟永超、梁桂钊、小马哥、大R  苯神、江南白衣）</li></ul><ul><li>看源码，知道功能，猜怎么实现的，查看源码验证自己的想法</li></ul><p>数据结构与算法之美、Linux性能优化实战、深入拆解Java虚拟机、MySQL实战</p><ul><li>应该明确描述我们在项目中解决的问题，包括技术难题和业务难题</li><li>STAR法则，即在什么情况下(Situation)，面临一项什么样的任务(Task)，采取了什么样的行动(Action)，达到了怎样的结果(Result)。</li><li>我们应该主动将问题引导向自己擅长的方面</li><li>只讲了项目的功能，而不讲过程中遇到的业务难点和技术难点</li><li>表述复杂问题时应该从宏观到微观。先从比较高的层次入手，划分大的模块，确定模块间的交互，然后再逐个模块地细化细节</li></ul><h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><ul><li><p>初级应聘者，基础知识扎实</p></li><li><p>中级应聘者，基础知识扎实，熟练使用框架</p></li><li><p>高级应聘者，基础知识扎实，熟练使用框架，可以修改框架</p></li></ul><h1 id="项目复盘"><a href="#项目复盘" class="headerlink" title="项目复盘"></a>项目复盘</h1><ul><li>明确项目的周期。</li><li>明确项目的价值。（为什么做这个项目，它解决了用户什么痛点，它带来什么价值？）</li><li>明确项目的功能。（这个项目涉及哪些功能？）</li><li>明确项目的技术。（这个项目用到哪些技术？）</li><li>明确个人在项目中的位置和作用。（你在这个项目的承担角色？）</li><li>明确项目的整体架构。</li><li>明确项目的优缺点,如果重新设计你会如何设计。</li><li>明确项目的亮点。（这个项目有什么亮点？）</li><li>明确技术成长。（你通过这个项目有哪些技术成长？）</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/09/10/aa_category/middleware/redis/%E5%AE%89%E8%A3%85/"/>
      <url>/2019/09/10/aa_category/middleware/redis/%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128</p><p>net.core.somaxconn= 1024 然后执行sysctl -p </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GC概述</title>
      <link href="/2019/06/11/aa_category/se/gc&amp;mem/%E6%A6%82%E8%BF%B0/"/>
      <url>/2019/06/11/aa_category/se/gc&amp;mem/%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="查看垃圾回收器"><a href="#查看垃圾回收器" class="headerlink" title="查看垃圾回收器"></a>查看垃圾回收器</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java  -XX:+PrintCommandLineFlags  -version</span><br><span class="line">-XX:InitialHeapSize=126504128 -XX:MaxHeapSize=2024066048 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br><span class="line">java version <span class="string">"1.8.0_151"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_151-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.151-b12, mixed mode)</span><br></pre></td></tr></table></figure><p>-XX:+UseParallelGC 新生代使用ParallerGC </p><a id="more"></a><h1 id="强制fullgc"><a href="#强制fullgc" class="headerlink" title="强制fullgc"></a>强制fullgc</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -histo:live &lt;pid&gt;</span><br></pre></td></tr></table></figure><h1 id="打印gc日志"><a href="#打印gc日志" class="headerlink" title="打印gc日志"></a>打印gc日志</h1><p>jinfo -flag UseParallelGC</p><h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><p><a href="https://blog.codecentric.de/en/2014/01/useful-jvm-flags-part-8-gc-logging/" target="_blank" rel="noopener">https://blog.codecentric.de/en/2014/01/useful-jvm-flags-part-8-gc-logging/</a></p><h2 id="PrintGC"><a href="#PrintGC" class="headerlink" title="PrintGC"></a>PrintGC</h2><p>Enables printing of messages at every GC. By default, this option is disabled.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure)  31143K-&gt;28042K(119808K), 0.0420462 secs]</span><br><span class="line">[GC (Allocation Failure)  59255K-&gt;59202K(151040K), 0.0149887 secs]</span><br><span class="line">[Full GC (Ergonomics)  59202K-&gt;59132K(196608K), 0.0178210 secs]</span><br></pre></td></tr></table></figure><h1 id="PrintGCDetails"><a href="#PrintGCDetails" class="headerlink" title="PrintGCDetails"></a>PrintGCDetails</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 31232K-&gt;5112K(36352K)] 31232K-&gt;27889K(119808K), 0.0400211 secs] [Times: user=0.00 sys=0.00, real=0.04 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 36221K-&gt;5112K(67584K)] 58998K-&gt;58562K(151040K), 0.0147648 secs] [Times: user=0.03 sys=0.02, real=0.02 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 5112K-&gt;0K(67584K)] [ParOldGen: 53449K-&gt;58483K(130560K)] 58562K-&gt;58483K(198144K), [Metaspace: 3654K-&gt;3654K(1056768K)], 0.0138515 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]</span><br></pre></td></tr></table></figure><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name">GC</span> (<span class="name">Allocation</span> Failure) [<span class="name">PSYoungGen:</span> <span class="number">31143</span>K-&gt;5099K(<span class="name">36352K</span>)] <span class="number">31143</span>K-&gt;28014K(<span class="name">119808K</span>), <span class="number">0.0225225</span> secs] [<span class="name">Times:</span> user=0.02 sys=0.00, real=0.02 secs] </span><br><span class="line">[<span class="name">GC</span> (<span class="name">Allocation</span> Failure) [<span class="name">PSYoungGen:</span> <span class="number">36297</span>K-&gt;5113K(<span class="name">67584K</span>)] <span class="number">59212</span>K-&gt;59110K(<span class="name">151040K</span>), <span class="number">0.0137243</span> secs] [<span class="name">Times:</span> user=0.01 sys=0.02, real=0.01 secs] </span><br><span class="line">[<span class="name">Full</span> GC (<span class="name">Ergonomics</span>) [<span class="name">PSYoungGen:</span> <span class="number">5113</span>K-&gt;0K(<span class="name">67584K</span>)] [<span class="name">ParOldGen:</span> <span class="number">53997</span>K-&gt;59027K(<span class="name">131584K</span>)] <span class="number">59110</span>K-&gt;59027K(<span class="name">199168K</span>), [<span class="name">Metaspace:</span> <span class="number">3655</span>K-&gt;3655K(<span class="name">1056768K</span>)], <span class="number">0.0159174</span> secs] [<span class="name">Times:</span> user=0.02 sys=0.00, real=0.02 secs]</span><br></pre></td></tr></table></figure><h2 id="PrintGC-amp-PrintGCDetails"><a href="#PrintGC-amp-PrintGCDetails" class="headerlink" title="PrintGC&amp;PrintGCDetails"></a>PrintGC&amp;PrintGCDetails</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen&#123;区域&#125;: 31205K&#123;回收前&#125;-&gt;5093K&#123;回收前&#125;(36352K&#123;该区域总容量&#125;)] 31205K&#123;堆前&#125;-&gt;28126K&#123;堆后&#125;(119808K&#123;堆总容量&#125;), 0.0126378 secs&#123;时间&#125;] [Times: user=0.00&#123;用户&#125; sys=0.03&#123;系统&#125;, real=0.01&#123;实际&#125; secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 36320K-&gt;5093K(67584K)] 59353K-&gt;59162K(151040K), 0.0128752 secs] [Times: user=0.02 sys=0.03, real=0.01 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 5093K-&gt;0K(67584K)] [ParOldGen: 54069K-&gt;59100K(135680K)] 59162K-&gt;59100K(203264K), [Metaspace: 3654K-&gt;3654K(1056768K)], 0.0226501 secs] [Times: user=0.03 sys=0.00, real=0.02 secs]</span><br></pre></td></tr></table></figure><h2 id="XX-PrintGCTimeStamps"><a href="#XX-PrintGCTimeStamps" class="headerlink" title="-XX:+PrintGCTimeStamps"></a>-XX:+PrintGCTimeStamps</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.284&#123;从jvm启动直到垃圾收集发生所经历的时间&#125;: [GC (Allocation Failure) [PSYoungGen: 31232K-&gt;5107K(36352K)] 31232K-&gt;27716K(119808K), 0.0131908 secs] [Times: user=0.00 sys=0.05, real=0.01 secs]</span><br></pre></td></tr></table></figure><p>  With <code>-XX:+PrintGCTimeStamps</code> a timestamp reflecting the real time passed in seconds since JVM </p><h2 id="XX-PrintGCDateStamps"><a href="#XX-PrintGCDateStamps" class="headerlink" title="-XX:+PrintGCDateStamps"></a>-XX:+PrintGCDateStamps</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span>T10:<span class="number">56</span>:<span class="number">27.863</span>+<span class="number">0800</span>: [GC (Allocation Failure)  <span class="number">31205</span>K-&gt;<span class="number">28094</span>K(<span class="number">119808</span>K), <span class="number">0.0149649</span> secs]</span><br></pre></td></tr></table></figure><h2 id="Xloggc"><a href="#Xloggc" class="headerlink" title="-Xloggc"></a>-Xloggc</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xloggc:C:\\Producer_gc.log</span><br></pre></td></tr></table></figure><h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><h3 id="XX-MaxTenuringThreshold-threshold"><a href="#XX-MaxTenuringThreshold-threshold" class="headerlink" title="-XX:MaxTenuringThreshold=threshold"></a>-XX:MaxTenuringThreshold=threshold</h3><p>Sets the maximum tenuring threshold for use in adaptive GC sizing. The largest value is 15. The default value is 15 for the parallel (throughput) collector, and 6 for the CMS collector.</p><h3 id="XX-PrintGCDetails"><a href="#XX-PrintGCDetails" class="headerlink" title="-XX:+PrintGCDetails"></a>-XX:+PrintGCDetails</h3><p>Enables printing of detailed messages at every GC. By default, this option is disabled.</p><h3 id="XX-PrintGCDateStamps-1"><a href="#XX-PrintGCDateStamps-1" class="headerlink" title="-XX:+PrintGCDateStamps"></a>-XX:+PrintGCDateStamps</h3><p>Enables printing of a date stamp at every GC. By default, this option is disabled.</p><h3 id="XX-PrintGCTimeStamps-1"><a href="#XX-PrintGCTimeStamps-1" class="headerlink" title="-XX:+PrintGCTimeStamps"></a>-XX:+PrintGCTimeStamps</h3><p>Enables printing of time stamps at every GC. By default, this option is disabled.</p><h3 id="XX-SurvivorRatio-ratio"><a href="#XX-SurvivorRatio-ratio" class="headerlink" title="-XX:SurvivorRatio=ratio"></a>-XX:SurvivorRatio=ratio</h3><p>Sets the ratio between eden space size and survivor space size. By default, this option is set to 8.</p><h3 id="XX-CMSInitiatingOccupancyFraction-percent"><a href="#XX-CMSInitiatingOccupancyFraction-percent" class="headerlink" title="-XX:CMSInitiatingOccupancyFraction=percent"></a>-XX:CMSInitiatingOccupancyFraction=percent</h3><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ul><li>熟悉算法</li><li>熟悉垃圾回收期</li><li>实际使用的垃圾回收是什么</li></ul>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> gc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性</title>
      <link href="/2019/05/12/aa_category/se/se8/"/>
      <url>/2019/05/12/aa_category/se/se8/</url>
      
        <content type="html"><![CDATA[<h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><p>java1.8引入的新类，用来判断是否小于1.8</p><a id="more"></a><h1 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有入参没有出参</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相当于返回另外一个实现类</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(after);</span><br><span class="line">    <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br></pre></td></tr></table></figure><h1 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有出参没有入参</span></span><br><span class="line"><span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h1 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有输入和输出</span></span><br><span class="line"><span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常追踪</title>
      <link href="/2019/05/12/aa_category/se/%E5%BC%82%E5%B8%B8%E8%BF%BD%E8%B8%AA/"/>
      <url>/2019/05/12/aa_category/se/%E5%BC%82%E5%B8%B8%E8%BF%BD%E8%B8%AA/</url>
      
        <content type="html"><![CDATA[<h1 id="ava-虚拟机工具接口（JVMTI）"><a href="#ava-虚拟机工具接口（JVMTI）" class="headerlink" title="ava 虚拟机工具接口（JVMTI）"></a>ava 虚拟机工具接口（JVMTI）</h1><p>JVMTI（Java Virtual Machine Tool Interface） 即指 Java 虚拟机工具接口， 它是一套由虚拟机直接提供的 native 接口， 它处于整<br>个 JPDA 体系的最底层， 所有调试功能本质上都需要通过 JVMTI 来提供。 通过这些接口， 开发人员不仅调试在该虚拟机上运行的<br>Java 程序， 还能查看它们运行的状态， 设置回调函数， 控制某些环境变量， 从而优化程序性能。</p><a id="more"></a><h1 id="Java-调试线协议（JDWP）"><a href="#Java-调试线协议（JDWP）" class="headerlink" title="Java 调试线协议（JDWP）"></a>Java 调试线协议（JDWP）</h1><p>JDWP（Java Debug Wire Protocol） 是一个为 Java 调试而设计的一个通讯交互协议， 它定义了调试器和被调试程序之间传递的信<br>息的格式。<br>在 JPDA 体系中， 作为前端（front-end） 的调试者（debugger） 进程和后端（back-end） 的被调试程序（debuggee） 进程之间<br>的交互数据的格式就是由 JDWP 来描述的， 它详细完整地定义了请求命令、 回应数据和错误代码， 保证了前端和后端的 JVMTI 和 JDI<br>的通信通畅。</p><h1 id="Java-调试接口（JDI）"><a href="#Java-调试接口（JDI）" class="headerlink" title="Java 调试接口（JDI）"></a>Java 调试接口（JDI）</h1><p>JDI（Java Debug Interface） 是三个模块中最高层的接口， 在多数的 JDK 中， 它是<br>由 Java 语言实现的。 JDI 由针对前端定义的接口组成， 通过它， 调试工具开发人员就能通过<br>前端虚拟机上的调试器来远程操控后端虚拟机上被调试程序的运行。 </p><h1 id="JVMTI"><a href="#JVMTI" class="headerlink" title="JVMTI"></a>JVMTI</h1><p>Start Load<br>Attach<br>Heap<br>Thread<br>Breakpoint</p><h1 id="Java-agent"><a href="#Java-agent" class="headerlink" title="Java agent"></a>Java agent</h1><p>APM Instrument</p><p>Spring AOP </p>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加载顺序</title>
      <link href="/2019/05/12/aa_category/ee/servlet/%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/"/>
      <url>/2019/05/12/aa_category/ee/servlet/%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>context-param -&gt; listener -&gt; filter -&gt; servlet</p><h1 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h1><h2 id="context-param"><a href="#context-param" class="headerlink" title="context-param"></a>context-param</h2><p>上下文初始化用到的参数</p><a id="more"></a><h1 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h1><h2 id="ServletContextListener"><a href="#ServletContextListener" class="headerlink" title="ServletContextListener"></a>ServletContextListener</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">contextInitialized</span><br><span class="line">contextDestroyed</span><br></pre></td></tr></table></figure><h2 id="HttpSessionListener"><a href="#HttpSessionListener" class="headerlink" title="HttpSessionListener"></a>HttpSessionListener</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sessionCreated</span><br><span class="line">sessionDestroyed</span><br></pre></td></tr></table></figure><h2 id="HttpSessionAttributeListener"><a href="#HttpSessionAttributeListener" class="headerlink" title="HttpSessionAttributeListener"></a>HttpSessionAttributeListener</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">attributeAdded</span><br><span class="line">attributeRemoved</span><br><span class="line">attributeReplaced</span><br></pre></td></tr></table></figure><h2 id="ServletRequestListener"><a href="#ServletRequestListener" class="headerlink" title="ServletRequestListener"></a>ServletRequestListener</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">requestInitialized</span></span><br><span class="line"><span class="attribute">requestDestroyed</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ee </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ee </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆外内存排查</title>
      <link href="/2019/05/12/aa_category/se/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E6%8E%92%E6%9F%A5/"/>
      <url>/2019/05/12/aa_category/se/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>有人反应线上服务端有一个进程的占用内存特别高，具体如下。</p><p>top命令如下：</p><p>PID USER PR NI VIRT <strong>RES</strong> SHR S %CPU %MEM TIME+ COMMAND<br>33801 admin 20 0 <strong>41.4g</strong> <strong>14g</strong> 10m S 5.0 5.8 4015:27 java</p><p>可以看到这个java进程占用的资源特别高。</p><a id="more"></a><h1 id="分析内存分布"><a href="#分析内存分布" class="headerlink" title="分析内存分布"></a>分析内存分布</h1><p>启动命令为：-server -Xms4096m -Xmx4096m -XX:MaxPermSize=256m </p><p>1.jmap -heap查看JVM占用内存大小</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`[admin@host-xxxx ~]$ jmap -heap <span class="number">33801</span>``Attaching to process ID <span class="number">33801</span>, please wait...``Debugger attached successfully.``Server compiler detected.``JVM version is <span class="number">20.0</span>-b11``using <span class="keyword">thread</span>-``local` `object allocation.``Parallel GC with <span class="number">43</span> <span class="keyword">thread</span>(s)``Heap Configuration:``   ``MinHeapFreeRatio = <span class="number">40</span>``   ``MaxHeapFreeRatio = <span class="number">70</span>``   ``MaxHeapSize      = <span class="number">4294967296</span> (<span class="number">4096.0</span>MB)``   ``NewSize          = <span class="number">1310720</span> (<span class="number">1.25</span>MB)``   ``MaxNewSize       = <span class="number">17592186044415</span> MB``   ``OldSize          = <span class="number">5439488</span> (<span class="number">5.1875</span>MB)``   ``NewRatio         = <span class="number">2</span>``   ``SurvivorRatio    = <span class="number">8</span>``   ``PermSize         = <span class="number">21757952</span> (<span class="number">20.75</span>MB)``   ``MaxPermSize      = <span class="number">268435456</span> (<span class="number">256.0</span>MB)``Heap Usage:``PS Young Generation``Eden Space:``   ``capacity = <span class="number">1402273792</span> (<span class="number">1337.3125</span>MB)``   ``used     = <span class="number">1305741520</span> (<span class="number">1245.2521514892578</span>MB)``   ``free`     `= <span class="number">96532272</span> (<span class="number">92.06034851074219</span>MB)``   ``<span class="number">93.11601824474518</span>% used``From Space:``   ``capacity = <span class="number">14680064</span> (<span class="number">14.0</span>MB)``   ``used     = <span class="number">0</span> (<span class="number">0.0</span>MB)``   ``free`     `= <span class="number">14680064</span> (<span class="number">14.0</span>MB)``   ``<span class="number">0.0</span>% used``To Space:``   ``capacity = <span class="number">14155776</span> (<span class="number">13.5</span>MB)``   ``used     = <span class="number">0</span> (<span class="number">0.0</span>MB)``   ``free`     `= <span class="number">14155776</span> (<span class="number">13.5</span>MB)``   ``<span class="number">0.0</span>% used``PS Old Generation``   ``capacity = <span class="number">2863333376</span> (<span class="number">2730.6875</span>MB)``   ``used     = <span class="number">78102656</span> (<span class="number">74.4844970703125</span>MB)``   ``free`     `= <span class="number">2785230720</span> (<span class="number">2656.2030029296875</span>MB)``   ``<span class="number">2.7276829395642124</span>% used``PS Perm Generation``   ``capacity = <span class="number">63176704</span> (<span class="number">60.25</span>MB)``   ``used     = <span class="number">62522104</span> (<span class="number">59.62572479248047</span>MB)``   ``free`     `= <span class="number">654600</span> (<span class="number">0.6242752075195312</span>MB)``   ``<span class="number">98.96385857673107</span>% used`</span><br></pre></td></tr></table></figure><p>可以看到堆内内存正常，没有超过4G，说明大部分内存都是堆外内存。</p><ol start="2"><li>查看堆外内存情况</li></ol><p>网上都推荐使用google-perftools来跟踪，但是需要重启应用。我们先不重启，直接dump内存分析下。</p><p>执行 pmap </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`[<span class="symbol">admin@</span>host-xxx~]$ pmap <span class="number">33801</span> &gt; <span class="number">33801.</span>txt``[<span class="symbol">admin@</span>host-xxx~]$ ``cat` `<span class="number">33801</span> | ``more``Address           Kbytes     RSS   Dirty Mode   Mapping``<span class="number">0000000040000000</span>      <span class="number">36</span>      <span class="number">36</span>       <span class="number">0</span> r-x--  java``<span class="number">0000000040108000</span>       <span class="number">8</span>       <span class="number">8</span>       <span class="number">8</span> rwx--  java``<span class="number">0000000040</span>b6d000     <span class="number">132</span>       <span class="number">8</span>       <span class="number">8</span> rwx--    [ anon ]``……``<span class="number">00007f</span>2c74000000  <span class="number">131072</span>  <span class="number">131072</span>  <span class="number">131072</span> rwx--    [ anon ]``<span class="number">00007f</span>2c7c000000  <span class="number">131072</span>  <span class="number">131072</span>  <span class="number">131072</span> rwx--    [ anon ]``<span class="number">00007f</span>2c84000000  <span class="number">131072</span>  <span class="number">131072</span>  <span class="number">131072</span> rwx--    [ anon ]``<span class="number">00007f</span>2c8c000000  <span class="number">131072</span>  <span class="number">131072</span>  <span class="number">131072</span> rwx--    [ anon ]``<span class="number">00007f</span>2c94000000  <span class="number">131072</span>  <span class="number">131072</span>  <span class="number">131072</span> rwx--    [ anon ]``……``……`</span><br></pre></td></tr></table></figure><p>其中看见不少 128M的内存块。  比较可疑</p><ol start="3"><li>dump内存块</li></ol><p>使用 gdb进行内存dump。如果没有，则需要安装 yum install gdb。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`[admin@host-xxx ~]$ gdb --pid <span class="number">33801</span>``……``Reading symbols from ``/export/Domains/follow``.soa.jd.com``/server1/temp/libnetty-transport-native-epoll4107761723280840577``.so...(no debugging symbols found)...``done``.``Loaded symbols ``for` `/export/Domains/follow``.soa.jd.com``/server1/temp/libnetty-transport-native-epoll4107761723280840577``.so``<span class="number">0</span>x00007f3206fa522d ``in` `pthread_join () from ``/lib64/libpthread``.so.<span class="number">0</span>``Missing separate debuginfos, use: debuginfo-``install` `glibc-<span class="number">2.12</span>-<span class="number">1.149</span>.el6.x86_64``(gdb) ``看到这个代表可以进行调试``然后外面找刚才的一段地址（前面加上<span class="number">0</span>x）进行dump``(gdb) dump binary memory .``/<span class="number">33801</span>_1``.dat <span class="number">0</span>x00007f2c74000000 <span class="number">0</span>x00007f2c7c000000`  `dump完 按q 退出``(gdb) q``A debugging session is active.``    ``Inferior <span class="number">1</span> [process <span class="number">33801</span>] will be detached.``Quit anyway? (y <span class="literal">or</span> n) y`</span><br></pre></td></tr></table></figure><p>这样我们就拿到了一个内存dump文件。可以通过16进制大概看看里面的内容。</p><ol start="4"><li>分析内存块。</li></ol><p>使用hexdump或者 下载下来拿UltraEdit EditPlus都可以看16进制文件。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`[<span class="symbol">admin@</span>host-xxxx ~]$ hexdump -e ``<span class="string">'16/1 "%02X " " | "'</span>` `-e ``<span class="string">'16/1 "%_p" "\n"'</span>` `.``/<span class="number">33801</span>_1``.dat  | ``more``<span class="number">20</span> <span class="number">00</span> <span class="number">00</span> <span class="number">98</span> <span class="number">2</span>D <span class="number">7</span>F <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">80</span> <span class="number">2</span>C <span class="number">7</span>F <span class="number">00</span> <span class="number">00</span> |  ...-.......,...``<span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> | ................``<span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">45</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> | ........E.......``<span class="number">45</span> <span class="number">72</span> <span class="number">72</span> <span class="number">6</span>F <span class="number">72</span> <span class="number">20</span> <span class="number">77</span> <span class="number">68</span> <span class="number">69</span> <span class="number">6</span>C <span class="number">65</span> <span class="number">20</span> <span class="number">72</span> <span class="number">65</span> <span class="number">61</span> <span class="number">64</span> | Error ``<span class="keyword">while</span>` `read``<span class="number">28</span> <span class="number">2</span>E <span class="number">2</span>E <span class="number">2</span>E <span class="number">29</span> <span class="number">3</span>A <span class="number">20</span> <span class="number">43</span> <span class="number">6</span>F <span class="number">6</span>E <span class="number">6</span>E <span class="number">65</span> <span class="number">63</span> <span class="number">74</span> <span class="number">69</span> <span class="number">6</span>F | (...): Connectio``<span class="number">6</span>E <span class="number">20</span> <span class="number">72</span> <span class="number">65</span> <span class="number">73</span> <span class="number">65</span> <span class="number">74</span> <span class="number">20</span> <span class="number">62</span> <span class="number">79</span> <span class="number">20</span> <span class="number">70</span> <span class="number">65</span> <span class="number">65</span> <span class="number">72</span> <span class="number">00</span> | n reset by peer.``<span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">45</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> | ........E.......``<span class="number">45</span> <span class="number">72</span> <span class="number">72</span> <span class="number">6</span>F <span class="number">72</span> <span class="number">20</span> <span class="number">77</span> <span class="number">68</span> <span class="number">69</span> <span class="number">6</span>C <span class="number">65</span> <span class="number">20</span> <span class="number">72</span> <span class="number">65</span> <span class="number">61</span> <span class="number">64</span> | Error ``<span class="keyword">while</span>` `read``<span class="number">28</span> <span class="number">2</span>E <span class="number">2</span>E <span class="number">2</span>E <span class="number">29</span> <span class="number">3</span>A <span class="number">20</span> <span class="number">43</span> <span class="number">6</span>F <span class="number">6</span>E <span class="number">6</span>E <span class="number">65</span> <span class="number">63</span> <span class="number">74</span> <span class="number">69</span> <span class="number">6</span>F | (...): Connectio``<span class="number">6</span>E <span class="number">20</span> <span class="number">72</span> <span class="number">65</span> <span class="number">73</span> <span class="number">65</span> <span class="number">74</span> <span class="number">20</span> <span class="number">62</span> <span class="number">79</span> <span class="number">20</span> <span class="number">70</span> <span class="number">65</span> <span class="number">65</span> <span class="number">72</span> <span class="number">00</span> | n reset by peer.``<span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">45</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> | ........E.......``<span class="number">45</span> <span class="number">72</span> <span class="number">72</span> <span class="number">6</span>F <span class="number">72</span> <span class="number">20</span> <span class="number">77</span> <span class="number">68</span> <span class="number">69</span> <span class="number">6</span>C <span class="number">65</span> <span class="number">20</span> <span class="number">72</span> <span class="number">65</span> <span class="number">61</span> <span class="number">64</span> | Error ``<span class="keyword">while</span>` `read``<span class="number">28</span> <span class="number">2</span>E <span class="number">2</span>E <span class="number">2</span>E <span class="number">29</span> <span class="number">3</span>A <span class="number">20</span> <span class="number">43</span> <span class="number">6</span>F <span class="number">6</span>E <span class="number">6</span>E <span class="number">65</span> <span class="number">63</span> <span class="number">74</span> <span class="number">69</span> <span class="number">6</span>F | (...): Connectio``<span class="number">6</span>E <span class="number">20</span> <span class="number">72</span> <span class="number">65</span> <span class="number">73</span> <span class="number">65</span> <span class="number">74</span> <span class="number">20</span> <span class="number">62</span> <span class="number">79</span> <span class="number">20</span> <span class="number">70</span> <span class="number">65</span> <span class="number">65</span> <span class="number">72</span> <span class="number">00</span> | n reset by peer.``<span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">45</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> | ........E.......`</span><br></pre></td></tr></table></figure><p>里面全是 ……..E……. Error while read(…): Connection reset by peer.</p><p>好像是一个对象，里面的字符串是 Error while read(…): Connection reset by peer.</p><h1 id="分析数据来源"><a href="#分析数据来源" class="headerlink" title="分析数据来源"></a>分析数据来源</h1><p>程序有Dubbo，mq使用了Netty4，zookeeper使用了Netty3。 这几个都有可能申请堆外内存。</p><p>搜索字符串“Error while read”</p><p>搜索netty4.0.24的源码 <strong>发现</strong>了该字符串：</p><p><strong>transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`jint read0(JNIEnv * env, jclass clazz, jint fd, `</span><span class="string">`void`</span> <span class="string">`*buffer, jint pos, jint limit) &#123;`</span><span class="string">`    `</span><span class="string">`ssize_t res;`</span><span class="string">`    `</span><span class="string">`int`</span> <span class="string">`err;`</span><span class="string">`    `</span><span class="string">`do`</span> <span class="string">`&#123;`</span><span class="string">`        `</span><span class="string">`res = read(fd, buffer + pos, (`</span><span class="string">`size_t`</span><span class="string">`) (limit - pos));`</span><span class="string">`        `</span><span class="string">`// Keep on reading if we was interrupted`</span><span class="string">`    `</span><span class="string">`&#125; `</span><span class="string">`while`</span> <span class="string">`(res == -1 &amp;&amp; ((err = `</span><span class="string">`errno`</span><span class="string">`) == EINTR));`</span> <span class="string">`    `</span><span class="string">`if`</span> <span class="string">`(res &lt; 0) &#123;`</span><span class="string">`        `</span><span class="string">`if`</span> <span class="string">`(err == EAGAIN || err == EWOULDBLOCK) &#123;`</span><span class="string">`            `</span><span class="string">`// Nothing left to read`</span><span class="string">`            `</span><span class="string">`return`</span> <span class="string">`0;`</span><span class="string">`        `</span><span class="string">`&#125;`</span><span class="string">`        `</span><span class="string">`if`</span> <span class="string">`(err == EBADF) &#123;`</span><span class="string">`            `</span><span class="string">`throwClosedChannelException(env);`</span><span class="string">`            `</span><span class="string">`return`</span> <span class="string">`-1;`</span><span class="string">`        `</span><span class="string">`&#125;`</span><span class="string">`        `</span><span class="string">`throwIOException(env, exceptionMessage(`</span><span class="string">`"Error while read(...): "`</span><span class="string">`, err));`</span><span class="string">`        `</span><span class="string">`return`</span> <span class="string">`-1;`</span><span class="string">`    `</span><span class="string">`&#125;`</span> <span class="string">`    `</span><span class="string">`if`</span> <span class="string">`(res == 0) &#123;`</span><span class="string">`        `</span><span class="string">`// end-of-stream`</span><span class="string">`        `</span><span class="string">`return`</span> <span class="string">`-1;`</span><span class="string">`    `</span><span class="string">`&#125;`</span><span class="string">`    `</span><span class="string">`return`</span> <span class="string">`(jint) res;`</span><span class="string">`&#125;`</span></span><br></pre></td></tr></table></figure><p>分析源码：如果使用了epoll，客户端连上服务端又断开，就会触发这个异常。</p><p>继续查看Netty源码和ReleaseNote，发现在4.0.25版本 已经优化掉了这个东西。</p><p>参见：<a href="http://netty.io/news/2014/12/31/4-0-25-Final.html" target="_blank" rel="noopener">http://netty.io/news/2014/12/31/4-0-25-Final.html</a></p><p><a href="https://github.com/netty/netty/pull/3227" target="_blank" rel="noopener">https://github.com/netty/netty/pull/3227</a></p><p><a href="https://source.jboss.org/changelog/Netty?cs=c0e889ae543e291f03f003485ee54dd281945ec6&amp;_sscc=t" target="_blank" rel="noopener">https://source.jboss.org/changelog/Netty?cs=c0e889ae543e291f03f003485ee54dd281945ec6&amp;_sscc=t</a></p><h1 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h1><p>1.测试关闭epoll是否会重现此问题。——-关闭后正常</p><p>2.更新netty版本，看是否解决。———解决</p><h1 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h1><p>1.单独升级Netty4的版本。</p>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射常用类</title>
      <link href="/2019/05/12/aa_category/se/reflect/%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
      <url>/2019/05/12/aa_category/se/reflect/%E5%B8%B8%E7%94%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="AnnotatedElement"><a href="#AnnotatedElement" class="headerlink" title="AnnotatedElement"></a>AnnotatedElement</h1><h1 id="getAnnotation"><a href="#getAnnotation" class="headerlink" title="getAnnotation"></a>getAnnotation</h1><ul><li>可以获取父类声明上的注解<a id="more"></a></li></ul><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><h3 id="isBridge"><a href="#isBridge" class="headerlink" title="isBridge"></a>isBridge</h3><p>一个子类在继承（或实现）一个父类（或接口）的泛型方法时，在子类中明确指定了泛型类型，那么在编译时编译器会自动生成桥接方法（当然还有其他情况会生成桥接方法，这里只是列举了其中一种情况）</p>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> reflect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mat</title>
      <link href="/2019/05/12/aa_category/tool/mat/"/>
      <url>/2019/05/12/aa_category/tool/mat/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/trust-freedom/p/6744948.html" target="_blank" rel="noopener">https://www.cnblogs.com/trust-freedom/p/6744948.html</a></p><p>with outGoing references  当前对象，引用了外部对象</p><p>with incoming references  当前查看的对象，被外部应用</p><p>Retained size：是该对象自己的 shallow size，加上从该对象能直接或间接访问到对象的 shallow size 之和。换句话说，retained size 是该对象被 GC 之后所能回收到内存的总和。</p>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jstat</title>
      <link href="/2019/05/12/aa_category/se/gc&amp;mem/jstat%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/05/12/aa_category/se/gc&amp;mem/jstat%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK-Tools-and-Utilities"><a href="#JDK-Tools-and-Utilities" class="headerlink" title="JDK Tools and Utilities"></a>JDK Tools and Utilities</h1><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html</a></p><a id="more"></a><h1 id="类加载统计"><a href="#类加载统计" class="headerlink" title="类加载统计"></a>类加载统计</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstat -class 172334</span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     Time   </span><br><span class="line"> 11658 23107.3        1     1.0      16.03</span><br></pre></td></tr></table></figure><ul><li>Loaded:加载class的数量</li><li>Bytes：所占用空间大小</li><li>Unloaded：未加载数量</li><li>Bytes:未加载占用空间</li><li>Time：时间</li></ul><h1 id="编译统计"><a href="#编译统计" class="headerlink" title="编译统计"></a>编译统计</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstat -compiler  172334</span><br><span class="line">Compiled Failed Invalid   Time   FailedType FailedMethod</span><br><span class="line">   14198      6       0   272.07          1 com/mysql/jdbc/AbandonedConnectionCleanupThread run</span><br></pre></td></tr></table></figure><ul><li>Compiled：编译数量。</li><li>Failed：失败数量</li><li>Invalid：不可用数量</li><li>Time：时间</li><li>FailedType：失败类型</li><li>FailedMethod：失败的方法</li></ul><h1 id="垃圾回收统计"><a href="#垃圾回收统计" class="headerlink" title="垃圾回收统计"></a>垃圾回收统计</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc  427623</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">8192.0 8704.0  0.0   896.0  331264.0 270063.5  699392.0   120920.8  75136.0 73687.3 8320.0 8042.8     89    4.616   3      4.195    8.810</span><br></pre></td></tr></table></figure><ul><li>S0C：第一个幸存区的大小</li><li>S1C：第二个幸存区的大小</li><li>S0U：第一个幸存区的使用大小</li><li>S1U：第二个幸存区的使用大小</li><li>EC：伊甸园区的大小</li><li>EU：伊甸园区的使用大小</li><li>OC：老年代大小</li><li>OU：老年代使用大小</li><li>MC：方法区大小</li><li>MU：方法区使用大小</li><li>CCSC:压缩类空间大小</li><li>CCSU:压缩类空间使用大小</li><li>YGC：年轻代垃圾回收次数</li><li>YGCT：年轻代垃圾回收消耗时间</li><li>FGC：老年代垃圾回收次数</li><li>FGCT：老年代垃圾回收消耗时间</li><li>GCT：垃圾回收消耗总时间</li></ul><h1 id="堆内存统计"><a href="#堆内存统计" class="headerlink" title="堆内存统计"></a>堆内存统计</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstat -gccapacity   427623</span><br><span class="line"> NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC       MCMN     MCMX      MC     CCSMN    CCSMX     CCSC    YGC    FGC </span><br><span class="line">349184.0 349184.0 349184.0 8192.0 7680.0 333312.0   699392.0   699392.0   699392.0   699392.0      0.0 1116160.0  75136.0      0.0 1048576.0   8320.0     90     3</span><br></pre></td></tr></table></figure><ul><li>NGCMN：新生代最小容量</li><li>NGCMX：新生代最大容量</li><li>NGC：当前新生代容量</li><li>S0C：第一个幸存区大小</li><li>S1C：第二个幸存区的大小</li><li>EC：伊甸园区的大小</li><li>OGCMN：老年代最小容量</li><li>OGCMX：老年代最大容量</li><li>OGC：当前老年代大小</li><li>OC:当前老年代大小</li><li>MCMN:最小元数据容量</li><li>MCMX：最大元数据容量</li><li>MC：当前元数据空间大小</li><li>CCSMN：最小压缩类空间大小</li><li>CCSMX：最大压缩类空间大小</li><li>CCSC：当前压缩类空间大小</li><li>YGC：年轻代gc次数</li><li>FGC：老年代GC次数</li></ul><p>346112</p><p>70057</p>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java命令</title>
      <link href="/2019/05/12/aa_category/se/gc&amp;mem/java_option/"/>
      <url>/2019/05/12/aa_category/se/gc&amp;mem/java_option/</url>
      
        <content type="html"><![CDATA[<p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a><br><a href="http://openjdk.java.net/jeps/122" target="_blank" rel="noopener">http://openjdk.java.net/jeps/122</a></p><a id="more"></a><h1 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h1><h2 id="XX-TraceClassLoading"><a href="#XX-TraceClassLoading" class="headerlink" title="-XX:+TraceClassLoading"></a>-XX:+TraceClassLoading</h2><p>Enables tracing of classes as they are loaded. By default, this option is disabled and classes are not traced.</p><h1 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h1><p><a href="https://blog.sokolenko.me/2014/11/javavm-options-production.html" target="_blank" rel="noopener">https://blog.sokolenko.me/2014/11/javavm-options-production.html</a></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">-server</span><br><span class="line">-Xms&lt;heap size&gt;[g|m|k] -Xmx&lt;heap size&gt;[g|m|k]</span><br><span class="line"><span class="comment">//Sets the initial size (in bytes) of the heap.   Specifies the maximum size (in bytes) of the memory allocation pool in bytes</span></span><br><span class="line"></span><br><span class="line">-<span class="string">XX:</span>MaxMetaspaceSize=&lt;metaspace size&gt;[g|m|k]</span><br><span class="line"><span class="comment">//Sets the maximum amount of native memory that can be allocated for class metadata.</span></span><br><span class="line"></span><br><span class="line">-Xmn&lt;young size&gt;[g|m|k]</span><br><span class="line"><span class="comment">//Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery)   eden+ 2 survivor space.</span></span><br><span class="line">-Xss</span><br><span class="line"><span class="comment">//Sets the thread stack size (in bytes).</span></span><br><span class="line">-<span class="string">XX:</span>SurvivorRatio=&lt;ratio&gt;</span><br><span class="line"><span class="comment">// Sets the ratio between eden space size and survivor space size.</span></span><br><span class="line"></span><br><span class="line">-<span class="string">XX:</span>+UseConcMarkSweepGC -<span class="string">XX:</span>+CMSParallelRemarkEnabled</span><br><span class="line"><span class="comment">// Enables the use of the CMS garbage collector for the old generation.</span></span><br><span class="line"></span><br><span class="line">-<span class="string">XX:</span>+UseCMSInitiatingOccupancyOnly -<span class="string">XX:</span>CMSInitiatingOccupancyFraction=&lt;percent&gt;</span><br><span class="line"></span><br><span class="line">-<span class="string">XX:</span>+ScavengeBeforeFullGC -<span class="string">XX:</span>+CMSScavengeBeforeRemark</span><br><span class="line"><span class="comment">//Enables GC of the young generation before each full GC.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-<span class="string">XX:</span>+PrintGCDateStamps -<span class="string">verbose:</span>gc -<span class="string">XX:</span>+PrintGCDetails -<span class="string">Xloggc:</span><span class="string">"&lt;path to log&gt;"</span></span><br><span class="line"></span><br><span class="line">-<span class="string">XX:</span>+UseGCLogFileRotation -<span class="string">XX:</span>NumberOfGCLogFiles=<span class="number">10</span> -<span class="string">XX:</span>GCLogFileSize=<span class="number">100</span>M</span><br><span class="line">-Dsun.net.inetaddr.ttl=&lt;TTL <span class="keyword">in</span> seconds&gt;</span><br><span class="line"></span><br><span class="line">-<span class="string">XX:</span>+HeapDumpOnOutOfMemoryError -<span class="string">XX:</span>HeapDumpPath=&lt;path to dump&gt;`date`.hprof</span><br><span class="line"><span class="comment">//Enables the dumping of the Java heap to a file in the current directory by using the heap profiler (HPROF) when a java.lang.OutOfMemoryError exception is thrown.</span></span><br><span class="line"></span><br><span class="line">-Djava.rmi.server.hostname=&lt;external IP&gt;</span><br><span class="line">-Dcom.sun.management.jmxremote.port=&lt;port&gt; </span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate=<span class="literal">false</span> </span><br><span class="line">-Dcom.sun.management.jmxremote.ssl=<span class="literal">false</span></span><br></pre></td></tr></table></figure><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h3 id="XX-MinHeapFreeRatio"><a href="#XX-MinHeapFreeRatio" class="headerlink" title="XX:MinHeapFreeRatio"></a>XX:MinHeapFreeRatio</h3><p>Sets the minimum allowed percentage of free heap space (0 to 100) after a GC event. If free heap space falls below this value, then the heap will be expanded. By default, this value is set to 40%.</p><h3 id="XX-MaxHeapFreeRatio"><a href="#XX-MaxHeapFreeRatio" class="headerlink" title="-XX:MaxHeapFreeRatio"></a>-XX:MaxHeapFreeRatio</h3><p>Sets the maximum allowed percentage of free heap space (0 to 100) after a GC event. If free heap space expands above this value, then the heap will be shrunk</p><h3 id="XX-NewRatio-ratio"><a href="#XX-NewRatio-ratio" class="headerlink" title="-XX:NewRatio=ratio"></a>-XX:NewRatio=ratio</h3><p>Sets the ratio between young and old generation sizes. By default, this option is set to 2.</p><h3 id="XX-NewSize-size"><a href="#XX-NewSize-size" class="headerlink" title="-XX:NewSize=size"></a>-XX:NewSize=size</h3><ul><li>Sets the initial size (in bytes) of the heap for the young generation (nursery)</li><li>The -XX:NewSize option is equivalent to -Xmn.</li></ul><h3 id="XX-MaxPermSize-size"><a href="#XX-MaxPermSize-size" class="headerlink" title="-XX:MaxPermSize=size"></a>-XX:MaxPermSize=<em>size</em></h3><p>Sets the maximum permanent generation space size (in bytes). This option was deprecated in JDK 8, and superseded by the -XX:MaxMetaspaceSize option.</p><h3 id="XX-MaxMetaspaceSize-size"><a href="#XX-MaxMetaspaceSize-size" class="headerlink" title="-XX:MaxMetaspaceSize=size"></a>-XX:MaxMetaspaceSize=size</h3><p>Sets the maximum amount of native memory that can be allocated for class metadata. By default, the size is not limited.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxMetaspaceSize=256m</span><br></pre></td></tr></table></figure><h3 id="XX-MetaspaceSize-size"><a href="#XX-MetaspaceSize-size" class="headerlink" title="-XX:MetaspaceSize=size"></a>-XX:MetaspaceSize=size</h3><p>Sets the size of the allocated class metadata space that will trigger a garbage collection the first time it is exceeded. This threshold for a garbage collection is increased or decreased depending on the amount of metadata used. The default size depends on the platform</p><h3 id="XX-CompressedClassSpaceSize-128m"><a href="#XX-CompressedClassSpaceSize-128m" class="headerlink" title="-XX:CompressedClassSpaceSize=128m"></a>-XX:CompressedClassSpaceSize=128m</h3><h1 id="江南白衣"><a href="#江南白衣" class="headerlink" title="江南白衣"></a>江南白衣</h1><p><a href="http://calvin1978.blogcn.com" target="_blank" rel="noopener">http://calvin1978.blogcn.com</a></p><h3 id="XX-PrintFlagsFinal"><a href="#XX-PrintFlagsFinal" class="headerlink" title="-XX:+PrintFlagsFinal"></a>-XX:+PrintFlagsFinal</h3><p>打印参数值</p><h3 id="XX-UseBiasedLocking"><a href="#XX-UseBiasedLocking" class="headerlink" title="-XX:-UseBiasedLocking"></a>-XX:-UseBiasedLocking</h3><h3 id="XX-AutoBoxCacheMax-20000"><a href="#XX-AutoBoxCacheMax-20000" class="headerlink" title="-XX:AutoBoxCacheMax=20000"></a>-XX:AutoBoxCacheMax=20000</h3>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM常用命令整理</title>
      <link href="/2019/05/12/aa_category/se/gc&amp;mem/JVM%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
      <url>/2019/05/12/aa_category/se/gc&amp;mem/JVM%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="看对象数量"><a href="#看对象数量" class="headerlink" title="看对象数量"></a>看对象数量</h4><p>jmap -histo [pid]&gt;jmaphisto.log<br>jmap -F -histo [pid]&gt;jmaphisto.log    服务已死加 -F<br>jmap -histo:live [pid]&gt;jmaphisto.log    只看存活（会触发fullgc再导出）</p><a id="more"></a><h4 id="看内存Dump"><a href="#看内存Dump" class="headerlink" title="看内存Dump"></a>看内存Dump</h4><p>jmap dump:format=b,file=jmapdump.hprof [pid]<br>jmap -F -dump:format=b,file=jmapdump.hprof [pid]<br>tar zcvf jmapdump.hprof.tar.gz jmapdump.hprof</p><h4 id="看GC情况"><a href="#看GC情况" class="headerlink" title="看GC情况"></a>看GC情况</h4><p>jstat -gccapacity<br>jstat -gcutil [pid] 1000 100   每1000毫秒看内存情况，持续100次</p><p>指标解释：<br>S0 — Heap上的 Survivor space 0 区已使用空间的百分比<br>S1 — Heap上的 Survivor space 1 区已使用空间的百分比<br>E — Heap上的 Eden space 区已使用空间的百分比<br>O — Heap上的 Old space 区已使用空间的百分比<br>P — Perm space 区已使用空间的百分比<br>YGC — 从应用程序启动到采样时发生 Young GC 的次数<br>YGCT– 从应用程序启动到采样时 Young GC 所用的时间(单位秒)<br>FGC — 从应用程序启动到采样时发生 Full GC 的次数<br>FGCT– 从应用程序启动到采样时 Full GC 所用的时间(单位秒)<br>GCT — 从应用程序启动到采样时用于垃圾回收的总时间(单位秒)</p><h4 id="看线程堆栈"><a href="#看线程堆栈" class="headerlink" title="看线程堆栈"></a>看线程堆栈</h4><p>jstack [pid] &gt;jstack.log<br>jstack -F [pid] &gt;jstack.log   服务已死加 -F<br>jstack -F -m [pid] &gt;jstack.log<br>jstack -F -m -l [pid] &gt;jstack.log</p><h4 id="看线程的资源情况"><a href="#看线程的资源情况" class="headerlink" title="看线程的资源情况"></a>看线程的资源情况</h4><p>pstree [pid]  打印进程的线程使用情况<br>top  看资源使用情况<br>top -Hp [pid]      看进程内线程资源情况<br>转为16进制配合jstack可查询线程cpu情况</p>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java问题排查工具单</title>
      <link href="/2019/05/12/aa_category/se/Java%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E5%B7%A5%E5%85%B7%E5%8D%95/"/>
      <url>/2019/05/12/aa_category/se/Java%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E5%B7%A5%E5%85%B7%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux命令类"><a href="#Linux命令类" class="headerlink" title="Linux命令类"></a>Linux命令类</h1><h2 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h2><p>tail -300f shopbase.log</p><a id="more"></a><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grep forest f.txt     <span class="comment">#文件查找</span></span><br><span class="line">grep forest f.txt cpf.txt <span class="comment">#多文件查找</span></span><br><span class="line">grep <span class="string">'log'</span> /home/admin -r -n <span class="comment">#目录下查找所有符合关键字的文件</span></span><br><span class="line">cat f.txt | grep -i shopbase</span><br><span class="line">grep <span class="string">'shopbase'</span> /home/admin -r -n --include *.&#123;vm,java&#125; <span class="comment">#指定文件后缀</span></span><br><span class="line">grep <span class="string">'shopbase'</span> /home/admin -r -n --exclude *.&#123;vm,java&#125; <span class="comment">#反匹配</span></span><br><span class="line">seq 10 | grep 5 -A 3    <span class="comment">#上匹配</span></span><br><span class="line">seq 10 | grep 5 -B 3    <span class="comment">#下匹配</span></span><br><span class="line">seq 10 | grep 5 -C 3    <span class="comment">#上下匹配，平时用这个就妥了</span></span><br><span class="line">cat f.txt | grep -c <span class="string">'SHOPBASE'</span></span><br></pre></td></tr></table></figure><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p>1 基础命令jmap </p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123;<span class="keyword">print</span> <span class="variable">$4</span>,<span class="variable">$6&#125;</span>' f.txt</span><br><span class="line">awk '&#123;<span class="keyword">print</span> NR,<span class="variable">$0&#125;</span>' f.txt cpf.txt</span><br><span class="line">awk '&#123;<span class="keyword">print</span> FNR,<span class="variable">$0&#125;</span>' f.txt cpf.txt</span><br><span class="line">awk '&#123;<span class="keyword">print</span> FNR,FILENAME,<span class="variable">$0&#125;</span>' f.txt cpf.txt</span><br><span class="line">awk '&#123;<span class="keyword">print</span> FILENAME,<span class="string">"NR="</span>NR,<span class="string">"FNR="</span>FNR,<span class="string">"$"</span>NF<span class="string">"="</span><span class="variable">$NF&#125;</span>' f.txt cpf.txt</span><br><span class="line">echo 1:2:3:4 | awk -F: '&#123;<span class="keyword">print</span> <span class="variable">$1</span>,<span class="variable">$2</span>,<span class="variable">$3</span>,<span class="variable">$4&#125;</span>'</span><br></pre></td></tr></table></figure><p>2 匹配</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'/ldb/ &#123;print&#125;'</span> f<span class="selector-class">.txt</span>   #匹配ldb</span><br><span class="line">awk <span class="string">'!/ldb/ &#123;print&#125;'</span> f<span class="selector-class">.txt</span>  #不匹配ldb</span><br><span class="line">awk <span class="string">'/ldb/ &amp;&amp; /LISTEN/ &#123;print&#125;'</span> f<span class="selector-class">.txt</span>   #匹配ldb和LISTEN</span><br><span class="line">awk <span class="string">'$5 ~ /ldb/ &#123;print&#125;'</span> f<span class="selector-class">.txt</span> #第五列匹配ldb</span><br></pre></td></tr></table></figure><p>3 内建变量</p><p>NR:NR表示从awk开始执行后，按照记录分隔符读取的数据次数，默认的记录分隔符为换行符，因此默认的就是读取的数据行数，NR可以理解为Number of Record的缩写。</p><p>FNR:在awk处理多个输入文件的时候，在处理完第一个文件后，NR并不会从1开始，而是继续累加，因此就出现了FNR，每当处理一个新文件的时候，FNR就从1开始计数，FNR可以理解为File Number of Record。</p><p>NF: NF表示目前的记录被分割的字段的数目，NF可以理解为Number of Field。</p><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sudo -u <span class="built_in">admin</span> <span class="built_in">find</span> /home/<span class="built_in">admin</span> /tmp /usr -<span class="built_in">name</span> \*.<span class="built_in">log</span>(多个目录去找)</span><br><span class="line"><span class="built_in">find</span> . -iname \*.txt(大小写都匹配)</span><br><span class="line"><span class="built_in">find</span> . -<span class="built_in">type</span> d(当前目录下的所有子目录)</span><br><span class="line"><span class="built_in">find</span> /usr -<span class="built_in">type</span> l(当前目录下所有的符号链接)</span><br><span class="line"><span class="built_in">find</span> /usr -<span class="built_in">type</span> l -<span class="built_in">name</span> <span class="string">"z*"</span> -ls(符号链接的详细信息 eg:inode,目录)</span><br><span class="line"><span class="built_in">find</span> /home/<span class="built_in">admin</span> -<span class="built_in">size</span> +<span class="number">250000</span>k(超过<span class="number">250000</span>k的文件，当然+改成-就是小于了)</span><br><span class="line"><span class="built_in">find</span> /home/<span class="built_in">admin</span> f -perm <span class="number">777</span> -<span class="built_in">exec</span> ls -l &#123;&#125; \; (按照权限查询文件)</span><br><span class="line"><span class="built_in">find</span> /home/<span class="built_in">admin</span> -atime -<span class="number">1</span>  <span class="number">1</span>天内访问过的文件</span><br><span class="line"><span class="built_in">find</span> /home/<span class="built_in">admin</span> -ctime -<span class="number">1</span>  <span class="number">1</span>天内状态改变过的文件</span><br><span class="line"><span class="built_in">find</span> /home/<span class="built_in">admin</span> -mtime -<span class="number">1</span>  <span class="number">1</span>天内修改过的文件</span><br><span class="line"><span class="built_in">find</span> /home/<span class="built_in">admin</span> -amin -<span class="number">1</span>  <span class="number">1</span>分钟内访问过的文件</span><br><span class="line"><span class="built_in">find</span> /home/<span class="built_in">admin</span> -cmin -<span class="number">1</span>  <span class="number">1</span>分钟内状态改变过的文件</span><br><span class="line"><span class="built_in">find</span> /home/<span class="built_in">admin</span> -mmin -<span class="number">1</span>  <span class="number">1</span>分钟内修改过的文件</span><br></pre></td></tr></table></figure><h2 id="pgm"><a href="#pgm" class="headerlink" title="pgm"></a>pgm</h2><p>批量查询vm-shopbase满足条件的日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pgm -A -f vm-shopbase <span class="string">'cat /home/admin/shopbase/logs/shopbase.log.2017-01-17|grep 2069861630'</span></span><br></pre></td></tr></table></figure><h2 id="tsar"><a href="#tsar" class="headerlink" title="tsar"></a>tsar</h2><p>Tsar (Taobao System Activity Reporter) is a monitoring tool, which can be used to gather and summarize system information, e.g. CPU, load, IO, and application information, e.g. nginx, HAProxy, Squid, etc. The results can be stored at local disk or sent to Nagios.</p><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | <span class="type">grep</span> java</span><br><span class="line"><span class="built_in">top</span> -H -p pid</span><br></pre></td></tr></table></figure><p>获得线程10进制转16进制后jstack去抓看这个线程到底在干啥</p><h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看当前连接，注意close_wait偏高的情况</span></span><br><span class="line">netstat -nat|awk  <span class="string">'&#123;print $6&#125;'</span>|sort|uniq -c|sort -rn</span><br></pre></td></tr></table></figure><h1 id="排查利器"><a href="#排查利器" class="headerlink" title="排查利器"></a>排查利器</h1><h2 id="btrace"><a href="#btrace" class="headerlink" title="btrace"></a>btrace</h2><p>A safe, dynamic tracing tool for the Java platform    </p><h2 id="Greys"><a href="#Greys" class="headerlink" title="Greys"></a>Greys</h2><p><a href="https://github.com/oldmanpushcart/greys-anatomy/wiki/greys-pdf" target="_blank" rel="noopener">https://github.com/oldmanpushcart/greys-anatomy/wiki/greys-pdf</a></p><h2 id="javOSize"><a href="#javOSize" class="headerlink" title="javOSize"></a>javOSize</h2><p><a href="http://www.javosize.com/" target="_blank" rel="noopener">http://www.javosize.com/</a></p><h2 id="JProfiler"><a href="#JProfiler" class="headerlink" title="JProfiler"></a>JProfiler</h2><p><a href="https://www.ej-technologies.com/products/jprofiler/overview.html" target="_blank" rel="noopener">https://www.ej-technologies.com/products/jprofiler/overview.html</a></p><h1 id="java三板斧"><a href="#java三板斧" class="headerlink" title="java三板斧"></a>java三板斧</h1><h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps -mlvV</span><br></pre></td></tr></table></figure><h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><h3 id="普通用法"><a href="#普通用法" class="headerlink" title="普通用法"></a>普通用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 2815</span><br></pre></td></tr></table></figure><h3 id="native-java栈"><a href="#native-java栈" class="headerlink" title="native+java栈"></a>native+java栈</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack -m 2815</span><br></pre></td></tr></table></figure><h2 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo -flags 2815</span><br></pre></td></tr></table></figure><h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><h3 id="查看堆的情况"><a href="#查看堆的情况" class="headerlink" title="查看堆的情况"></a>查看堆的情况</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap 2815</span><br></pre></td></tr></table></figure><h3 id="dump"><a href="#dump" class="headerlink" title="dump"></a>dump</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:live,format=b,file=/tmp/heap2.bin 2815</span><br></pre></td></tr></table></figure><h3 id="看看堆都被谁占了"><a href="#看看堆都被谁占了" class="headerlink" title="看看堆都被谁占了"></a>看看堆都被谁占了</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -histo 2815 | head -10</span><br></pre></td></tr></table></figure><h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gcutil 2815 1000</span><br></pre></td></tr></table></figure><h1 id="jar包冲突"><a href="#jar包冲突" class="headerlink" title="jar包冲突"></a>jar包冲突</h1><h2 id="打出所有依赖"><a href="#打出所有依赖" class="headerlink" title="打出所有依赖"></a>打出所有依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn dependency:tree &gt; ~/dependency.txt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05基础篇：某个应用的CPU使用率居然达到100%我该怎么办</title>
      <link href="/2019/04/12/aa_category/linux/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/05%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9A%E6%9F%90%E4%B8%AA%E5%BA%94%E7%94%A8%E7%9A%84CPU%E4%BD%BF%E7%94%A8%E7%8E%87%E5%B1%85%E7%84%B6%E8%BE%BE%E5%88%B0100%25%EF%BC%8C%E6%88%91%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E/"/>
      <url>/2019/04/12/aa_category/linux/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/05%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9A%E6%9F%90%E4%B8%AA%E5%BA%94%E7%94%A8%E7%9A%84CPU%E4%BD%BF%E7%94%A8%E7%8E%87%E5%B1%85%E7%84%B6%E8%BE%BE%E5%88%B0100%25%EF%BC%8C%E6%88%91%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="CPU-使用率"><a href="#CPU-使用率" class="headerlink" title="CPU 使用率"></a>CPU 使用率</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">'CONFIG_HZ='</span> /boot/config-$(uname -r)</span><br><span class="line">CONFIG_HZ=250</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只保留各个 CPU 的数据</span></span><br><span class="line">$ cat /proc/<span class="built_in">stat</span> | grep ^cpu</span><br><span class="line">cpu  280580 7407 286084 172900810 83602 0 583 0 0 0</span><br><span class="line">cpu0 144745 4181 176701 86423902 52076 0 301 0 0 0</span><br><span class="line">cpu1 135834 3226 109383 86476907 31525 0 282 0 0 0</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li><p>user（通常缩写为 us），代表用户态 CPU 时间。注意，它不包括下面的 nice 时间，但包括了 guest 时间。</p></li><li><p>nice（通常缩写为 ni），代表低优先级用户态 CPU 时间，也就是进程的 nice 值被调整为 1-19 之间时的 CPU 时间。这里注意，nice 可取值范围是 -20 到 19，数值越大，优先级反而越低。</p></li><li><p>system（通常缩写为 sys），代表内核态 CPU 时间。</p></li><li><p>idle（通常缩写为 id），代表空闲时间。注意，它不包括等待 I/O 的时间（iowait）。</p></li><li><p>iowait（通常缩写为 wa），代表等待 I/O 的 CPU 时间。</p></li><li><p>irq（通常缩写为 hi），代表处理硬中断的 CPU 时间。</p></li><li><p>soft（通常缩写为 si），代表处理软中断的 CPU 时间。</p></li><li><p>steal（通常缩写为 st），代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间。</p></li><li><p>guest（通常缩写为 guest），代表通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的 CPU 时间。</p></li><li><p>guest_nice（通常缩写为 gnice），代表以低优先级运行虚拟机的时间。</p></li></ul><p>CPU 使用率，就是除了空闲时间外的其他时间占总 CPU 时间的百分比</p><p><img src="https://static001.geekbang.org/resource/image/3e/09/3edcc7f908c7c1ddba4bbcccc0277c09.png" alt="img"></p><h1 id="怎么查看-CPU-使用率"><a href="#怎么查看-CPU-使用率" class="headerlink" title="怎么查看 CPU 使用率"></a>怎么查看 CPU 使用率</h1><p>top 显示了系统总体的 CPU 和内存使用情况，以及各个进程的资源使用情况。</p><p>ps 则只显示了每个进程的资源使用情况。</p><h1 id="CPU-使用率过高怎么办？"><a href="#CPU-使用率过高怎么办？" class="headerlink" title="CPU 使用率过高怎么办？"></a>CPU 使用率过高怎么办？</h1><ul><li>GDB（The GNU Project Debugger） </li><li>perf top</li></ul><h2 id="perf"><a href="#perf" class="headerlink" title="perf"></a>perf</h2><p><a href="https://perf.wiki.kernel.org/index.php/Main_Page" target="_blank" rel="noopener">https://perf.wiki.kernel.org/index.php/Main_Page</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开篇词_别再让Linux性能问题成为你的绊脚石</title>
      <link href="/2019/04/12/aa_category/linux/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/%E5%BC%80%E7%AF%87%E8%AF%8D_%E5%88%AB%E5%86%8D%E8%AE%A9Linux%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E6%88%90%E4%B8%BA%E4%BD%A0%E7%9A%84%E7%BB%8A%E8%84%9A%E7%9F%B3/"/>
      <url>/2019/04/12/aa_category/linux/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/%E5%BC%80%E7%AF%87%E8%AF%8D_%E5%88%AB%E5%86%8D%E8%AE%A9Linux%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E6%88%90%E4%B8%BA%E4%BD%A0%E7%9A%84%E7%BB%8A%E8%84%9A%E7%9F%B3/</url>
      
        <content type="html"><![CDATA[<p>最好的学习方式一定是带着问题学习</p><p>具体来看，我会分为 5 个模块。前 4 个模块我会从资源使用的视角出发，带你分析各种 Linux 资源可能会碰到的性能问题，包括 CPU 性能、磁盘 I/O 性能、内存性能、网络性能</p><a id="more"></a><ul><li><p>基础篇，介绍 Linux 必备的基本原理以及对应的性能指标和性能工具。比如怎么理解平均负载，怎么理解上下文切换，Linux 内存的工作原理等等。</p></li><li><p>案例篇，这里我会通过模拟案例，帮你分析高手在遇到资源瓶颈时，是如何观测、定位、分析并优化这些性能问题的。</p></li><li><p>套路篇，在理解了基础，亲身体验了模拟案例之后，我会帮你梳理出排查问题的整体思路，也就是检查性能问题的一般步骤，这样，以后你遇到问题，就可以按照这样的路子来。</p></li><li><p>答疑篇，我相信在学习完每一个模块之后，你都会有很多的问题，在答疑篇里，我会拿出提问频次较高的问题给你系统解答。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23基础篇：Linux 文件系统是怎么工作的</title>
      <link href="/2019/04/12/aa_category/linux/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/23%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9ALinux%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/"/>
      <url>/2019/04/12/aa_category/linux/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/23%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9ALinux%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="索引节点和目录项"><a href="#索引节点和目录项" class="headerlink" title="索引节点和目录项"></a>索引节点和目录项</h1><p>在 Linux 中一切皆文件。不仅普通的文件和目录，就连块设备、套接字、管道等，也都要通过统一的文件系统来管理。</p><a id="more"></a><p>为了方便管理，Linux 文件系统为每个文件都分配两个数据结构，索引节点（index node）和目录项（directory entry）。它们主要用来记录文件的元信息和目录结构。</p><ul><li>索引节点，简称为 inode，用来记录文件的元数据，比如 inode 编号、文件大小、访问权限、修改日期、数据的位置等。索引节点和文件一一对应，它跟文件内容一样，都会被持久化存储到磁盘中。所以记住，索引节点同样占用磁盘空间。</li><li>目录项，简称为 dentry，用来记录文件的名字、索引节点指针以及与其他目录项的关联关系。多个关联的目录项，就构成了文件系统的目录结构。不过，不同于索引节点，目录项是由内核维护的一个内存数据结构，所以通常也被叫做目录项缓存。</li></ul><p>索引节点是每个文件的唯一标志，而目录项维护的正是文件系统的树状结构。目录项和索引节点的关系是多对一，你可以简单理解为，一个文件可以有多个别名。</p><p>举个例子，通过硬链接为文件创建的别名，就会对应不同的目录项，不过这些目录项本质上还是链接同一个文件，所以，它们的索引节点相同。    </p><p><img src="http://liyong.ac.cn/pic/1554533311894.png" alt="1554533311894"></p><ul><li>第一，目录项本身就是一个内存缓存，而索引节点则是存储在磁盘中的数据。在前面的 Buffer 和 Cache 原理中，我曾经提到过，为了协调慢速磁盘与快速 CPU 的性能差异，文件内容会缓存到页缓存 Cache 中。</li><li>第二，磁盘在执行文件系统格式化时，会被分成三个存储区域，超级块、索引节点区和数据块区。其中，<ul><li>超级块，存储整个文件系统的状态。</li><li>索引节点区，用来存储索引节点。</li><li>数据块区，则用来存储文件数据。</li></ul></li></ul><h1 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h1><p><img src="http://liyong.ac.cn/pic/728b7b39252a1e23a7a223cdf4aa1612.png" alt></p><ul><li>第一类是基于磁盘的文件系统，也就是把数据直接存储在计算机本地挂载的磁盘中。常见的 Ext4、XFS、OverlayFS 等，都是这类文件系统。</li><li>第二类是基于内存的文件系统，也就是我们常说的虚拟文件系统。这类文件系统，不需要任何磁盘分配存储空间，但会占用内存。我们经常用到的 /proc 文件系统，其实就是一种最常见的虚拟文件系统。此外，/sys 文件系统也属于这一类，主要向用户空间导出层次化的内核对象。</li><li>第三类是网络文件系统，也就是用来访问其他计算机数据的文件系统，比如 NFS、SMB、iSCSI 等。</li></ul><p>这些文件系统，要先挂载到 VFS 目录树中的某个子目录（称为挂载点），然后才能访问其中的文件。拿第一类，也就是基于磁盘的文件系统为例，在安装系统时，要先挂载一个根目录（/），在根目录下再把其他文件系统（比如其他的磁盘分区、/proc 文件系统、/sys 文件系统、NFS 等）挂载进来。</p><h1 id="文件系统-I-O"><a href="#文件系统-I-O" class="headerlink" title="文件系统 I/O"></a>文件系统 I/O</h1><ul><li>第一种，根据是否利用标准库缓存，可以把文件 I/O 分为缓冲 I/O 与非缓冲 I/O。<ul><li>缓冲 I/O，是指利用标准库缓存来加速文件的访问，而标准库内部再通过系统调度访问文件。</li><li>非缓冲 I/O，是指直接通过系统调用来访问文件，不再经过标准库缓存。</li></ul></li><li>第二，根据是否利用操作系统的页缓存，可以把文件 I/O 分为直接 I/O 与非直接 I/O。<ul><li>直接 I/O，是指跳过操作系统的页缓存，直接跟文件系统交互来访问文件。</li><li>非直接 I/O 正好相反，文件读写时，先要经过系统的页缓存，然后再由内核或额外的系统调用，真正写入磁盘。</li></ul></li><li>第三，根据应用程序是否阻塞自身运行，可以把文件 I/O 分为阻塞 I/O 和非阻塞 I/O：<ul><li>所谓阻塞 I/O，是指应用程序执行 I/O 操作后，如果没有获得响应，就会阻塞当前线程，自然就不能执行其他任务。</li><li>所谓非阻塞 I/O，是指应用程序执行 I/O 操作后，不会阻塞当前的线程，可以继续执行其他的任务，随后再通过轮询或者事件通知的形式，获取调用的结果。</li></ul></li><li>第四，根据是否等待响应结果，可以把文件 I/O 分为同步和异步 I/O：<ul><li>所谓同步 I/O，是指应用程序执行 I/O 操作后，要一直等到整个 I/O 完成后，才能获得 I/O 响应。</li><li>所谓异步 I/O，是指应用程序执行 I/O 操作后，不用等待完成和完成后的响应，而是继续执行就可以。等到这次 I/O 完成后，响应会用事件通知的方式，告诉应用程序。</li></ul></li></ul><h1 id="性能观测"><a href="#性能观测" class="headerlink" title="性能观测"></a>性能观测</h1><h2 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> df /dev/sda1 </span><br><span class="line">Filesystem     1K-blocks    Used Available Use% Mounted on </span><br><span class="line">/dev/sda1       30308240 3167020  27124836  11% /</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df -i /dev/sda1 </span><br><span class="line">Filesystem      Inodes  IUsed   IFree IUse% Mounted on </span><br><span class="line">/dev/sda1      3870720 157460 3713260    5% /</span><br></pre></td></tr></table></figure><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/meminfo | grep -E <span class="string">"SReclaimable|Cached"</span> </span><br><span class="line">Cached:           748316 kB </span><br><span class="line">SwapCached:            0 kB </span><br><span class="line">SReclaimable:     179508 kB</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/slabinfo | grep -E <span class="string">'^#|dentry|inode'</span> </span><br><span class="line"><span class="comment"># name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;limit&gt; &lt;batchcount&gt; &lt;sharedfactor&gt; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt; </span></span><br><span class="line"></span><br><span class="line">xfs_inode              0      0    960   17    4 : tunables    0    0    0 : slabdata      0      0      0 </span><br><span class="line">... </span><br><span class="line">ext4_inode_cache   32104  34590   1088   15    4 : tunables    0    0    0 : slabdata   2306   2306      0hugetlbfs_inode_cache     13     13    624   13    2 : tunables    0    0    0 : slabdata      1      1      0 </span><br><span class="line">sock_inode_cache    1190   1242    704   23    4 : tunables    0    0    0 : slabdata     54     54      0 </span><br><span class="line">shmem_inode_cache   1622   2139    712   23    4 : tunables    0    0    0 : slabdata     93     93      0 </span><br><span class="line">proc_inode_cache    3560   4080    680   12    2 : tunables    0    0    0 : slabdata    340    340      0 </span><br><span class="line">inode_cache        25172  25818    608   13    2 : tunables    0    0    0 : slabdata   1986   1986      0 </span><br><span class="line">dentry             76050 121296    192   21    1 : tunables    0    0    0 : slabdata   5776   5776      0</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按下 c 按照缓存大小排序，按下 a 按照活跃对象数排序 </span></span><br><span class="line">$ slabtop </span><br><span class="line">Active / Total Objects (% used)    : 277970 / 358914 (77.4%) </span><br><span class="line">Active / Total Slabs (% used)      : 12414 / 12414 (100.0%) </span><br><span class="line">Active / Total Caches (% used)     : 83 / 135 (61.5%) </span><br><span class="line">Active / Total Size (% used)       : 57816.88K / 73307.70K (78.9%) </span><br><span class="line">Minimum / Average / Maximum Object : 0.01K / 0.20K / 22.88K </span><br><span class="line"></span><br><span class="line">  OBJS ACTIVE  USE OBJ SIZE  SLABS OBJ/SLAB CACHE SIZE NAME </span><br><span class="line">69804  23094   0%    0.19K   3324       21     13296K dentry </span><br><span class="line">16380  15854   0%    0.59K   1260       13     10080K inode_cache </span><br><span class="line">58260  55397   0%    0.13K   1942       30      7768K kernfs_node_cache </span><br><span class="line">   485    413   0%    5.69K     97        5      3104K task_struct </span><br><span class="line">  1472   1397   0%    2.00K     92       16      2944K kmalloc-2048</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>16基础篇：怎么理解内存中的Buffer和Cache</title>
      <link href="/2019/04/12/aa_category/linux/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/16%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9A%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84Buffer%E5%92%8CCache/"/>
      <url>/2019/04/12/aa_category/linux/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/16%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9A%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84Buffer%E5%92%8CCache/</url>
      
        <content type="html"><![CDATA[<ul><li>Buffers 是内核缓冲区用到的内存，对应的是  /proc/meminfo 中的 Buffers 值。</li><li>Cache 是内核页缓存和 Slab 用到的内存，对应的是  /proc/meminfo 中的 Cached 与 SReclaimable 之和。</li></ul><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Buffers %lu</span><br><span class="line">    Relatively temporary storage <span class="keyword">for</span> raw disk blocks that shouldn<span class="string">'t get tremendously large (20MB or so).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Cached %lu</span></span><br><span class="line"><span class="string">   In-memory cache for files read from the disk (the page cache).  Doesn'</span>t include SwapCached.</span><br><span class="line">...</span><br><span class="line">SReclaimable %lu (since Linux 2.6.19)</span><br><span class="line">    Part of Slab, that might be reclaimed, such as caches.</span><br><span class="line">    </span><br><span class="line">SUnreclaim %lu (since Linux 2.6.19)</span><br><span class="line">    Part of Slab, that cannot be reclaimed on memory pressure.</span><br></pre></td></tr></table></figure><ul><li><p>Buffers 是对原始磁盘块的临时存储，也就是用来<strong>缓存磁盘的数据</strong>，通常不会特别大（20MB 左右）。这样，内核就可以把分散的写集中起来，统一优化磁盘的写入，比如可以把多次小的写合并成单次大的写等等。</p></li><li><p>Cached 是从磁盘读取文件的页缓存，也就是用来<strong>缓存从文件读取的数据</strong>。这样，下次访问这些文件数据时，就可以直接从内存中快速获取，而不需要再次访问缓慢的磁盘。</p></li><li><p>SReclaimable 是 Slab 的一部分。Slab 包括两部分，其中的可回收部分，用 SReclaimable 记录；而不可回收部分，用 SUnreclaim 记录。</p></li></ul><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清理文件页、目录项、Inodes 等各种缓存</span></span><br><span class="line"><span class="built_in">echo</span> 3 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先清理缓存</span></span><br><span class="line"><span class="built_in">echo</span> 3 &gt; /proc/sys/vm/drop_caches</span><br><span class="line"><span class="comment"># 然后运行 dd 命令向磁盘分区 /dev/sdb1 写入 2G 数据</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/urandom of=/dev/sdb1 bs=1M count=2048</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Buffer 既可以用作“将要写入磁盘数据的缓存”，也可以用作“从磁盘读取数据的缓存”。</li><li>Cache 既可以用作“从文件读取数据的页缓存”，也可以用作“写文件的页缓存”。</li><li>Buffer 是对磁盘数据的缓存，而 Cache 是文件数据的缓存，它们既会用在读请求中，也会用在写请求中</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15 基础篇：Linux内存是怎么工作的</title>
      <link href="/2019/04/12/aa_category/linux/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/15%20%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9ALinux%E5%86%85%E5%AD%98%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/"/>
      <url>/2019/04/12/aa_category/linux/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/15%20%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9ALinux%E5%86%85%E5%AD%98%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h1><p>Linux 内核给每个进程都提供了一个独立的虚拟地址空间，并且这个地址空间是连续的。这样，进程就可以很方便地访问内存，更确切地说是访问虚拟内存。</p><a id="more"></a><p>虚拟地址空间的内部又被分为<strong>内核空间和用户空间</strong>两部分，不同字长（也就是单个 CPU 指令可以处理数据的最大长度）的处理器，地址空间的范围也不同。比如最常见的 32 位和 64 位系统，如下所示：</p><p><img src="http://liyong.ac.cn/pic/ed8824c7a2e4020e2fdd2a104c70ab7b.png" alt="ed8824c7a2e4020e2fdd2a104c70ab7b"></p><p>​    进程在用户态时，只能访问用户空间内存；只有进入内核态后，才可以访问内核空间内存。虽然每个进程的地址空间都包含了内核空间，但这些内核空间，其实关联的都是相同的物理内存。这样，进程切换到内核态后，就可以很方便地访问内核空间内存。</p><p>既然每个进程都有一个这么大的地址空间，那么所有进程的虚拟内存加起来，自然要比实际的物理内存大得多。所以，并不是所有的虚拟内存都会分配物理内存，只有那些实际使用的虚拟内存才分配物理内存，并且分配后的物理内存，是通过<strong>内存映射</strong>来管理的。</p><p>内存映射，其实就是将<strong>虚拟内存地址</strong>映射到<strong>物理内存地址</strong>。为了完成内存映射，内核为每个进程都维护了一张页表，记录虚拟地址与物理地址的映射关系，如下图所示：</p><p><img src="http://liyong.ac.cn/pic/fcfbe2f8eb7c6090d82bf93ecdc1f0b6.png" alt></p><h1 id="虚拟内存空间分布"><a href="#虚拟内存空间分布" class="headerlink" title="虚拟内存空间分布"></a>虚拟内存空间分布</h1><p><img src="http://liyong.ac.cn/pic/71a754523386cc75f4456a5eabc93c5d.png" alt></p><ul><li>只读段，包括代码和常量等。</li><li>数据段，包括全局变量等。</li><li>堆，包括动态分配的内存，从低地址开始向上增长。</li><li>文件映射段，包括动态库、共享内存等，从高地址开始向下增长。</li><li>栈，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。</li></ul><h1 id="内存分配与回收"><a href="#内存分配与回收" class="headerlink" title="内存分配与回收"></a>内存分配与回收</h1><ul><li>回收缓存，比如使用 LRU（Least Recently Used）算法，回收最近使用最少的内存页面；</li><li>回收不常访问的内存，把不常用的内存通过交换分区直接写到磁盘中；</li><li>杀死进程，内存紧张时系统还会通过 OOM（Out of Memory），直接杀掉占用大量内存的进程。</li></ul><p>回收不常访问的内存会用到交换分区（以下简称 Swap）。Swap 其实就是把一块磁盘空间当成内存来用。它可以把进程暂时不用的数据存储到磁盘中（这个过程称为换出），当进程访问这些内存时，再从磁盘读取这些数据到内存中（这个过程称为换入）。</p><h1 id="如何查看内存使用情况"><a href="#如何查看内存使用情况" class="headerlink" title="如何查看内存使用情况"></a>如何查看内存使用情况</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ free</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:        8169348      263524     6875352         668     1030472     7611064</span><br><span class="line">Swap:             0           0           0</span><br></pre></td></tr></table></figure><p>available 不仅包含未使用内存，还包括了可回收的缓存，所以一般会比未使用内存更大。不过，并不是所有缓存都可以回收，因为有些缓存可能正在使用中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按下 M 切换到内存排序</span></span><br><span class="line">$ top</span><br><span class="line">...</span><br><span class="line">KiB Mem :  8169348 total,  6871440 free,   267096 used,  1030812 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.  7607492 avail Mem</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">  430 root      19  -1  122360  35588  23748 S   0.0  0.4   0:32.17 systemd-journal</span><br><span class="line"> 1075 root      20   0  771860  22744  11368 S   0.0  0.3   0:38.89 snapd</span><br></pre></td></tr></table></figure><ul><li>VIRT 是进程虚拟内存的大小，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内。</li><li>RES 是常驻内存的大小，也就是进程实际使用的物理内存大小，但不包括 Swap 和共享内存。</li><li>SHR 是共享内存的大小，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>24-25基础篇：Linux 磁盘IO是怎么工作的</title>
      <link href="/2019/04/12/aa_category/linux/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/24-25%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9ALinux%20%E7%A3%81%E7%9B%98IO%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/"/>
      <url>/2019/04/12/aa_category/linux/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/24-25%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9ALinux%20%E7%A3%81%E7%9B%98IO%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h1><ul><li>第一类，机械磁盘，也称为硬盘驱动器（Hard Disk Driver），通常缩写为 HDD。机械磁盘主要由盘片和读写磁头组成，数据就存储在盘片的环状磁道中。在读写数据前，需要移动读写磁头，定位到数据所在的磁道，然后才能访问数据。</li><li>第二类，固态磁盘（Solid State Disk），通常缩写为 SSD，由固态电子元器件组成。固态磁盘不需要磁道寻址，所以，不管是连续 I/O，还是随机 I/O 的性能，都比机械磁盘要好得多。</li></ul><a id="more"></a><h1 id="通用块层"><a href="#通用块层" class="headerlink" title="通用块层"></a>通用块层</h1><ul><li>第一个功能跟虚拟文件系统的功能类似。向上，为文件系统和应用程序，提供访问块设备的标准接口；向下，把各种异构的磁盘设备抽象为统一的块设备，并提供统一框架来管理这些设备的驱动程序。</li><li>第二个功能，通用块层还会给文件系统和应用程序发来的 I/O 请求排队，并通过重新排序、请求合并等方式，提高磁盘读写的效率。</li></ul><h1 id="I-O-栈"><a href="#I-O-栈" class="headerlink" title="I/O 栈"></a>I/O 栈</h1><p><img src="http://liyong.ac.cn/pic/Linux-storage-stack-diagram_v4.10.png" alt></p><ul><li>文件系统层，包括虚拟文件系统和其他各种文件系统的具体实现。它为上层的应用程序，提供标准的文件访问接口；对下会通过通用块层，来存储和管理磁盘数据。</li><li>通用块层，包括块设备 I/O 队列和 I/O 调度器。它会对文件系统的 I/O 请求进行排队，再通过重新排序和请求合并，然后才要发送给下一级的设备层。</li><li>设备层，包括存储设备和相应的驱动程序，负责最终物理设备的 I/O 操作。</li></ul><h1 id="磁盘性能指标"><a href="#磁盘性能指标" class="headerlink" title="磁盘性能指标"></a>磁盘性能指标</h1><ul><li>使用率，是指磁盘处理 I/O 的时间百分比。过高的使用率（比如超过 80%），通常意味着磁盘 I/O 存在性能瓶颈。</li><li>饱和度，是指磁盘处理 I/O 的繁忙程度。过高的饱和度，意味着磁盘存在严重的性能瓶颈。当饱和度为 100% 时，磁盘无法接受新的 I/O 请求。</li><li>IOPS（Input/Output Per Second），是指每秒的 I/O 请求数。</li><li>吞吐量，是指每秒的 I/O 请求大小。</li><li>响应时间，是指 I/O 请求从发出到收到响应的间隔时间。</li></ul><p>使用率只考虑有没有 I/O，而不考虑 I/O 的大小。换句话说，当使用率是 100% 的时候，磁盘依然有可能接受新的 I/O 请求。</p><h1 id="磁盘-I-O-观测"><a href="#磁盘-I-O-观测" class="headerlink" title="磁盘 I/O 观测"></a>磁盘 I/O 观测</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -d -x 表示显示所有磁盘 I/O 的指标</span></span><br><span class="line">$ iostat -d -x 1</span><br></pre></td></tr></table></figure><p><img src="http://liyong.ac.cn/pic/cff31e715af51c9cb8085ce1bb48318d.png" alt="img"></p><ul><li>%util  ，就是我们前面提到的磁盘 I/O 使用率；</li><li>r/s+  w/s  ，就是 IOPS；</li><li>rkB/s+wkB/s ，就是吞吐量；</li><li>r_await+w_await ，就是响应时间。</li></ul><h1 id="进程I-O观测"><a href="#进程I-O观测" class="headerlink" title="进程I/O观测"></a>进程I/O观测</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidstat -d 1</span><br></pre></td></tr></table></figure><ul><li>每秒读取的数据大小（kB_rd/s） ，单位是 KB。</li><li>每秒发出的写请求数据大小（kB_wr/s） ，单位是 KB。</li><li>每秒取消的写请求数据大小（kB_ccwr/s） ，单位是 KB。</li><li>块 I/O 延迟（iodelay），包括等待同步块 I/O 和换入块 I/O 结束的时间，单位是时钟周期。</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03-04基础篇：经常说的 CPU 上下文切换是什么意思</title>
      <link href="/2019/04/12/aa_category/linux/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/03-04%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9A%E7%BB%8F%E5%B8%B8%E8%AF%B4%E7%9A%84%20CPU%20%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/"/>
      <url>/2019/04/12/aa_category/linux/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/03-04%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9A%E7%BB%8F%E5%B8%B8%E8%AF%B4%E7%9A%84%20CPU%20%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/</url>
      
        <content type="html"><![CDATA[<p>CPU 寄存器，是 CPU 内置的容量小、但速度极快的内存。而程序计数器，则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。它们都是 CPU 在运行任何任务前，必须的依赖环境，因此也被叫做 cpu上下文</p><p><img src="http://liyong.ac.cn/pic/98ac9df2593a193d6a7f1767cd68eb5f.png" alt="1"></p><a id="more"></a><p>知道了什么是 CPU 上下文，我想你也很容易理解 <strong>CPU 上下文切换</strong>。CPU 上下文切换，就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。</p><p>而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。</p><p>根据任务的不同，CPU 的上下文切换就可以分为几个不同的场景，也就是<strong>进程上下文切换</strong>、<strong>线程上下文切换</strong>以及<strong>中断上下文切换</strong>。</p><h1 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h1><p>因此，进程的上下文切换就比系统调用时多了一步：在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的虚拟内存、栈等保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。</p><ul><li><p>其一，为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行。</p></li><li><p>其二，进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。</p></li><li><p>其三，当进程通过睡眠函数  sleep 这样的方法将自己主动挂起时，自然也会重新调度。</p></li><li><p>其四，当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行</p></li></ul><p>最后一个，发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。</p><h1 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h1><p>线程与进程最大的区别在于，<strong>线程是调度的基本单位，而进程则是资源拥有的基本单位</strong>。说白了，所谓内核中的任务调度，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全局变量等资源。所以，对于线程和进程，我们可以这么理解：</p><ul><li>当进程只有一个线程时，可以认为进程就等于线程。</li><li>当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。</li></ul><p>另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。</p><ul><li><p>第一种， 前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。</p></li><li><p>第二种，前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。</p></li></ul><h1 id="中断上下文切换"><a href="#中断上下文切换" class="headerlink" title="中断上下文切换"></a>中断上下文切换</h1><ul><li><p>为了快速响应硬件的事件，<strong>中断处理会打断进程的正常调度和执行</strong>，转而调用中断处理程序，响应设备事件。而在打断其他进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行。</p></li><li><p>跟进程上下文不同，中断上下文切换并不涉及到进程的用户态。所以，即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等。</p></li><li><p>对同一个 CPU 来说，中断处理比进程拥有更高的优先级</p></li></ul><h1 id="怎么查看系统的上下文切换情况"><a href="#怎么查看系统的上下文切换情况" class="headerlink" title="怎么查看系统的上下文切换情况"></a>怎么查看系统的上下文切换情况</h1><h2 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔 5 秒输出 1 组数据</span></span><br><span class="line">$ vmstat 5</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   <span class="keyword">in</span>   cs us sy id wa st</span><br><span class="line"> 0  0      0 7005360  91564 818900    0    0     0     0   25   33  0  0 100  0  0</span><br></pre></td></tr></table></figure><ul><li>cs（context switch）是每秒上下文切换的次数,The number of context switches per second。</li><li>in（interrupt）则是每秒中断的次数,The number of interrupts per second, including the clock。</li><li>r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程数。</li><li>b（Blocked）则是处于不可中断睡眠状态的进程数。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔 5 秒输出 1 组数据</span></span><br><span class="line">$ pidstat -w 5</span><br><span class="line">Linux 4.15.0 (ubuntu)  09/23/18  _x86_64_  (2 CPU)</span><br><span class="line"></span><br><span class="line">08:18:26      UID       PID   cswch/s nvcswch/s  Command</span><br><span class="line">08:18:31        0         1      0.20      0.00  systemd</span><br><span class="line">08:18:31        0         8      5.40      0.00  rcu_sched</span><br></pre></td></tr></table></figure><p> 这个结果中有两列内容是我们的重点关注对象。一个是  cswch  ，表示每秒自愿上下文切换（voluntary context switches）的次数，另一个则是  nvcswch  ，表示每秒非自愿上下文切换（non voluntary context switches）的次数。</p><ul><li>所谓<strong>自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换</strong>。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。</li><li>而<strong>非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换</strong>。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换。</li></ul><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="sysbench"><a href="#sysbench" class="headerlink" title="sysbench"></a>sysbench</h2><p><a href="https://github.com/akopytov/sysbench" target="_blank" rel="noopener">https://github.com/akopytov/sysbench</a></p><h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以 10 个线程运行 5 分钟的基准测试，模拟多线程切换的问题</span></span><br><span class="line">sysbench --threads=10 --max-time=300 threads run</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔 1 秒输出 1 组数据（需要 Ctrl+C 才结束）</span></span><br><span class="line">$ vmstat 3</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔 1 秒输出 1 组数据（需要 Ctrl+C 才结束）</span></span><br><span class="line"><span class="comment"># -w 参数表示输出进程切换指标，而 -u 参数则表示输出 CPU 使用指标</span></span><br><span class="line">$ pidstat -w -u 3</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔 1 秒输出一组数据（需要 Ctrl+C 才结束）</span></span><br><span class="line"><span class="comment"># -wt 参数表示输出线程的上下文切换指标</span></span><br><span class="line">$ pidstat -wt 1</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -d 参数表示高亮显示变化的区域</span></span><br><span class="line">$ watch -d cat /proc/interrupts</span><br><span class="line">           CPU0       CPU1</span><br><span class="line">...</span><br><span class="line">RES:    2450431    5279697   Rescheduling interrupts</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>观察一段时间，你可以发现，变化速度最快的是<strong>重调度中断</strong>（RES），这个中断类型表示，唤醒空闲状态的 CPU 来调度新的任务运行。这是多处理器系统（SMP）中，调度器用来分散任务到不同 CPU 的机制，通常也被称为<strong>处理器间中断</strong>（Inter-Processor Interrupts，IPI）</p><ul><li>自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I/O 等其他问题；</li><li>非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈；</li><li>中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts 文件来分析具体的中断类型。</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01如何学习Linux性能优化</title>
      <link href="/2019/04/12/aa_category/linux/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/01%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2019/04/12/aa_category/linux/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/01%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="学习方法论"><a href="#学习方法论" class="headerlink" title="学习方法论"></a>学习方法论</h1><p>只要理解了应用程序和系统的少数几个基本原理，再进行大量的实战练习，建立起整体性能的全局观，大多数性能问题的优化就会水到渠成。</p><a id="more"></a><h1 id="性能指标是什么？"><a href="#性能指标是什么？" class="headerlink" title="性能指标是什么？"></a>性能指标是什么？</h1><p><img src="http://liyong.ac.cn/pic/920601da775da08844d231bc2b4c301d.png" alt="img"></p><p>随着应用负载的增加，系统资源的使用也会升高，甚至达到极限。而性能问题的本质，就是系统资源已经达到瓶颈，但请求的处理却还不够快，无法支撑更多的请求。</p><p>性能分析，其实就是<strong>找出应用或系统的瓶颈，并设法去避免或者缓解它们</strong>，从而更高效地利用系统资源处理更多的请求。这包含了一系列的步骤，比如下面这六个步骤。</p><ul><li>选择指标评估应用程序和系统的性能；</li><li>为应用程序和系统设置性能目标；</li><li>进行性能基准测试；</li><li>性能分析定位瓶颈；</li><li>优化系统和应用程序；</li><li>性能监控和告警。</li></ul><h1 id="学习的重点是什么？"><a href="#学习的重点是什么？" class="headerlink" title="学习的重点是什么？"></a>学习的重点是什么？</h1><p>想要学习好性能分析和优化，<strong>建立整体系统性能的全局观</strong>是最核心的话题。因而，</p><p>理解最基本的几个系统知识原理；<br>掌握必要的性能工具；<br>通过实际的场景演练，贯穿不同的组件。</p><p><img src="http://liyong.ac.cn/pic/linux_perf_tools_full.png" alt="img"></p><p>另外，我还要特别强调一点，就是<strong>性能工具的选用</strong>。有句话是这么说的，一个正确的选择胜过千百次的努力。虽然夸张了些，但是选用合适的性能工具，确实可以大大简化整个性能优化过程。在什么场景选用什么样的工具、以及怎么学会选择合适工具，都是我想教给你的东西。</p><p><img src="http://liyong.ac.cn/pic/20190402_01.png" alt="img"></p><h1 id="怎么学更高效？"><a href="#怎么学更高效？" class="headerlink" title="怎么学更高效？"></a>怎么学更高效？</h1><ul><li>技巧一：虽然系统的原理很重要，但在刚开始一定不要试图抓住所有的实现细节。<ul><li>有哪些指标可以衡量性能？</li><li>使用什么样的性能工具来观察指标？</li><li>导致这些指标变化的因素等。</li></ul></li><li>技巧二：边学边实践，通过大量的案例演习掌握 Linux 性能的分析和优化。</li><li>技巧三：勤思考，多反思，善总结，多问为什么。</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何用十条命令在一分钟内检查Linux服务器性能</title>
      <link href="/2019/04/12/aa_category/linux/%E5%A6%82%E4%BD%95%E7%94%A8%E5%8D%81%E6%9D%A1%E5%91%BD%E4%BB%A4%E5%9C%A8%E4%B8%80%E5%88%86%E9%92%9F%E5%86%85%E6%A3%80%E6%9F%A5Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD/"/>
      <url>/2019/04/12/aa_category/linux/%E5%A6%82%E4%BD%95%E7%94%A8%E5%8D%81%E6%9D%A1%E5%91%BD%E4%BB%A4%E5%9C%A8%E4%B8%80%E5%88%86%E9%92%9F%E5%86%85%E6%A3%80%E6%9F%A5Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h1><p>通过执行以下命令，可以在1分钟内对系统资源使用情况有个大致的了解。</p><ul><li>uptime</li><li>dmesg | tail</li><li>vmstat 1</li><li>mpstat -P ALL 1</li><li>pidstat 1</li><li>iostat -xz 1</li><li>free -m</li><li>sar -n DEV 1</li><li>sar -n TCP,ETCP 1</li><li>top</li></ul><a id="more"></a><p>其中一些命令需要安装sysstat包，有一些由procps包提供。这些命令的输出，有助于快速定位性能瓶颈，检查出所有资源（CPU、内存、磁盘IO等）的利用率（utilization）、饱和度（saturation）和错误（error）度量，也就是所谓的USE方法。</p><p>下面我们来逐一介绍下这些命令，有关这些命令更多的参数和说明，请参照命令的手册。</p><h1 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a><strong>uptime</strong></h1><p>$ uptime</p><p>23:51:26 up 21:31,  1 user,  load average: 30.02, 26.43, 19.02</p><p>这个命令可以快速查看机器的负载情况。在Linux系统中，这些数据表示等待CPU资源的进程和阻塞在不可中断IO进程（进程状态为D）的数量。这些数据可以让我们对系统资源使用有一个宏观的了解。</p><p>命令的输出分别表示1分钟、5分钟、15分钟的平均负载情况。通过这三个数据，可以了解服务器负载是在趋于紧张还是趋于缓解。如果1分钟平均负载很高，而15分钟平均负载很低，说明服务器正在命令高负载情况，需要进一步排查CPU资源都消耗在了哪里。反之，如果15分钟平均负载很高，1分钟平均负载较低，则有可能是CPU资源紧张时刻已经过去。</p><p>上面例子中的输出，可以看见最近1分钟的平均负载非常高，且远高于最近15分钟负载，因此我们需要继续排查当前系统中有什么进程消耗了大量的资源。可以通过下文将会介绍的vmstat、mpstat等命令进一步排查。</p><h1 id="dmesg丨tail"><a href="#dmesg丨tail" class="headerlink" title="dmesg丨tail"></a><strong>dmesg丨tail</strong></h1><p>$ dmesg | tail</p><p>[1880957.563150] perl invoked oom-killer: gfp_mask=0x280da, order=0, oom_score_adj=0</p><p>[…]</p><p>[1880957.563400] Out of memory: Kill process 18694 (perl) score 246 or sacrifice child</p><p>[1880957.563408] Killed process 18694 (perl) <a href="http://total-vm:1972392kB/" target="_blank" rel="noopener">total-vm:1972392kB</a>, <a href="http://anon-rss:1953348kB/" target="_blank" rel="noopener">anon-rss:1953348kB</a>, <a href="http://file-rss:0kB/" target="_blank" rel="noopener">file-rss:0kB</a></p><p>[2320864.954447] TCP: Possible SYN flooding on port 7001. Dropping</p><p>request.  Check SNMP counters.</p><p>该命令会输出系统日志的最后10行。示例中的输出，可以看见一次内核的oom kill和一次TCP丢包。这些日志可以帮助排查性能问题。千万不要忘了这一步。</p><h1 id="vmstat-1"><a href="#vmstat-1" class="headerlink" title="vmstat 1"></a><strong>vmstat 1</strong></h1><p>$ vmstat 1</p><p>procs ———memory———- —swap– —–io—- -system– ——cpu—–</p><p>r  b swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</p><p>34  0    0 200889792  73708 591828    0    0     0     5    6   10 96  1  3  0  0</p><p>32  0    0 200889920  73708 591860    0    0     0   592 13284 4282 98  1  1  0  0</p><p>32  0    0 200890112  73708 591860    0    0     0     0 9501 2154 99  1  0  0  0</p><p>32  0    0 200889568  73712 591856    0    0     0    48 11900 2459 99  0  0  0  0</p><p>32  0    0 200890208  73712 591860    0    0     0     0 15898 4840 98  1  1  0  0</p><p>^C</p><p>vmstat(8) 命令，每行会输出一些系统核心指标，这些指标可以让我们更详细的了解系统状态。后面跟的参数1，表示每秒输出一次统计信息，表头提示了每一列的含义，这几介绍一些和性能调优相关的列：</p><ul><li>r：等待在CPU资源的进程数。这个数据比平均负载更加能够体现CPU负载情况，数据中不包含等待IO的进程。如果这个数值大于机器CPU核数，那么机器的CPU资源已经饱和。</li><li>free：系统可用内存数（以千字节为单位），如果剩余内存不足，也会导致系统性能问题。下文介绍到的free命令，可以更详细的了解系统内存的使用情况。</li><li>si，so：交换区写入和读取的数量。如果这个数据不为0，说明系统已经在使用交换区（swap），机器物理内存已经不足。</li><li>us, sy, id, wa, st：这些都代表了CPU时间的消耗，它们分别表示用户时间（user）、系统（内核）时间（sys）、空闲时间（idle）、IO等待时间（wait）和被偷走的时间（stolen，一般被其他虚拟机消耗）。</li></ul><p>上述这些CPU时间，可以让我们很快了解CPU是否出于繁忙状态。一般情况下，如果用户时间和系统时间相加非常大，CPU出于忙于执行指令。如果IO等待时间很长，那么系统的瓶颈可能在磁盘IO。</p><p>示例命令的输出可以看见，大量CPU时间消耗在用户态，也就是用户应用程序消耗了CPU时间。这不一定是性能问题，需要结合r队列，一起分析。</p><h1 id="mpstat-P-ALL-1"><a href="#mpstat-P-ALL-1" class="headerlink" title="mpstat -P ALL 1"></a><strong>mpstat -P ALL 1</strong></h1><p>$ mpstat -P ALL 1</p><p>Linux 3.13.0-49-generic (titanclusters-xxxxx)  07/14/2015  <em>x86_64</em> (32 CPU)</p><p>07:38:49 PM  CPU   %usr  %nice   %sys %iowait   %irq  %soft  %steal  %guest  %gnice  %idle</p><p>07:38:50 PM  all  98.47   0.00   0.75    0.00   0.00   0.00    0.00    0.00    0.00   0.78</p><p>07:38:50 PM    0  96.04   0.00   2.97    0.00   0.00   0.00    0.00    0.00    0.00   0.99</p><p>07:38:50 PM    1  97.00   0.00   1.00    0.00   0.00   0.00    0.00    0.00    0.00   2.00</p><p>07:38:50 PM    2  98.00   0.00   1.00    0.00   0.00   0.00    0.00    0.00    0.00   1.00</p><p>07:38:50 PM    3  96.97   0.00   0.00    0.00   0.00   0.00    0.00    0.00    0.00   3.03</p><p>[…]</p><p>该命令可以显示每个CPU的占用情况，如果有一个CPU占用率特别高，那么有可能是一个单线程应用程序引起的。</p><h1 id="pidstat-1"><a href="#pidstat-1" class="headerlink" title="pidstat 1"></a><strong>pidstat 1</strong></h1><p>$ pidstat 1</p><p>Linux 3.13.0-49-generic (titanclusters-xxxxx)  07/14/2015    <em>x86_64</em>    (32 CPU)</p><p>07:41:02 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command</p><p>07:41:03 PM     0         9    0.00    0.94    0.00    0.94     1  rcuos/0</p><p>07:41:03 PM     0      4214    5.66    5.66    0.00   11.32    15  mesos-slave</p><p>07:41:03 PM     0      4354    0.94    0.94    0.00    1.89     8  java</p><p>07:41:03 PM     0      6521 1596.23    1.89    0.00 1598.11    27  java</p><p>07:41:03 PM     0      6564 1571.70    7.55    0.00 1579.25    28  java</p><p>07:41:03 PM 60004     60154    0.94    4.72    0.00    5.66     9  pidstat</p><p>07:41:03 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command</p><p>07:41:04 PM     0      4214    6.00    2.00    0.00    8.00    15  mesos-slave</p><p>07:41:04 PM     0      6521 1590.00    1.00    0.00 1591.00    27  <a href="http://java07:41:4/" target="_blank" rel="noopener">java07:41:04</a> PM     0      6564 1573.00   10.00    0.00 1583.00    28  java</p><p>07:41:04 PM   108      6718    1.00    0.00    0.00    1.00     0  snmp-pass</p><p>07:41:04 PM 60004     60154    1.00    4.00    0.00    5.00     9  pidstat</p><p>^C</p><p>pidstat命令输出进程的CPU占用率，该命令会持续输出，并且不会覆盖之前的数据，可以方便观察系统动态。如上的输出，可以看见两个JAVA进程占用了将近1600%的CPU时间，既消耗了大约16个CPU核心的运算资源。</p><h1 id="iostat-xz-1"><a href="#iostat-xz-1" class="headerlink" title="iostat -xz 1"></a><strong>iostat -xz 1</strong></h1><p>$ iostat -xz 1</p><p>Linux 3.13.0-49-generic (titanclusters-xxxxx)  07/14/2015  <em>x86_64</em> (32 CPU)</p><p>avg-cpu:  %user   %nice %system %iowait  %steal   %idle</p><p>​         73.96    0.00    3.73    0.03    0.06   22.21</p><p>Device:   rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</p><p>xvda        0.00     0.23    0.21    0.18     4.52     2.08    34.37     0.00    9.98   13.80    5.42   2.44   0.09</p><p>xvdb        0.01     0.00    1.02    8.94   127.97   598.53   145.79     0.00    0.43    1.78    0.28   0.25   0.25</p><p>xvdc        0.01     0.00    1.02    8.86   127.79   595.94   146.50     0.00    0.45    1.82    0.30   0.27   0.26</p><p>dm-0        0.00     0.00    0.69    2.32    10.47    31.69    28.01     0.01    3.23    0.71    3.98   0.13   0.04</p><p>dm-1        0.00     0.00    0.00    0.94     0.01     3.78     8.00     0.33  345.84    0.04  346.81   0.01   0.00</p><p>dm-2        0.00     0.00    0.09    0.07     1.35     0.36    22.50     0.00    2.55    0.23    5.62   1.78   0.03</p><p>[…]</p><p>^C</p><p>iostat命令主要用于查看机器磁盘IO情况。该命令输出的列，主要含义是：</p><ul><li>r/s, w/s, rkB/s, wkB/s：分别表示每秒读写次数和每秒读写数据量（千字节）。读写量过大，可能会引起性能问题。</li><li>await：IO操作的平均等待时间，单位是毫秒。这是应用程序在和磁盘交互时，需要消耗的时间，包括IO等待和实际操作的耗时。如果这个数值过大，可能是硬件设备遇到了瓶颈或者出现故障。</li><li>avgqu-sz：向设备发出的请求平均数量。如果这个数值大于1，可能是硬件设备已经饱和（部分前端硬件设备支持并行写入）。</li><li>%util：设备利用率。这个数值表示设备的繁忙程度，经验值是如果超过60，可能会影响IO性能（可以参照IO操作平均等待时间）。如果到达100%，说明硬件设备已经饱和。</li></ul><p>如果显示的是逻辑设备的数据，那么设备利用率不代表后端实际的硬件设备已经饱和。值得注意的是，即使IO性能不理想，也不一定意味这应用程序性能会不好，可以利用诸如预读取、写缓存等策略提升应用性能。</p><h1 id="free-m"><a href="#free-m" class="headerlink" title="free -m"></a><strong>free -m</strong></h1><p>$ free -m</p><p>​            total       used       free     shared    buffers     cached</p><p>Mem:        245998      24545     221453         83         59        541</p><p>-/+ buffers/cache:      23944     222053</p><p>Swap:            0          0          0</p><p>free命令可以查看系统内存的使用情况，-m参数表示按照兆字节展示。最后两列分别表示用于IO缓存的内存数，和用于文件系统页缓存的内存数。需要注意的是，第二行-/+ buffers/cache，看上去缓存占用了大量内存空间。</p><p>这是Linux系统的内存使用策略，尽可能的利用内存，如果应用程序需要内存，这部分内存会立即被回收并分配给应用程序。因此，这部分内存一般也被当成是可用内存。</p><p>如果可用内存非常少，系统可能会动用交换区（如果配置了的话），这样会增加IO开销（可以在iostat命令中提现），降低系统性能。</p><h1 id="sar-n-DEV-1"><a href="#sar-n-DEV-1" class="headerlink" title="sar -n DEV 1"></a><strong>sar -n DEV 1</strong></h1><p>$ sar -n DEV 1</p><p>Linux 3.13.0-49-generic (titanclusters-xxxxx)  07/14/2015     <em>x86_64</em>    (32 CPU)</p><p>12:16:48 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil</p><p>12:16:49 AM      eth0  18763.00   5032.00  20686.42    478.30      0.00      0.00      0.00      0.00</p><p>12:16:49 AM        lo     14.00     14.00      1.36      1.36      0.00      0.00      0.00      0.00</p><p>12:16:49 AM   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</p><p>12:16:49 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil</p><p>12:16:50 AM      eth0  19763.00   5101.00  21999.10    482.56      0.00      0.00      0.00      0.00</p><p>12:16:50 AM        lo     20.00     20.00      3.25      3.25      0.00      0.00      0.00      0.00</p><p>12:16:50 AM   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</p><p>^C</p><p>sar命令在这里可以查看网络设备的吞吐率。在排查性能问题时，可以通过网络设备的吞吐量，判断网络设备是否已经饱和。如示例输出中，eth0网卡设备，吞吐率大概在22 Mbytes/s，既176 Mbits/sec，没有达到1Gbit/sec的硬件上限。</p><h1 id="sar-n-TCP-ETCP-1"><a href="#sar-n-TCP-ETCP-1" class="headerlink" title="sar -n TCP,ETCP 1"></a><strong>sar -n TCP,ETCP 1</strong></h1><p>$ sar -n TCP,ETCP 1</p><p>Linux 3.13.0-49-generic (titanclusters-xxxxx)  07/14/2015    <em>x86_64</em>    (32 CPU)</p><p>12:17:19 AM  active/s passive/s    iseg/s    oseg/s</p><p>12:17:20 AM      1.00      0.00  10233.00  18846.00</p><p>12:17:19 AM  atmptf/s  estres/s retrans/s isegerr/s   orsts/s</p><p>12:17:20 AM      0.00      0.00      0.00      0.00      0.00</p><p>12:17:20 AM  active/s passive/s    iseg/s    oseg/s</p><p>12:17:21 AM      1.00      0.00   8359.00   6039.00</p><p>12:17:20 AM  atmptf/s  estres/s retrans/s isegerr/s   orsts/s</p><p>12:17:21 AM      0.00      0.00      0.00      0.00      0.00</p><p>^C</p><p>sar命令在这里用于查看TCP连接状态，其中包括：</p><ul><li>active/s：每秒本地发起的TCP连接数，既通过connect调用创建的TCP连接；</li><li>passive/s：每秒远程发起的TCP连接数，即通过accept调用创建的TCP连接；</li><li>retrans/s：每秒TCP重传数量；</li></ul><p>TCP连接数可以用来判断性能问题是否由于建立了过多的连接，进一步可以判断是主动发起的连接，还是被动接受的连接。TCP重传可能是因为网络环境恶劣，或者服务器压力过大导致丢包。</p><h1 id="top"><a href="#top" class="headerlink" title="top"></a><strong>top</strong></h1><p>$ top</p><p>top - 00:15:40 up 21:56,  1 user,  load average: 31.09, 29.87, 29.92</p><p>Tasks: 871 total,   1 running, 868 sleeping,   0 stopped,   2 zombie</p><p>%Cpu(s): 96.8 us,  0.4 sy,  0.0 ni,  2.7 id,  0.1 wa,  0.0 hi,  0.0 si,  0.0 st</p><p>KiB Mem:  25190241+total, 24921688 used, 22698073+free,    60448 buffers</p><p>KiB Swap:        0 total,        0 used,        0 free.   554208 cached Mem</p><p>  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</p><p>20248 root      20   0  0.227t 0.012t  18748 S  3090  5.2  29812:58 java</p><p> 4213 root      20   0 2722544  64640  44232 S  23.5  0.0 233:35.37 mesos-slave</p><p>66128 titancl+  20   0   24344   2332   1172 R   1.0  0.0   0:00.07 top</p><p> 5235 root      20   0 38.227g 547004  49996 S   0.7  0.2   2:02.74 java</p><p> 4299 root      20   0 20.015g 2.682g  16836 S   0.3  1.1  33:14.42 java     1 root      20   0   33620   2920   1496 S   0.0  0.0   0:03.82 init</p><p>​    2 root      20   0       0      0      0 S   0.0  0.0   0:00.02 kthreadd</p><p>​    3 root      20   0       0      0      0 S   0.0  0.0   0:05.35 ksoftirqd/0</p><p>​    5 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker/0:0H</p><p>​    6 root      20   0       0      0      0 S   0.0  0.0   0:06.94 kworker/u256:0</p><p>​    8 root      20   0       0      0      0 S   0.0  0.0   2:38.05 rcu_sched</p><p>top命令包含了前面好几个命令的检查的内容。比如系统负载情况（uptime）、系统内存使用情况（free）、系统CPU使用情况（vmstat）等。因此通过这个命令，可以相对全面的查看系统负载的来源。同时，top命令支持排序，可以按照不同的列排序，方便查找出诸如内存占用最多的进程、CPU占用率最高的进程等。</p><p>但是，top命令相对于前面一些命令，输出是一个瞬间值，如果不持续盯着，可能会错过一些线索。这时可能需要暂停top命令刷新，来记录和比对数据。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>排查Linux服务器性能问题还有很多工具，上面介绍的一些命令，可以帮助我们快速的定位问题。例如前面的示例输出，多个证据证明有JAVA进程占用了大量CPU资源，之后的性能调优就可以针对应用程序进行。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>33-34关于 Linux 网络，你必须知道这些</title>
      <link href="/2019/04/12/aa_category/linux/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/33-34%E5%85%B3%E4%BA%8E%20Linux%20%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E8%BF%99%E4%BA%9B/"/>
      <url>/2019/04/12/aa_category/linux/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/33-34%E5%85%B3%E4%BA%8E%20Linux%20%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E8%BF%99%E4%BA%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h1><a id="more"></a><h2 id="开放式系统互联通信参考模型-（Open-System-Interconnection-Reference-Model"><a href="#开放式系统互联通信参考模型-（Open-System-Interconnection-Reference-Model" class="headerlink" title="开放式系统互联通信参考模型(（Open System Interconnection Reference Model)"></a>开放式系统互联通信参考模型(（Open System Interconnection Reference Model)</h2><ul><li>应用层，负责为应用程序提供统一的接口。</li><li>表示层，负责把数据转换成兼容接收系统的格式。</li><li>会话层，负责维护计算机之间的通信连接。</li><li>传输层，负责为数据加上传输表头，形成数据包。</li><li>网络层，负责数据的路由和转发。</li><li>数据链路层，负责 MAC 寻址、错误侦测和改错。</li><li>物理层，负责在物理网络中传输数据帧。</li></ul><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><ul><li>应用层，负责向用户提供一组应用程序，比如 HTTP、FTP、DNS 等。</li><li>传输层，负责端到端的通信，比如 TCP、UDP 等。</li><li>网络层，负责网络包的封装、寻址和路由，比如 IP、ICMP 等。</li><li>网络接口层，负责网络包在物理网络中的传输，比如 MAC 寻址、错误侦测以及通过网卡传输网络帧等。</li></ul><p><img src="http://liyong.ac.cn/pic/f2dbfb5500c2aa7c47de6216ee7098bd" alt></p><p>七层和四层负载均衡，对应的分别是 OSI 模型中的应用层和传输层（而它们对应到 TCP/IP 模型中，实际上是四层和三层）。</p><h1 id="Linux-网络栈"><a href="#Linux-网络栈" class="headerlink" title="Linux 网络栈"></a>Linux 网络栈</h1><p>有了 TCP/IP 模型后，在进行网络传输时，数据包就会按照协议栈，对上一层发来的数据进行逐层处理；然后封装上该层的协议头，再发送给下一层。</p><p>而封装做的事情就很简单了，只是在原来的负载前后，增加固定格式的元数据，原始的负载数据并不会被修改。</p><p><img src="http://liyong.ac.cn/pic/c8dfe80acc44ba1aa9df327c54349e79.png" alt></p><p>物理链路中并不能传输任意大小的数据包。网络接口配置的最大传输单元（MTU），就规定了最大的 IP 包大小。在我们最常用的以太网中，MTU 默认值是 1500（这也是 Linux 的默认值）。</p><p>一旦网络包超过 MTU 的大小，就会在网络层分片，以保证分片后的 IP 包不大于 MTU 值。显然，MTU 越大，需要的分包也就越少，自然，网络吞吐能力就越好。</p><p><img src="http://liyong.ac.cn/pic/c7b5b16539f90caabb537362ee7c27ac.png" alt></p><h1 id="Linux-网络收发流程"><a href="#Linux-网络收发流程" class="headerlink" title="Linux 网络收发流程"></a>Linux 网络收发流程</h1><p><img src="http://liyong.ac.cn/pic/3af644b6d463869ece19786a4634f765.png" alt></p><p>当一个网络帧到达网卡后，网卡会通过 DMA 方式，把这个网络包放到收包队列中；然后通过硬中断，告诉中断处理程序已经收到了网络包。</p><p>接着，网卡中断处理程序会为网络帧分配内核数据结构（sk_buff），并将其拷贝到 sk_buff 缓冲区中；然后再通过软中断，通知内核收到了新的网络帧。</p><p>接下来，内核协议栈从缓冲区中取出网络帧，并通过网络协议栈，从下到上逐层处理这个网络帧。比如，</p><ul><li>在链路层检查报文的合法性，找出上层协议的类型（比如 IPv4 还是 IPv6），再去掉帧头、帧尾，然后交给网络层。</li><li>网络层取出 IP 头，判断网络包下一步的走向，比如是交给上层处理还是转发。当网络层确认这个包是要发送到本机后，就会取出上层协议的类型（比如 TCP 还是 UDP），去掉 IP 头，再交给传输层处理。</li><li>传输层取出 TCP 头或者 UDP 头后，根据 &lt; 源 IP、源端口、目的 IP、目的端口 &gt; 四元组作为标识，找出对应的 Socket，并把数据拷贝到 Socket 的接收缓存中。</li></ul><p>最后，应用程序就可以使用 Socket 接口，读取到新接收到的数据了。</p><h1 id="网络包的发送流程"><a href="#网络包的发送流程" class="headerlink" title="网络包的发送流程"></a>网络包的发送流程</h1><p>首先，应用程序调用 Socket API（比如 sendmsg）发送网络包。</p><p>由于这是一个系统调用，所以会陷入到内核态的套接字层中。套接字层会把数据包放到 Socket 发送缓冲区中。</p><p>接下来，网络协议栈从 Socket 发送缓冲区中，取出数据包；再按照 TCP/IP 栈，从上到下逐层处理。比如，传输层和网络层，分别为其增加 TCP 头和 IP 头，执行路由查找确认下一跳的 IP，并按照 MTU 大小进行分片。</p><p>分片后的网络包，再送到网络接口层，进行物理地址寻址，以找到下一跳的 MAC 地址。然后添加帧头和帧尾，放到发包队列中。这一切完成后，会有软中断通知驱动程序：发包队列中有新的网络帧需要发送。</p><p>最后，驱动程序通过 DMA ，从发包队列中读出网络帧，并通过物理网卡把它发送出去。</p><h1 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h1><ul><li><p><strong>带宽</strong>，表示链路的最大传输速率，单位通常为 b/s （比特 / 秒）。</p></li><li><p><strong>吞吐量</strong>，表示单位时间内成功传输的数据量，单位通常为 b/s（比特 / 秒）或者 B/s（字节 / 秒）。吞吐量受带宽限制，而吞吐量 / 带宽，也就是该网络的使用率。</p></li><li><p><strong>延时</strong>，表示从网络请求发出后，一直到收到远端响应，所需要的时间延迟。在不同场景中，这一指标可能会有不同含义。比如，它可以表示，建立连接需要的时间（比如 TCP 握手延时），或一个数据包往返所需的时间（比如 RTT）。</p></li><li><p><strong>延时</strong>，表示从网络请求发出后，一直到收到远端响应，所需要的时间延迟。在不同场景中，这一指标可能会有不同含义。比如，它可以表示，建立连接需要的时间（比如 TCP 握手延时），或一个数据包往返所需的时间（比如 RTT）。</p><ul><li>网络可用性</li></ul></li><li><p>并发连接数</p></li><li><p>丢包率</p></li><li><p>重传率</p></li></ul><h1 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig enp0s3</span><br><span class="line">ip -s addr show dev enp0s3</span><br></pre></td></tr></table></figure><ul><li><p>第一，网络接口的状态标志。ifconfig 输出中的 RUNNING ，或 ip 输出中的 LOWER_UP ，都表示物理网络是连通的，即网卡已经连接到了交换机或者路由器中。如果你看不到它们，通常表示网线被拔掉了。</p></li><li><p>第二，MTU 的大小。MTU 默认大小是 1500，根据网络架构的不同（比如是否使用了 VXLAN 等叠加网络），你可能需要调大或者调小 MTU 的数值。</p></li><li><p>第三，网络接口的 IP 地址、子网以及 MAC 地址。这些都是保障网络功能正常工作所必需的，你需要确保配置正确。</p></li><li><p>第四，网络收发的字节数、包数、错误数以及丢包情况，特别是 TX 和 RX 部分的 errors、dropped、overruns、carrier 以及 collisions 等指标不为 0 时，通常表示出现了网络 I/O 问题。其中：</p><ul><li>errors 表示发生错误的数据包数，比如校验错误、帧同步错误等；</li><li>dropped 表示丢弃的数据包数，即数据包已经收到了 Ring Buffer，但因为内存不足等原因丢包；</li><li>overruns 表示超限数据包数，即网络 I/O 速度过快，导致 Ring Buffer 中的数据包来不及处理（队列满）而导致的丢包；</li><li>carrier 表示发生 carrirer 错误的数据包数，比如双工模式不匹配、物理电缆出现问题等；</li><li>collisions 表示碰撞数据包数。</li></ul></li></ul><h1 id="套接字信息"><a href="#套接字信息" class="headerlink" title="套接字信息"></a>套接字信息</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># head -n 3 表示只显示前面 3 行</span></span><br><span class="line"><span class="comment"># -l 表示只显示监听套接字</span></span><br><span class="line"><span class="comment"># -n 表示显示数字地址和端口 (而不是名字)</span></span><br><span class="line"><span class="comment"># -p 表示显示进程信息</span></span><br><span class="line">netstat -nlp | head -n 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># -l 表示只显示监听套接字</span></span><br><span class="line"><span class="comment"># -t 表示只显示 TCP 套接字</span></span><br><span class="line"><span class="comment"># -n 表示显示数字地址和端口 (而不是名字)</span></span><br><span class="line"><span class="comment"># -p 表示显示进程信息</span></span><br><span class="line">ss -ltnp | head -n 3</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 协议栈统计信息</span></span><br><span class="line">netstat -s</span><br><span class="line">$ ss -s</span><br></pre></td></tr></table></figure><h1 id="网络吞吐和-PPS"><a href="#网络吞吐和-PPS" class="headerlink" title="网络吞吐和 PPS"></a>网络吞吐和 PPS</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数字 1 表示每隔 1 秒输出一组数据</span></span><br><span class="line">sar -n DEV 1</span><br></pre></td></tr></table></figure><ul><li>rxpck/s 和 txpck/s 分别是接收和发送的 PPS，单位为包 / 秒。</li><li>rxkB/s 和 txkB/s 分别是接收和发送的吞吐量，单位是 KB/ 秒。</li><li>rxcmp/s 和 txcmp/s 分别是接收和发送的压缩数据包数，单位是包 / 秒。</li><li>%ifutil 是网络接口的使用率，即半双工模式下为 (rxkB/s+txkB/s)/Bandwidth，而全双工模式下为 max(rxkB/s, txkB/s)/Bandwidth。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool eth0 | grep Speed</span><br></pre></td></tr></table></figure><h1 id="连通性和延时"><a href="#连通性和延时" class="headerlink" title="连通性和延时"></a>连通性和延时</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -c3 表示发送三次 ICMP 包后停止</span></span><br><span class="line">ping -c3 114.114.114.114</span><br></pre></td></tr></table></figure><ul><li>第一部分，是每个 ICMP 请求的信息，包括 ICMP 序列号（icmp_seq）、TTL（生存时间，或者跳数）以及往返延时。</li><li>第二部分，则是三次 ICMP 请求的汇总。</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02基础篇：到底应该怎么理解“平均负载”</title>
      <link href="/2019/04/12/aa_category/linux/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/02%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9A%E5%88%B0%E5%BA%95%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E2%80%9C%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD%E2%80%9D/"/>
      <url>/2019/04/12/aa_category/linux/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/02%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9A%E5%88%B0%E5%BA%95%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E2%80%9C%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h1><p>平均负载是指单位时间内，系统处于<strong>可运行状态</strong>和<strong>不可中断状态</strong>的平均进程数，也就是<strong>平均活跃进程数</strong>，它和 CPU 使用率并没有直接关系。</p><p>可运行状态的进程，是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们常用 ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程。</p><p>不可中断状态的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应，也就是我们在 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程。</p><p>不可中断状态实际上是系统对进程和硬件设备的一种保护机制</p><p>平均负载其实就是平均活跃进程数。平均活跃进程数，直观上的理解就是单位时间内的活跃进程数，但它实际上是活跃进程数的指数衰减平均值。这个“指数衰减平均”的详细含义你不用计较，这只是系统的一种更快速的计算方式，你把它直接当成活跃进程数的平均值也没问题。</p><a id="more"></a><p>既然平均的是活跃进程数，那么最理想的，就是每个 CPU 上都刚好运行着一个进程，这样每个 CPU 都得到了充分利用。比如当平均负载为 2 时，意味着什么呢？</p><p>在只有 2 个 CPU 的系统上，意味着所有的 CPU 都刚好被完全占用。</p><p>在 4 个 CPU 的系统上，意味着 CPU 有 50% 的空闲。</p><p>而在只有 1 个 CPU 的系统中，则意味着有一半的进程竞争不到 CPU。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关于 grep 和 wc 的用法请查询它们的手册或者网络搜索</span></span><br><span class="line">$ grep <span class="string">'model name'</span> /proc/cpuinfo | wc -l</span><br></pre></td></tr></table></figure><ul><li>当平均负载高于 CPU 数量 70% 的时候</li></ul><h1 id="平均负载与-CPU-使用率"><a href="#平均负载与-CPU-使用率" class="headerlink" title="平均负载与 CPU 使用率"></a>平均负载与 CPU 使用率</h1><p>CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的；</p><p>I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高；</p><p>大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高。</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><ul><li>more /etc/issue    查看系统版本</li><li>安装  stress 和 sysstat。</li></ul><h2 id="stress"><a href="#stress" class="headerlink" title="stress"></a>stress</h2><p><a href="https://wiki.archlinux.org/index.php/Stress_testing" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Stress_testing</a></p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cpu</span></span><br><span class="line">$ <span class="string">stress </span><span class="built_in">--cpu</span> 1 <span class="built_in">--timeout</span> <span class="string">600</span></span><br><span class="line"><span class="string">#</span> <span class="string">io</span></span><br><span class="line"><span class="string">$</span> <span class="string">stress </span>-i 1 <span class="built_in">--timeout</span> <span class="string">600</span></span><br><span class="line"><span class="string">#</span> 并发</span><br><span class="line">$ <span class="string">stress </span>-c 8 <span class="built_in">--timeout</span> <span class="string">600</span></span><br></pre></td></tr></table></figure><h2 id="sysstat"><a href="#sysstat" class="headerlink" title="sysstat"></a>sysstat</h2><p><a href="https://github.com/sysstat/sysstat" target="_blank" rel="noopener">https://github.com/sysstat/sysstat</a></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> # 显示所有 CPU 的指标，并在间隔 <span class="number">5</span> 秒输出一组数据</span><br><span class="line"> mpstat -P ALL <span class="number">5</span> <span class="number">1</span></span><br><span class="line"> # 间隔 <span class="number">5</span> 秒后输出一组数据，-u 表示 CPU 指标</span><br><span class="line">pidstat -u <span class="number">5</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8事务到底是隔离的还是不隔离的</title>
      <link href="/2019/03/11/aa_category/db/mysql/mysql%E5%AE%9E%E6%88%98/8%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%BA%95%E6%98%AF%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%98%E6%98%AF%E4%B8%8D%E9%9A%94%E7%A6%BB%E7%9A%84/"/>
      <url>/2019/03/11/aa_category/db/mysql/mysql%E5%AE%9E%E6%88%98/8%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%BA%95%E6%98%AF%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%98%E6%98%AF%E4%B8%8D%E9%9A%94%E7%A6%BB%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p><img src="http://liyong.ac.cn/pic/C1550281789388.png" alt="1550281789388"></p><p>begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句（第一个快照读语句），事务才真正启动。如果你想要马上启动一个事务，可以使用 start transaction with consistent snapshot 这个命令。    </p><a id="more"></a>       <h1 id="快照”在-MVCC-里是怎么工作的"><a href="#快照”在-MVCC-里是怎么工作的" class="headerlink" title="快照”在 MVCC 里是怎么工作的"></a>快照”在 MVCC 里是怎么工作的</h1><p> <img src="http://liyong.ac.cn/pic/1547518976274.png" alt="1547518976274"></p><p>InnoDB为每个事物构造了一个数组，用来保存启动瞬间，当前正在活跃的事务ID,活跃是指启动但是未提交</p><p>当前系统里面已经创建的事务ID最大值加1记为高水位</p><p><img src="http://liyong.ac.cn/pic/1547519067829.png" alt="1547519067829">对于当前事务启动瞬间来说，一个数据版本row trx_id有集中可能</p><ul><li>如果小于低水位，落在绿色区间，可见</li><li>如果大于高水位，落在红色区间 ，不可见</li><li>如果落在黄色区间不可见</li><li>版本未提交，不可见；</li><li>版本已提交，但是是在视图创建后提交的，不可见；</li><li>版本已提交，而且是在视图创建前提交的，可见。</li></ul><h2 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h2><ul><li><p>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读“</p></li><li><p>这里我们提到了一个概念，叫作当前读。其实，除了 update 语句外，select 语句如果加锁，也是当前读。</p></li><li><p>update 属于排它锁，一定要等待其他线程写完</p></li></ul><h2 id="可重复读-amp-读提交"><a href="#可重复读-amp-读提交" class="headerlink" title="可重复读&amp;读提交"></a>可重复读&amp;读提交</h2><ul><li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</li><li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</li></ul>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> db </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>28-29基准测试框架JMH</title>
      <link href="/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/28-29%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6JMH/"/>
      <url>/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/28-29%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6JMH/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DinteractiveMode=<span class="literal">false</span> -DarchetypeGroupId=org.openjdk.jmh -DarchetypeArtifactId=jmh-java-benchmark-archetype -DgroupId=com.jenkov -DartifactId=first-benchmark -Dversion=1.0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>27注解处理器</title>
      <link href="/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/27%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8/"/>
      <url>/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/27%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="注解处理器的原理"><a href="#注解处理器的原理" class="headerlink" title="注解处理器的原理"></a>注解处理器的原理</h1><h2 id="Java-编译器的工作流程"><a href="#Java-编译器的工作流程" class="headerlink" title="Java 编译器的工作流程"></a>Java 编译器的工作流程</h2><p><img src="http://liyong.ac.cn/pic/5C1553688920602.png" alt="1553688920602"></p><ol>将源文件解析为抽象语法树；调用已注册的注解处理器；生成字节码。</ol><a id="more"></a><h1 id="Processor"><a href="#Processor" class="headerlink" title="Processor"></a>Processor</h1><ul><li>所有的注解都要实现该接口</li><li>@SupportedAnnotationTypes</li><li>@SupportedSourceVersion</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnv)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ javac -cp /CLASSPATH/TO/CheckGetterProcessor -processor bar.CheckGetterProcessor Foo.java</span><br><span class="line">error: Class <span class="string">'Foo'</span> is annotated as @CheckGetter, but field <span class="string">'a'</span> is without getter</span><br><span class="line">1 error</span><br></pre></td></tr></table></figure><h1 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h1><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li><a href="http://openjdk.java.net/groups/compiler/doc/compilation-overview/index.html" target="_blank" rel="noopener">http://openjdk.java.net/groups/compiler/doc/compilation-overview/index.html</a></li><li><a href="http://hannesdorfmann.com/annotation-processing/annotationprocessing101" target="_blank" rel="noopener">http://hannesdorfmann.com/annotation-processing/annotationprocessing101</a></li><li><a href="https://docs.oracle.com/javase/10/docs/api/javax/lang/model/element/package-summary.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/10/docs/api/javax/lang/model/element/package-summary.html</a></li><li><a href="https://projectlombok.org/" target="_blank" rel="noopener">https://projectlombok.org/</a></li><li><a href="http://notatube.blogspot.com/2010/11/project-lombok-trick-explained.html" target="_blank" rel="noopener">http://notatube.blogspot.com/2010/11/project-lombok-trick-explained.html</a></li><li><a href="http://jnb.ociweb.com/jnb/jnbJan2010.html#controversy" target="_blank" rel="noopener">http://jnb.ociweb.com/jnb/jnbJan2010.html#controversy</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22HotSpot虚拟机的intrinsic</title>
      <link href="/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/22HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84intrinsic/"/>
      <url>/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/22HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84intrinsic/</url>
      
        <content type="html"><![CDATA[<p>换句话说，HotSpot 虚拟机将为标注了@HotSpotIntrinsicCandidate注解的方法额外维护一套高效实现。如果 Java 核心类库的开发者更改了原本的实现，那么虚拟机中的高效实现也需要进行相应的修改，以保证程序语义一致。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li><a href="http://openjdk.java.net/jeps/254" target="_blank" rel="noopener">http://openjdk.java.net/jeps/254</a></li><li><a href="http://hg.openjdk.java.net/jdk/hs/file/46dc568d6804/src/hotspot/share/classfile/vmSymbols.hpp#l727" target="_blank" rel="noopener">http://hg.openjdk.java.net/jdk/hs/file/46dc568d6804/src/hotspot/share/classfile/vmSymbols.hpp#l727</a></li><li><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/2af8917ffbee/src/share/vm/classfile/vmSymbols.hpp#l647" target="_blank" rel="noopener">http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/2af8917ffbee/src/share/vm/classfile/vmSymbols.hpp#l647</a></li></ul><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20-21方法内联</title>
      <link href="/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/20-21%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94/"/>
      <url>/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/20-21%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94/</url>
      
        <content type="html"><![CDATA[<p>在编译过程中遇到方法调用时，将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段。</p><p>以 getter/setter 为例，如果没有方法内联，在调用 getter/setter 时，程序需要保存当前方法的执行位置，创建并压入用于 getter/setter 的栈帧、访问字段、弹出栈帧，最后再恢复当前方法的执行。而当内联了对 getter/setter 的方法调用后，上述操作仅剩字段访问。</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19Java字节码</title>
      <link href="/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/19Java%E5%AD%97%E8%8A%82%E7%A0%81/"/>
      <url>/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/19Java%E5%AD%97%E8%8A%82%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h1><h2 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h2><p>通常用于复制 new 指令生成的未初始化的引用</p><a id="more"></a><h2 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h2><p>通常用来舍弃调用指令的返回结果</p><h2 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h2><p>用来交换栈顶的两个元素</p><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><ul><li>生成该类的未初始化的对象</li><li>Create a new class instance </li></ul><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><ul><li>判断栈顶元素是否为目标类 / 接口的实例。是则压入 1，否则压入 0</li><li>Check properties of class instances or arrays </li></ul><h2 id="checkcast"><a href="#checkcast" class="headerlink" title="checkcast"></a>checkcast</h2><p>判断栈顶元素是否为目标类 / 接口的实例。如果不是便抛出异常</p><h2 id="athrow"><a href="#athrow" class="headerlink" title="athrow"></a>athrow</h2><p>将栈顶异常抛出</p><h2 id="monitorenter"><a href="#monitorenter" class="headerlink" title="monitorenter"></a>monitorenter</h2><p>为栈顶对象加锁</p><h2 id="monitorexit"><a href="#monitorexit" class="headerlink" title="monitorexit"></a>monitorexit</h2><p>为栈顶对象解锁</p><h1 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h1><ul><li>存放计算的操作数以及返回的结果</li><li>java每执行一条指令前要求该指令的操作数已经压入操作数栈</li><li>在执行指令的时候会将指令弹出栈，并将计算结果压入操作数栈</li></ul><h1 id="常量加载到操作数栈"><a href="#常量加载到操作数栈" class="headerlink" title="常量加载到操作数栈"></a>常量加载到操作数栈</h1><p> <img src="https://liyong.ac.cn/pic/1545569191786.png" alt="1545569268350"></p><h1 id="局部变量加载存储指令"><a href="#局部变量加载存储指令" class="headerlink" title="局部变量加载存储指令"></a>局部变量加载存储指令</h1><p><img src="https://liyong.ac.cn/pic/1545569581309.png" alt="1545569581309"></p><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><ul><li>是一个数组</li><li>this指针(非静态方法)</li><li>方法参数</li><li>字节码内部变量</li></ul><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li>aload 0 指加载第0 局部变量元素到栈</li></ul><h1 id="数组访问指令"><a href="#数组访问指令" class="headerlink" title="数组访问指令"></a>数组访问指令</h1><p><img src="https://liyong.ac.cn/pic/5C1552913579687.png" alt="1552913579687"></p><h2 id="返回指令表"><a href="#返回指令表" class="headerlink" title="返回指令表"></a>返回指令表</h2><p><img src="https://liyong.ac.cn/pic/5C1552913646446.png" alt="1552913646446"></p><h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><p><a href="https://docs.oracle.com/javase/specs/jvms/se10/html/jvms-6.html#jvms-6.5" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se10/html/jvms-6.html#jvms-6.5</a></p>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18即时编译器的中间表达形式</title>
      <link href="/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/18%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%A1%A8%E8%BE%BE%E5%BD%A2%E5%BC%8F/"/>
      <url>/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/18%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%A1%A8%E8%BE%BE%E5%BD%A2%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="中间表达形式（IR）"><a href="#中间表达形式（IR）" class="headerlink" title="中间表达形式（IR）"></a>中间表达形式（IR）</h1><p>如果不考虑解释执行的话，从 Java 源代码到最终的机器码实际上经过了两轮编译：Java 编译器将 Java 源代码编译成 Java 字节码，而即时编译器则将 Java 字节码编译成机器码。</p><p> Java 字节码本身并不适合直接作为可供优化的 IR。这是因为现代编译器一般采用静态单赋值（Static Single Assignment，SSA）IR。这种 IR 的特点是每个变量只能被赋值一次，而且只有当变量被赋值之后才能使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">x1=<span class="number">4</span>*<span class="number">1024</span> 经过常量折叠后变为 x1=<span class="number">4096</span></span><br><span class="line">x1=<span class="number">4</span>; y1=x1 经过常量传播后变为 x1=<span class="number">4</span>; y1=<span class="number">4</span></span><br><span class="line">y1=x1*<span class="number">3</span> 经过强度削减后变为 y1=(x1&lt;&lt;<span class="number">1</span>)+x1</span><br><span class="line"><span class="keyword">if</span>(<span class="number">2</span>&gt;<span class="number">1</span>)&#123;y1=<span class="number">1</span>;&#125;<span class="keyword">else</span>&#123;y2=<span class="number">1</span>;&#125;经过死代码删除后变为 y1=<span class="number">1</span></span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="Sea-of-nodes"><a href="#Sea-of-nodes" class="headerlink" title="Sea-of-nodes"></a>Sea-of-nodes</h1><h1 id="Gloval-Value-Numbering"><a href="#Gloval-Value-Numbering" class="headerlink" title="Gloval Value Numbering"></a>Gloval Value Numbering</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>哥，讲的太深了，暂时根本用不到</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li><a href="https://en.wikipedia.org/wiki/Static_single_assignment_form" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Static_single_assignment_form</a></li><li><a href="https://en.wikipedia.org/wiki/Reaching_definition" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Reaching_definition</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>16-17即时编译</title>
      <link href="/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/16-17%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91/"/>
      <url>/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/16-17%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h1 id="分层编译将-Java-虚拟机的执行状态分为了五个层次"><a href="#分层编译将-Java-虚拟机的执行状态分为了五个层次" class="headerlink" title="分层编译将 Java 虚拟机的执行状态分为了五个层次"></a>分层编译将 Java 虚拟机的执行状态分为了五个层次</h1><ol><li>解释执行；</li><li>执行不带 profiling 的 C1 代码；</li><li>执行仅带方法调用次数以及循环回边执行次数 profiling 的 C1 代码；</li><li>执行带所有 profiling 的 C1 代码；</li><li>执行 C2 代码。</li></ol><a id="more"></a><p>通常情况下，C2 代码的执行效率要比 C1 代码的高出 30% 以上。然而，对于 C1 代码的三种状态，按执行效率从高至低则是 1 层 &gt; 2 层 &gt; 3 层。</p><p>其中 1 层的性能比 2 层的稍微高一些，而 2 层的性能又比 3 层高出 30%。这是因为 profiling 越多，其额外的性能开销越大。</p><p>profiling 是指在程序执行过程中，收集能够反映程序执行状态的数据。这里所收集的数据我们称之为程序的 profile。</p><p><img src="http://liyong.ac.cn/pic/5C1553565062936.png" alt="1553565062936"></p><h1 id="OSR-（On-Stack-Replacement）编译"><a href="#OSR-（On-Stack-Replacement）编译" class="headerlink" title="OSR （On-Stack-Replacement）编译"></a>OSR （On-Stack-Replacement）编译</h1><p>它指的是在程序执行过程中，动态地替换掉 Java 方法栈桢，从而使得程序能够在非方法入口处进行解释执行和编译后的代码之间的切换。事实上，去优化（deoptimization）采用的技术也可以称之为 OSR。</p><p>在不启用分层编译的情况下，触发 OSR 编译的阈值是由参数 -XX:CompileThreshold 指定的阈值的倍数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(OnStackReplacePercentage - InterpreterProfilePercentage)/100</span><br><span class="line"></span><br><span class="line">其中 -XX:InterpreterProfilePercentage 的默认值为 33，当使用 C1 时 -XX:OnStackReplacePercentage 为 933，当使用 C2 时为 140。</span><br></pre></td></tr></table></figure><p>在启用分层编译的情况下，触发 OSR 编译的阈值则是由参数 -XX:TierXBackEdgeThreshold 指定的阈值乘以系数。</p><h1 id="基于分支-profile-的优化"><a href="#基于分支-profile-的优化" class="headerlink" title="基于分支 profile 的优化"></a>基于分支 profile 的优化</h1><p> 根据条件跳转指令的分支 profile，即时编译器可以将从未执行过的分支剪掉，以避免编译这些很有可能不会用到的代码，从而节省编译时间以及部署代码所要消耗的内存空间。此外，“剪枝”将精简程序的数据流，从而触发更多的优化。</p><h1 id="基于类型-profile-的优化"><a href="#基于类型-profile-的优化" class="headerlink" title="基于类型 profile 的优化"></a>基于类型 profile 的优化</h1><p>在 Java 虚拟机中，instanceof 测试并不简单。如果 instanceof 的目标类型是 final 类型，那么 Java 虚拟机仅需比较测试对象的动态类型是否为该 final 类型。</p><p>如果目标类型不是 final 类型，比如说我们例子中的 Exception，那么 Java 虚拟机需要从测试对象的动态类型开始，依次测试该类，该类的父类、祖先类，该类所直接实现或者间接实现的接口是否与目标类型一致。</p><h1 id="去优化"><a href="#去优化" class="headerlink" title="去优化"></a>去优化</h1><p>Java 虚拟机给出的解决方案便是去优化，即从执行即时编译生成的机器码切换回解释执行。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>今天的实践环节，你可以使用参数 -XX:+PrintCompilation 来打印你项目中的即时编译情况。</p>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15Java语法糖与Java编译器</title>
      <link href="/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/15Java%E8%AF%AD%E6%B3%95%E7%B3%96%E4%B8%8EJava%E7%BC%96%E8%AF%91%E5%99%A8/"/>
      <url>/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/15Java%E8%AF%AD%E6%B3%95%E7%B3%96%E4%B8%8EJava%E7%BC%96%E8%AF%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="自动装箱与自动拆箱"><a href="#自动装箱与自动拆箱" class="headerlink" title="自动装箱与自动拆箱"></a>自动装箱与自动拆箱</h1><p>也就是说，我们可以通过配置该参数，扩大 Integer 缓存的范围。Java 虚拟机参数 -XX:+AggressiveOpts 也会将 IntegerCache.high 调整至 20000。</p><a id="more"></a><h1 id="泛型与类型擦除"><a href="#泛型与类型擦除" class="headerlink" title="泛型与类型擦除"></a>泛型与类型擦除</h1><h1 id="桥接方法"><a href="#桥接方法" class="headerlink" title="桥接方法"></a>桥接方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberF</span>&lt;<span class="title">T</span> <span class="keyword">extends</span>  <span class="title">Number</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T number)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberS</span> <span class="keyword">extends</span> <span class="title">NumberF</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Integer number)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">javap -v NumberS.class</span><br><span class="line">Classfile /D:/workspace/demo/se-demo/src/main/java/brige/NumberS.class</span><br><span class="line">  Last modified 2019-3-26; size 550 bytes</span><br><span class="line">  MD5 checksum 5434bc6cbc8277ec249d44c992fe26bc</span><br><span class="line">  Compiled from <span class="string">"NumberS.java"</span></span><br><span class="line">public class brige.NumberS extends brige.NumberF&lt;java.lang.Integer&gt;</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   <span class="comment">#1 = Methodref          #5.#21         // brige/NumberF."&lt;init&gt;":()V</span></span><br><span class="line">   <span class="comment">#2 = Class              #22            // java/lang/Integer</span></span><br><span class="line">   <span class="comment">#3 = Methodref          #4.#23         // brige/NumberS.add:(Ljava/lang/</span></span><br><span class="line">Integer;)V</span><br><span class="line">   <span class="comment">#4 = Class              #24            // brige/NumberS</span></span><br><span class="line">   <span class="comment">#5 = Class              #25            // brige/NumberF</span></span><br><span class="line">   <span class="comment">#6 = Utf8               &lt;init&gt;</span></span><br><span class="line">   <span class="comment">#7 = Utf8               ()V</span></span><br><span class="line">   <span class="comment">#8 = Utf8               Code</span></span><br><span class="line">   <span class="comment">#9 = Utf8               LineNumberTable</span></span><br><span class="line">  <span class="comment">#10 = Utf8               add</span></span><br><span class="line">  <span class="comment">#11 = Utf8               (Ljava/lang/Integer;)V</span></span><br><span class="line">  <span class="comment">#12 = Utf8               foo</span></span><br><span class="line">  <span class="comment">#13 = Utf8               ([I)V</span></span><br><span class="line">  <span class="comment">#14 = Utf8               StackMapTable</span></span><br><span class="line">  <span class="comment">#15 = Class              #26            // "[I"</span></span><br><span class="line">  <span class="comment">#16 = Utf8               (Ljava/lang/Number;)V</span></span><br><span class="line">  <span class="comment">#17 = Utf8               Signature</span></span><br><span class="line">  <span class="comment">#18 = Utf8               Lbrige/NumberF&lt;Ljava/lang/Integer;&gt;;</span></span><br><span class="line">  <span class="comment">#19 = Utf8               SourceFile</span></span><br><span class="line">  <span class="comment">#20 = Utf8               NumberS.java</span></span><br><span class="line">  <span class="comment">#21 = NameAndType        #6:#7          // "&lt;init&gt;":()V</span></span><br><span class="line">  <span class="comment">#22 = Utf8               java/lang/Integer</span></span><br><span class="line">  <span class="comment">#23 = NameAndType        #10:#11        // add:(Ljava/lang/Integer;)V</span></span><br><span class="line">  <span class="comment">#24 = Utf8               brige/NumberS</span></span><br><span class="line">  <span class="comment">#25 = Utf8               brige/NumberF</span></span><br><span class="line">  <span class="comment">#26 = Utf8               [I</span></span><br><span class="line">&#123;</span><br><span class="line">  public brige.NumberS();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial <span class="comment">#1                  // Method brige/NumberF."&lt;ini</span></span><br><span class="line">t&gt;<span class="string">":()V</span></span><br><span class="line"><span class="string">         4: return</span></span><br><span class="line"><span class="string">      LineNumberTable:</span></span><br><span class="line"><span class="string">        line 16: 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  public void add(java.lang.Integer);</span></span><br><span class="line"><span class="string">    descriptor: (Ljava/lang/Integer;)V</span></span><br><span class="line"><span class="string">    flags: ACC_PUBLIC</span></span><br><span class="line"><span class="string">    Code:</span></span><br><span class="line"><span class="string">      stack=0, locals=2, args_size=2</span></span><br><span class="line"><span class="string">         0: return</span></span><br><span class="line"><span class="string">      LineNumberTable:</span></span><br><span class="line"><span class="string">        line 21: 0</span></span><br><span class="line"><span class="string">  // 桥接方法</span></span><br><span class="line"><span class="string">  public void add(java.lang.Number);</span></span><br><span class="line"><span class="string">    descriptor: (Ljava/lang/Number;)V</span></span><br><span class="line"><span class="string">    flags: ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC</span></span><br><span class="line"><span class="string">    Code:</span></span><br><span class="line"><span class="string">      stack=2, locals=2, args_size=2</span></span><br><span class="line"><span class="string">         0: aload_0</span></span><br><span class="line"><span class="string">         1: aload_1</span></span><br><span class="line"><span class="string">         2: checkcast     #2                  // class java/lang/Integer</span></span><br><span class="line"><span class="string">         5: invokevirtual #3                  // Method add:(Ljava/lang/Int</span></span><br><span class="line"><span class="string">eger;)V</span></span><br><span class="line"><span class="string">         8: return</span></span><br><span class="line"><span class="string">      LineNumberTable:</span></span><br><span class="line"><span class="string">        line 16: 0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">Signature: #18                          // Lbrige/NumberF&lt;Ljava/lang/Intege</span></span><br><span class="line"><span class="string">r;&gt;;</span></span><br><span class="line"><span class="string">SourceFile: "</span>NumberS.java<span class="string">"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20幻读是什么，幻读有什么问题</title>
      <link href="/2019/03/11/aa_category/db/mysql/mysql%E5%AE%9E%E6%88%98/20%E5%B9%BB%E8%AF%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%B9%BB%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/"/>
      <url>/2019/03/11/aa_category/db/mysql/mysql%E5%AE%9E%E6%88%98/20%E5%B9%BB%E8%AF%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%B9%BB%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="幻读是什么"><a href="#幻读是什么" class="headerlink" title="幻读是什么"></a>幻读是什么</h1><p><img src="http://liyong.ac.cn/pic/1547689067869.png" alt="1547689067869"></p><ul><li>幻读是指新插入的行</li></ul><h1 id="幻读有什么问题"><a href="#幻读有什么问题" class="headerlink" title="幻读有什么问题"></a>幻读有什么问题</h1><p><img src="http://liyong.ac.cn/pic/1547689596472.png" alt="1547689596472"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> t <span class="keyword">where</span> d=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">//会把扫描中遇到的行都加锁</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d =<span class="number">100</span> <span class="keyword">where</span> d=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> t <span class="keyword">where</span> d=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> t <span class="keyword">where</span> d=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d=<span class="number">5</span>  <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c=<span class="number">5</span>  <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c=<span class="number">5</span>  <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><h1 id="如何解决幻读"><a href="#如何解决幻读" class="headerlink" title="如何解决幻读"></a>如何解决幻读</h1><p><img src="http://liyong.ac.cn/pic/1547694691025.png" alt="1547694691025"></p><ul><li><p>跟行锁有冲突关系的是“另外一个行锁</p></li><li><p>跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作</p></li></ul><p><img src="http://liyong.ac.cn/pic/1547695323532.png" alt="1547695323532"></p>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> db </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13Java内存模型</title>
      <link href="/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/13Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/13Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>, b=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> r2 = a;</span><br><span class="line">  b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> r1 = b;</span><br><span class="line">  a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="多线程乱序"><a href="#多线程乱序" class="headerlink" title="多线程乱序"></a>多线程乱序</h1><ul><li>及时编译器的重排序</li><li>处理器的乱序执行</li><li>内存系统的重排序</li></ul><h1 id="Java-内存模型和-happens-before关系"><a href="#Java-内存模型和-happens-before关系" class="headerlink" title="Java 内存模型和 happens-before关系"></a>Java 内存模型和 happens-before关系</h1><ul><li>单线程内，编写顺序和执行顺序一致</li><li>解锁操作在加锁操作之后</li><li>volatile字段操读作先于写操作</li><li>线程的start方法先行与此线程的每一个动作</li><li>线程的所有操作先行于线程的终止检测</li><li>对线程的interrupt()方法调用优先于被中断线程的代码检测到中断事件</li><li>对象的构造方法先行于finalize()方法</li><li>传递性，A先行于B,B先行于C,那么A先行于C</li></ul><h1 id="Java-内存模型的底层实现"><a href="#Java-内存模型的底层实现" class="headerlink" title="Java 内存模型的底层实现"></a>Java 内存模型的底层实现</h1><p> Java 内存模型是通过内存屏障（memory barrier）来禁止重排序的。</p><p>对于即时编译器来说，它会针对前面提到的每一个 happens-before 关系，向正在编译的目标方法中插入相应的读读、读写、写读以及写写内存屏障。</p><p>这些内存屏障会限制即时编译器的重排序操作。以 volatile 字段访问为例，所插入的内存屏障将不允许 volatile 字段写操作之前的内存访问被重排序至其之后；也将不允许 volatile 字段读操作之后的内存访问被重排序至其之前。</p><p>在 X86_64 平台上，只有 volatile 字段的写操作会强制刷新缓存。因此，理想情况下对 volatile 字段的使用应当多读少写，并且应当只有一个线程进行写操作。</p><p>volatile 字段的另一个特性是即时编译器无法将其分配到寄存器里。换句话说，volatile 字段的每次访问均需要直接从内存中读写。</p><p>final 实例字段则涉及新建对象的发布问题。当一个对象包含 final 实例字段时，我们希望其他线程只能看到已初始化的 final 实例字段。</p><p>因此，即时编译器会在 final 字段的写操作后插入一个写写屏障，以防某些优化将新建对象的发布（即将实例对象写入一个共享引用中）重排序至 final 字段的写操作之前。在 X86_64 平台上，写写屏障是空操作。</p><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ul><li><a href="https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4</a></li><li><a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html" target="_blank" rel="noopener">http://gee.cs.oswego.edu/dl/jmm/cookbook.html</a></li><li><a href="https://blogs.oracle.com/dave/instruction-selection-for-volatile-fences-:-mfence-vs-lock:add" target="_blank" rel="noopener">https://blogs.oracle.com/dave/instruction-selection-for-volatile-fences-:-mfence-vs-lock:add</a></li><li><a href="https://vlkan.com/blog/post/2014/02/14/java-safe-publication/" target="_blank" rel="noopener">https://vlkan.com/blog/post/2014/02/14/java-safe-publication/</a></li><li><a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/CodeTools/jcstress</a></li><li><a href="http://hg.openjdk.java.net/code-tools/jcstress/file/64f2cf32fa0a/tests-custom/src/main/java/org/openjdk/jcstress/tests/unsafe/UnsafePublication.java" target="_blank" rel="noopener">http://hg.openjdk.java.net/code-tools/jcstress/file/64f2cf32fa0a/tests-custom/src/main/java/org/openjdk/jcstress/tests/unsafe/UnsafePublication.java</a></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有点深，以后反过来看，暂时放置</p>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11-12垃圾回收</title>
      <link href="/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/11-12%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/11-12%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="引用计数法和可达性分析"><a href="#引用计数法和可达性分析" class="headerlink" title="引用计数法和可达性分析"></a>引用计数法和可达性分析</h1><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>循环引用的问题</p><h2 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h2><ul><li>方法栈桢中的局部变量</li><li>已加载类的静态变量</li><li>JNI handles</li><li>已启动未停止的java线程</li></ul><a id="more"></a><h1 id="stop-the-world-以及安全点"><a href="#stop-the-world-以及安全点" class="headerlink" title="stop-the-world 以及安全点"></a>stop-the-world 以及安全点</h1><ul><li>stop-the-world ，停止其他非垃圾回收线程，直到完成垃圾回收。</li><li>安全点并不是让线程停下来，而是到达一个稳定的状态（堆栈不发生变化）</li><li>对于解释执行，字节码和字节码都是安全点。java虚拟机的做法是，当有安全点的请求是，执行一条字节码进行一次安全点检查</li><li>对于直接运行的机器码，在及时编译时插入安全安全检测点。通常在方法的出口，以及非技术循环的循环回边插入安全检测点</li></ul><h1 id="垃圾回收的三种方式"><a href="#垃圾回收的三种方式" class="headerlink" title="垃圾回收的三种方式"></a>垃圾回收的三种方式</h1><h2 id="清除"><a href="#清除" class="headerlink" title="清除"></a>清除</h2><ul><li>内存碎片</li><li>分配效率低</li></ul><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><ul><li>性能开销较大</li></ul><h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><ul><li>使用率低下</li></ul><h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafePointTest</span> &#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// time java SafepointTestp</span></span><br><span class="line"><span class="comment">/// 你还可以使用如下几个选项</span></span><br><span class="line">  <span class="comment">// -XX:+PrintGC</span></span><br><span class="line"><span class="comment">// -XX:+PrintGCApplicationStoppedTime</span></span><br><span class="line"><span class="comment">// -XX:+PrintSafepointStatistics</span></span><br><span class="line"><span class="comment">// -XX:+UseCountedLoopSafepoints</span></span><br><span class="line"><span class="comment">//  public class SafepointTest &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x77777777</span>; i++) &#123;</span><br><span class="line">        sum += Math.<span class="built_in">sqrt</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>_000_000; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Object().hashCode();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Runnable foo = SafePointTest::foo;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">new</span> Thread(foo).start();</span><br><span class="line">      <span class="keyword">new</span> Thread(SafePointTest::bar).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><h1 id="虚拟机推划分"><a href="#虚拟机推划分" class="headerlink" title="虚拟机推划分"></a>虚拟机推划分</h1><ul><li>TLAB(Thread Local Allocation Buffer)</li></ul><h1 id="卡表"><a href="#卡表" class="headerlink" title="卡表"></a>卡表</h1><ul><li>推分为512Byte的卡，通过卡表定位卡</li><li>截获字节码的写操作容易</li><li>截获机器码的写操作不容器，采取宁可错杀一万不肯放过一个的策略</li></ul><h1 id="GC日志"><a href="#GC日志" class="headerlink" title="GC日志"></a>GC日志</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-01-05T22:21:02.445+0800: [GC (Allocation Failure) [PSYoungGen: 76800K-&gt;12792K(89600K)] 76800K-&gt;35744K(113664K), 0.0438584 secs][Times: user=0.03 sys=0.05, real=0.04 secs] </span><br><span class="line">2019-01-05T22:21:02.489+0800: [Full GC (Ergonomics) [PSYoungGen: 12792K-&gt;12767K(89600K)] [ParOldGen: 22952K-&gt;22745K(86016K)] 35744K-&gt;35512K(175616K), [Metaspace: 3457K-&gt;3457K(1056768K)], 0.2233472 secs][Times: user=0.19 sys=0.00, real=0.22 secs]</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> PSYoungGen      total <span class="number">69120</span>K, used <span class="number">67955</span>K [<span class="number">0x00000000f9c00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space <span class="number">35840</span>K, <span class="number">97</span>% used [<span class="number">0x00000000f9c00000</span>,<span class="number">0x00000000fbe3cd10</span>,<span class="number">0x00000000fbf00000</span>)</span><br><span class="line">  <span class="keyword">from</span> space <span class="number">33280</span>K, <span class="number">98</span>% used [<span class="number">0x00000000fbf00000</span>,<span class="number">0x00000000fdf20000</span>,<span class="number">0x00000000fdf80000</span>)</span><br><span class="line">  to   space <span class="number">33280</span>K, <span class="number">0</span>% used [<span class="number">0x00000000fdf80000</span>,<span class="number">0x00000000fdf80000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line"> ParOldGen       total <span class="number">123904</span>K, used <span class="number">99900</span>K [<span class="number">0x0000000087400000</span>, <span class="number">0x000000008ed00000</span>, <span class="number">0x00000000f9c00000</span>)</span><br><span class="line">  object space <span class="number">123904</span>K, <span class="number">80</span>% used [<span class="number">0x0000000087400000</span>,<span class="number">0x000000008d58f1d8</span>,<span class="number">0x000000008ed00000</span>)</span><br><span class="line"> Metaspace       used <span class="number">9344</span>K, capacity <span class="number">9658</span>K, committed <span class="number">9984</span>K, reserved <span class="number">1058816</span>K</span><br><span class="line">  <span class="keyword">class</span> <span class="symbol">space</span>    <span class="symbol">used</span> <span class="symbol">1086K, <span class="symbol">capacity</span></span> <span class="symbol">1160K, <span class="symbol">committed</span></span> <span class="symbol">1280K, <span class="symbol">reserved</span></span> <span class="symbol">1048576K</span></span><br></pre></td></tr></table></figure><h1 id="VM-Options"><a href="#VM-Options" class="headerlink" title="VM Options"></a>VM Options</h1><ul><li><p>-XX:+PrintGC  打印GC日志</p></li><li><p>-XX:+PrintGCApplicationStoppedTime </p></li><li><p>-XX:+PrintSafepointStatistics</p></li><li><p>-XX:+UseCountedLoopSafepoints</p></li><li><p>XX:+UsePSAdaptiveSurvivorSizePolicy</p></li><li><p>-XX:SurvivorRatio</p></li><li><p>-XX:+UseTLAB</p></li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li><a href="http://psy-lob-saw.blogspot.com/2015/12/safepoints.html" target="_blank" rel="noopener">http://psy-lob-saw.blogspot.com/2015/12/safepoints.html</a></li><li><a href="http://openjdk.java.net/jeps/122" target="_blank" rel="noopener">http://openjdk.java.net/jeps/122</a></li><li><a href="http://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html" target="_blank" rel="noopener">http://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html</a></li><li><a href="https://blogs.oracle.com/dave/false-sharing-induced-by-card-table-marking" target="_blank" rel="noopener">https://blogs.oracle.com/dave/false-sharing-induced-by-card-table-marking</a></li><li><a href="http://openjdk.java.net/jeps/291" target="_blank" rel="noopener">http://openjdk.java.net/jeps/291</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10Java对象的内存布局</title>
      <link href="/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/10Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"/>
      <url>/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/10Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><ul><li><p>对象头</p></li><li><ul><li>存储对象自身的运行时数据，Mark Word</li><li>类型指针，对象指向类元数据的指针（32bit–&gt;32bit，64bit–&gt;64bit(未开启压缩指针)，32bit(开启压缩指针)），JVM通过这个指针来确定这个对象是哪个类的实例（根据对象确定其Class的指针）</li></ul></li><li><p>实例数据，对象真正存储的有效信息</p></li><li><p>对齐填充，JVM要求对象的大小必须是8的整数倍，若不是，需要补位对齐</p></li></ul><a id="more"></a><h1 id="初始化方式"><a href="#初始化方式" class="headerlink" title="初始化方式"></a>初始化方式</h1><ul><li>new，新建对象覆盖了所有父类的实例字段，虽然无法直接访问父类的私有字段，但是可以覆盖父类的私有字段，也可以为父类分配内存</li><li>反射机制</li><li>Oject.clone</li><li>反序列化</li></ul><h1 id="压缩指针"><a href="#压缩指针" class="headerlink" title="压缩指针"></a>压缩指针</h1><ul><li>-XX:+UseCompressedOops   将堆中原本 64 位的 Java 对象指针压缩成 32 位的，对象头中的类型指针也会被压缩成 32 位,作用于引用类型的字段,引用类型数组。</li><li>对象头包含类型指针和标记字段</li><li>字段填充让字段只出现在同一CPU缓存行</li><li>64位虚拟中，对象头又16位字节转变成12位，只转变类型指针</li><li>默认情况下，Java 虚拟机堆中对象的起始地址需要对齐至 8 的倍数。如果一个对象用不到 8N 个字节，那么空白的那部分空间就浪费掉了。这些浪费掉的空间我们称之为对象间的填充（padding）。</li></ul><h1 id="字段重排列"><a href="#字段重排列" class="headerlink" title="字段重排列"></a>字段重排列</h1><ul><li>如果一个字段占据C字节，那么该字段的偏移量需要对齐至NC</li><li>子类继承的偏移量需要和父类对应字段的偏移量保持一致</li><li>Contended 解决虚共享问题</li></ul><h1 id="JOL"><a href="#JOL" class="headerlink" title="JOL"></a>JOL</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li><a href="https://wiki.openjdk.java.net/display/HotSpot/CompressedOops" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/HotSpot/CompressedOops</a></li><li><a href="http://openjdk.java.net/jeps/142" target="_blank" rel="noopener">http://openjdk.java.net/jeps/142</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>08-09JVM是怎么实现invokedynamic的</title>
      <link href="/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/08-09JVM%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0invokedynamic%E7%9A%84/"/>
      <url>/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/08-09JVM%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0invokedynamic%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="方法句柄的概念"><a href="#方法句柄的概念" class="headerlink" title="方法句柄的概念"></a>方法句柄的概念</h1><ul><li>方法句柄的权限取决于Lookup对象的创建位置</li><li>方法句柄的类型（MethodType）是由所指向方法的参数类型以及返回类型组成的</li></ul><a id="more"></a><h1 id="方法句柄的操作"><a href="#方法句柄的操作" class="headerlink" title="方法句柄的操作"></a>方法句柄的操作</h1><ul><li>PolymorphicSignature</li></ul><h1 id="方法句柄的实现"><a href="#方法句柄的实现" class="headerlink" title="方法句柄的实现"></a>方法句柄的实现</h1><ul><li>-XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames 这个参数来打印被 Java 虚拟机隐藏了的栈信息</li></ul><h1 id="CallSite"><a href="#CallSite" class="headerlink" title="CallSite"></a>CallSite</h1><ul><li>ConstantCallSite</li><li>MethodVisitor</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>  和工作相关性比较大，暂时可以不关注</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://en.wikipedia.org/wiki/Duck_typing" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Duck_typing</a></li><li><a href="https://docs.oracle.com/javase/10/docs/api/java/lang/invoke/MethodHandle.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/10/docs/api/java/lang/invoke/MethodHandle.html</a></li><li><a href="https://en.wikipedia.org/wiki/Currying" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Currying</a></li><li><a href="http://openjdk.java.net/jeps/303" target="_blank" rel="noopener">http://openjdk.java.net/jeps/303</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07JVM是如何实现反射的</title>
      <link href="/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/07JVM%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%B0%84%E7%9A%84/"/>
      <url>/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/07JVM%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%B0%84%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="反射调用的实现"><a href="#反射调用的实现" class="headerlink" title="反射调用的实现"></a>反射调用的实现</h1><ul><li>-Dsun.reflect.inflationThreshold 设置本地调用的阀值</li><li>-verbose:class</li><li>-XX:+PrintGC 打印GC</li><li>在实践中需要保存反射得到的结果</li></ul><a id="more"></a><h1 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">target</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Exception(<span class="string">"#"</span> + i).printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class&lt;?&gt; klass = Class.forName(<span class="string">"reflect.Test"</span>);</span><br><span class="line">    Method method = klass.getMethod(<span class="string">"target"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">    method.invoke(<span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">target:22, Test (reflect)</span><br><span class="line">invoke0(Method, Object, Object[]):-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke(Object, Object[]):62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke(Object, Object[]):43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke(Object, Object[]):498, Method (java.lang.reflect)</span><br><span class="line">main(String[]):28, Test (reflect)</span><br></pre></td></tr></table></figure><p>这里你可能会疑问，为什么反射调用还要采取委派实现作为中间层？直接交给本地实现不可以么？</p><p>其实，Java 的反射调用机制还设立了另一种动态生成字节码的实现（下称动态实现），直接使用 invoke 指令来调用目标方法。之所以采用委派实现，便是为了能够在本地实现以及动态实现中切换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态实现的伪代码，这里只列举了关键的调用逻辑，其实它还包括调用者检测、参数检测的字节码。</span></span><br><span class="line"><span class="keyword">package</span> jdk.internal.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneratedMethodAccessor1</span> <span class="keyword">extends</span> ... </span>&#123;</span><br><span class="line">  <span class="meta">@Overrides</span>    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span> <span class="keyword">throws</span> ... </span>&#123;</span><br><span class="line">    Test.target((<span class="keyword">int</span>) args[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="反射调用的开销"><a href="#反射调用的开销" class="headerlink" title="反射调用的开销"></a>反射调用的开销</h1><ul><li>变长参数Object数组</li><li>自动装箱</li></ul><h2 id="getMethod"><a href="#getMethod" class="headerlink" title="getMethod"></a>getMethod</h2><ul><li><p>Class.getMethod 则会遍历该类的公有方法。如果没有匹配到，它还将遍历父类的公有方法。可想而知，这两个操作都非常费时。</p></li><li><p>以 getMethod 为代表的查找方法操作，会返回查找得到结果的一份拷贝。因此，我们应当避免在热点代码中使用返回 Method 数组的 getMethods 或者 getDeclaredMethods 方法，以减少不必要的堆空间消耗。</p></li></ul><h2 id="demo2"><a href="#demo2" class="headerlink" title="demo2"></a>demo2</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">target</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空方法</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class&lt;?&gt; klass = Class.forName(<span class="string">"reflect.Test2"</span>);</span><br><span class="line">    Method method = klass.getMethod(<span class="string">"target"</span>, <span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> current = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2_000_000_000</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i % <span class="number">100_000_000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> temp = System.currentTimeMillis();</span><br><span class="line">        System.out.println(temp - current);</span><br><span class="line">        current = temp;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      method.invoke(<span class="keyword">null</span>, <span class="number">128</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">59: aload_2                         // 加载 Method 对象</span><br><span class="line">  60: aconst_null                     // 反射调用的第一个参数 null</span><br><span class="line">  61: iconst_1</span><br><span class="line">  62: anewarray Object                // 生成一个长度为 1 的 Object 数组</span><br><span class="line">  65: dup</span><br><span class="line">  66: iconst_0</span><br><span class="line">  67: sipush 128</span><br><span class="line">  70: invokestatic Integer.valueOf    // 将 128 自动装箱成 Integer</span><br><span class="line">  73: aastore                         // 存入 Object 数组中</span><br><span class="line">  74: invokevirtual Method.invoke     // 反射调用</span><br></pre></td></tr></table></figure><ul><li>由于 Method.invoke 是一个变长参数方法，在字节码层面它的最后一个参数会是 Object 数组（感兴趣的同学私下可以用 javap 查看）。Java 编译器会在方法调用处生成一个长度为传入参数数量的 Object 数组，并将传入参数一一存储进该数组中。</li><li>由于 Object 数组不能存储基本类型，Java 编译器会对传入的基本类型参数进行自动装箱。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://docs.oracle.com/javase/tutorial/reflect/" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/reflect/</a></li><li><a href="http://hg.openjdk.java.net/jdk10/jdk10/jdk/file/777356696811/src/java.base/share/classes/jdk/internal/reflect/ReflectionFactory.java#l80" target="_blank" rel="noopener">http://hg.openjdk.java.net/jdk10/jdk10/jdk/file/777356696811/src/java.base/share/classes/jdk/internal/reflect/ReflectionFactory.java#l80</a></li><li><a href="http://hg.openjdk.java.net/jdk10/jdk10/jdk/file/777356696811/src/java.base/share/classes/jdk/internal/reflect/ReflectionFactory.java#l78" target="_blank" rel="noopener">http://hg.openjdk.java.net/jdk10/jdk10/jdk/file/777356696811/src/java.base/share/classes/jdk/internal/reflect/ReflectionFactory.java#l78</a></li><li><a href="https://docs.oracle.com/javase/tutorial/reflect/class/classMembers.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/reflect/class/classMembers.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06JVM是如何处理异常的</title>
      <link href="/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/06JVM%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E7%9A%84/"/>
      <url>/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/06JVM%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="异常的基本概念"><a href="#异常的基本概念" class="headerlink" title="异常的基本概念"></a>异常的基本概念</h1><p><img src="http://liyong.ac.cn/pic/1546248609299.png" alt="1546248609299"></p><a id="more"></a><h1 id="Java-虚拟机是如何捕获异常的"><a href="#Java-虚拟机是如何捕获异常的" class="headerlink" title="Java 虚拟机是如何捕获异常的"></a>Java 虚拟机是如何捕获异常的</h1><ul><li><p>当程序触发异常时，Java 虚拟机会从上至下遍历异常表中的所有条目。当触发异常的字节码的索引值在某个异常表条目的监控范围内，Java 虚拟机会判断所抛出的异常和该条目想要捕获的异常是否匹配。如果匹配，Java 虚拟机会将控制流转移至该条目 target 指针指向的字节码。</p></li><li><p>finally，复制finally代码块的内容，分别放置try-catch 代码块中所有正常以及异常路径的出口处</p></li></ul><p><img src="http://liyong.ac.cn/pic/1546250668869.png" alt="1546250668869"></p><h1 id="Java-7-的-Supressed-异常以及语法糖"><a href="#Java-7-的-Supressed-异常以及语法糖" class="headerlink" title="Java 7 的 Supressed 异常以及语法糖"></a>Java 7 的 Supressed 异常以及语法糖</h1><ul><li>try-with-resources</li></ul>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04-05JVM是如何执行方法调用的</title>
      <link href="/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/04-05JVM%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84/"/>
      <url>/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/04-05JVM%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h1><h2 id="选取过程"><a href="#选取过程" class="headerlink" title="选取过程"></a>选取过程</h2><ol><li>不考虑自动拆装箱，不考虑变长参数的情况，选择重载方法</li><li>如果在第1阶段没有找到重载方法，运行自动拆装箱，不考虑变长参数的情况，选择重载方法</li><li>如果在第2个阶段没有找到重载方法，考虑变长参数<a id="more"></a></li></ol><h2 id="选取原则"><a href="#选取原则" class="headerlink" title="选取原则"></a>选取原则</h2><ul><li>选择最为贴切的方法，贴切由参数类型的继承关系</li></ul><h2 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h2><p>如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型相同，那么这两个方法之间又是什么关系呢？</p><p>如果是静态方法，子类隐藏父类的方法。如果不是静态子类重写了父类中的方法</p><h1 id="JVM静态绑定和动态绑定"><a href="#JVM静态绑定和动态绑定" class="headerlink" title="JVM静态绑定和动态绑定"></a>JVM静态绑定和动态绑定</h1><ol><li>静态绑定编译期间可以确定执行的方法</li><li>动态绑定执行期间才可以确定执行的方法</li><li>重写属于动态绑定</li><li>重载属于静态绑定</li></ol><ul><li>invokestatic,用于调用静态方法</li><li>invokespeccial,调用私有方法、构造器、super关键字调用的父类实例或构造方法，和接口的默认方法</li><li>invokevirtual,调用实例非私有方法</li><li>invokeinterface,调用接口</li><li>invokedynamic,调用动态方法</li><li>invokestatic 、invokespecial ，Java 虚拟机能够直接识别具体的目标方法。</li><li>invokevirtual 、invokeinterface，虚拟机需要在执行过程中，根据调用者的动态类型，来确定具体的目标方法。</li></ul><h1 id="调用指令的符号引用"><a href="#调用指令的符号引用" class="headerlink" title="调用指令的符号引用"></a>调用指令的符号引用</h1><ul><li>javap -v  打印某个类的常量池</li></ul><h2 id="非接口符号引用"><a href="#非接口符号引用" class="headerlink" title="非接口符号引用"></a>非接口符号引用</h2><ul><li>在C中查找符合名字及描述符的方法</li><li>如果没有找到在C的父类中寻找，直至Object</li><li>如果没有找到，在C所有直接或间接实现的接口中查找</li></ul><h2 id="接口符号引用"><a href="#接口符号引用" class="headerlink" title="接口符号引用"></a>接口符号引用</h2><ul><li>在I中查找符合名字及描述符的方法</li><li>如果没有找到，在Objet类的公有实例方法中搜索</li><li>如果没有找到，在I的超接口中搜索</li></ul><h2 id="虚方法调用"><a href="#虚方法调用" class="headerlink" title="虚方法调用"></a>虚方法调用</h2><ul><li>invokestatic 、invokespecial </li></ul><h2 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h2><ul><li>子类方法表包含父类方法表中的所有方法</li><li>同一方法在子类和父类的方法表中的下标相同</li><li>访问栈上的调用者，读取调用者的动态类型，读取该类型的方法表，读取方法表中某个索引对应的方法</li></ul><h2 id="内联缓存"><a href="#内联缓存" class="headerlink" title="内联缓存"></a>内联缓存</h2><ul><li>单态</li><li>多态</li><li>超多态</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/language/varargs.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/language/varargs.html</a></li><li><a href="https://docs.oracle.com/javase/tutorial/java/generics/bridgeMethods.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/java/generics/bridgeMethods.html</a></li><li><a href="https://wiki.openjdk.java.net/display/HotSpot/VirtualCalls" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/HotSpot/VirtualCalls</a></li><li><a href="https://wiki.openjdk.java.net/display/HotSpot/InterfaceCalls" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/HotSpot/InterfaceCalls</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03Java虚拟机是如何加载Java类的</title>
      <link href="/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/03Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BDJava%E7%B1%BB%E7%9A%84/"/>
      <url>/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/03Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BDJava%E7%B1%BB%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h2 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h2><ul><li>对calss文件加密，使用classloader对其解密</li><li>类的唯一性是有类加载器和类的全名一起确定的</li><li>-verbose:class 可以查看加载过程<a id="more"></a></li></ul><h1 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h1><ul><li>查找字节流，并根据此创建类的过程</li><li>双亲委托加载机制</li></ul><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><ul><li>验证加载的类是否满足Java虚拟机约束条件</li></ul><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>静态字段准备内存</li><li>构造跟类层次相关的数据结构（符号引用）</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li>符号引用解析成实际引用</li></ul><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><ul><li>如果字段被final修饰，且是基本类型或字符串，会标记为常量，初始化由Java虚拟机完成。除此之外的赋值操作，以及静态代码块中的代码，则会被编译器置于方法<clinit></clinit></li><li>执行clinit方法的时候通过加锁确保只被执行一次</li></ul><h2 id="类的初始化触发时机"><a href="#类的初始化触发时机" class="headerlink" title="类的初始化触发时机"></a>类的初始化触发时机</h2><ol><li>用户指定的主类</li><li>引用静态字段,初始化字段所在的类</li><li>引用静态方法,初始化方法所在的类</li><li>new 指定的目标类</li><li>通过反射调用某个类,初始化这个类</li><li>子类的初始化会触发父类的初始化</li><li>接口定义了default方法,那么直接实现或者间接实现该接口的类的初始化,会初始化接口的初始化</li><li>当初次调用MethodHandle实例是,初始化MethodHandle指向的类</li></ol><h2 id="反例说明"><a href="#反例说明" class="headerlink" title="反例说明"></a>反例说明</h2><p> import 某类,不会触发该类的初始化</p>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02Java的基本类型</title>
      <link href="/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/02Java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/02Java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<ul><li>ifeq succeeds if and only if value = 0</li><li>ifne succeeds if and only if value ≠ 0</li><li>ifle succeeds if and only if value ≤ 0</li><li>ifgt succeeds if and only if value &gt; 0</li><li>ifge succeeds if and only if value ≥ 0 <a id="more"></a>   </li></ul>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01Java代码是怎么运行的</title>
      <link href="/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/01Java%E4%BB%A3%E7%A0%81%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84/"/>
      <url>/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/01Java%E4%BB%A3%E7%A0%81%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h1><p>从虚拟机视角来看，执行 Java 代码首先需要将它编译而成的 class 文件加载到 Java 虚拟机中。加载后的 Java 类会被存放于方法区（Method Area）中。实际运行时，虚拟机会执行方法区内的代码。</p><p>在运行过程中，每当调用进入一个 Java 方法，Java 虚拟机会在当前线程的 Java 方法栈中生成一个栈帧，用以存放局部变量以及字节码的操作数。这个栈帧的大小是提前计算好的，而且 Java 虚拟机不要求栈帧在内存空间里连续分布。</p><h1 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h1><p>从硬件视角来看，Java 字节码无法直接执行。因此，Java 虚拟机需要将字节码翻译成机器码。</p><a id="more"></a><h2 id="HotSpot"><a href="#HotSpot" class="headerlink" title="HotSpot"></a>HotSpot</h2><p>在 HotSpot 里面，上述翻译过程有两种形式：第一种是解释执行，即逐条将字节码翻译成机器码并执行；第二种是即时编译（Just-In-Time compilation，JIT），即将一个方法中包含的所有字节码编译成机器码后再执行。</p><p>前者的优势在于无需等待编译，而后者的优势在于实际运行速度更快。HotSpot 默认采用混合模式，综合了解释执行和即时编译两者的优点。它会先解释执行字节码，而后将其中反复执行的热点代码，以方法为单位进行即时编译。</p>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12为什么我的MySQL会“抖”一下</title>
      <link href="/2019/03/11/aa_category/db/mysql/mysql%E5%AE%9E%E6%88%98/12%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84MySQL%E4%BC%9A%E2%80%9C%E6%8A%96%E2%80%9D%E4%B8%80%E4%B8%8B/"/>
      <url>/2019/03/11/aa_category/db/mysql/mysql%E5%AE%9E%E6%88%98/12%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84MySQL%E4%BC%9A%E2%80%9C%E6%8A%96%E2%80%9D%E4%B8%80%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<p>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”</p><a id="more"></a><h1 id="那么，什么情况会引发数据库的-flush-过程呢？"><a href="#那么，什么情况会引发数据库的-flush-过程呢？" class="headerlink" title="那么，什么情况会引发数据库的 flush 过程呢？"></a>那么，什么情况会引发数据库的 flush 过程呢？</h1><ul><li>粉板（redo log）满了，记不下了。</li><li>对应的就是系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。</li><li>MySQL 认为系统“空闲”的时候</li><li>MySQL 正常关闭的情况 </li></ul><h2 id="内存不够用了"><a href="#内存不够用了" class="headerlink" title="内存不够用了"></a>内存不够用了</h2><p>内存不够用了要先将脏页写到磁盘”，这种情况其实是常态。InnoDB 用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态：</p><ul><li>还没有使用的；</li><li>使用了并且是干净页；</li><li>使用了并且是脏页。</li></ul><p>刷脏页虽然是常态，但是出现以情况，都是会明显影响性能的：一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；</p><h1 id="InnoDB-刷脏页的控制策略"><a href="#InnoDB-刷脏页的控制策略" class="headerlink" title="InnoDB 刷脏页的控制策略"></a>InnoDB 刷脏页的控制策略</h1><p>这就要用到 innodb_io_capacity 这个参数了，它会告诉 InnoDB 你的磁盘能力。这个值我建议你设置成磁盘的 IOPS。磁盘的 IOPS 可以通过 fio 这个工具来测试，下面的语句是我用来测试磁盘随机读写的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio -filename=<span class="variable">$filename</span> -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest</span><br></pre></td></tr></table></figure><p>一旦一个查询请求需要在执行过程中先 flush 掉一个脏页时，这个查询就可能要比平时慢了。在准备刷一个脏页的时候，如果这个数据页旁边的数据页刚好是脏页，就会把这个“邻居”也带着一起刷掉；而且这个把“邻居”拖下水的逻辑还可以继续蔓延，也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷。</p><p>在 InnoDB 中，innodb_flush_neighbors 参数就是用来控制这个行为的，值为 1 的时候会有上述的“连坐”机制，值为 0 时表示不找邻居，自己刷自己的。</p>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> db </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1一条SQL查询语句是如何执行的</title>
      <link href="/2019/03/11/aa_category/db/mysql/mysql%E5%AE%9E%E6%88%98/1%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/"/>
      <url>/2019/03/11/aa_category/db/mysql/mysql%E5%AE%9E%E6%88%98/1%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="summarize"><a href="#summarize" class="headerlink" title="summarize"></a>summarize</h1><p><img src="http://liyong.ac.cn/pic/1546866826086.png" alt="1546866826086"></p><ul><li>server层包括连接器、查询缓存、分析器、优化器、执行器以及所有的内置函数（如日期、时间、数学函数）</li></ul><a id="more"></a><h1 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h1><ul><li><p>修改用户权限，不影响已经建立的连接</p></li><li><p>show processlist 查看连接的客户端</p></li><li><p>wait_timeout  默认值  8</p></li><li><p>建立连接比较麻烦，建议使用长连接</p></li></ul><h1 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h1><ul><li><p>query_cache_type  设置成DEMAND</p></li><li><p>select SQL_CACHE * from T where ID=10     使用SQL_CACHE 显示的使用缓存</p></li></ul><h1 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h1><ul><li>词法分析</li><li>语法分析</li></ul><h1 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h1><ul><li>决定索引</li><li>决定各个表的连接顺序</li></ul><h1 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> <span class="keyword">ID</span>=<span class="number">10</span>;</span><br></pre></td></tr></table></figure><ol><li>取这个表的第一行判断ID值是否等于10，如果不是则跳过，如果是则将结果保存到结果中</li><li>取下一行，重复相同的逻辑判断，直至最后一行</li><li>将满足条件的记录返回给客户端</li></ol>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> db </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11怎么给字符串字段加索引</title>
      <link href="/2019/03/11/aa_category/db/mysql/mysql%E5%AE%9E%E6%88%98/11%E6%80%8E%E4%B9%88%E7%BB%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E6%AE%B5%E5%8A%A0%E7%B4%A2%E5%BC%95/"/>
      <url>/2019/03/11/aa_category/db/mysql/mysql%E5%AE%9E%E6%88%98/11%E6%80%8E%E4%B9%88%E7%BB%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E6%AE%B5%E5%8A%A0%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">create</span> <span class="keyword">table</span> SUser(</span><br><span class="line"><span class="keyword">ID</span> <span class="built_in">bigint</span> <span class="keyword">unsigned</span> primary <span class="keyword">key</span>,</span><br><span class="line">email <span class="built_in">varchar</span>(<span class="number">64</span>) </span><br><span class="line">) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> SUser <span class="keyword">add</span> <span class="keyword">index</span> index1(email);</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> SUser <span class="keyword">add</span> <span class="keyword">index</span> index2(email(<span class="number">6</span>));</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="http://liyong.ac.cn/pic/5C1550487077103.png" alt="1550487077103"></p><p><img src="http://liyong.ac.cn/pic/C1550487095185.png" alt="1550487095185"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span>,email <span class="keyword">from</span> SUser <span class="keyword">where</span> email=<span class="string">'zhangssxyz@xxx.com'</span></span><br></pre></td></tr></table></figure><ul><li>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本</li><li>select count(distinct email) as L from SUser;</li><li>使用前缀索引就用不上覆盖索引对查询性能的优化了</li></ul>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> db </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7行锁功过：怎么减少行锁对性能的影响</title>
      <link href="/2019/03/11/aa_category/db/mysql/mysql%E5%AE%9E%E6%88%98/7%E8%A1%8C%E9%94%81%E5%8A%9F%E8%BF%87%EF%BC%9A%E6%80%8E%E4%B9%88%E5%87%8F%E5%B0%91%E8%A1%8C%E9%94%81%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
      <url>/2019/03/11/aa_category/db/mysql/mysql%E5%AE%9E%E6%88%98/7%E8%A1%8C%E9%94%81%E5%8A%9F%E8%BF%87%EF%BC%9A%E6%80%8E%E4%B9%88%E5%87%8F%E5%B0%91%E8%A1%8C%E9%94%81%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
      
        <content type="html"><![CDATA[<p>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。 </p><a id="more"></a><h1 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h1><p><img src="http://liyong.ac.cn/pic/C1550279844179.png" alt="1550279844179"></p><h2 id="解决死锁的策略"><a href="#解决死锁的策略" class="headerlink" title="解决死锁的策略"></a>解决死锁的策略</h2><ul><li>直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置</li><li>发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。</li></ul>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> db </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13为什么表数据删掉一半,表文件大小不变</title>
      <link href="/2019/03/11/aa_category/db/mysql/mysql%E5%AE%9E%E6%88%98/13%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%88%A0%E6%8E%89%E4%B8%80%E5%8D%8A,%E8%A1%A8%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E4%B8%8D%E5%8F%98/"/>
      <url>/2019/03/11/aa_category/db/mysql/mysql%E5%AE%9E%E6%88%98/13%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%88%A0%E6%8E%89%E4%B8%80%E5%8D%8A,%E8%A1%A8%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E4%B8%8D%E5%8F%98/</url>
      
        <content type="html"><![CDATA[<h1 id="innodb-file-per-table"><a href="#innodb-file-per-table" class="headerlink" title="innodb_file_per_table"></a>innodb_file_per_table</h1><ul><li>这个参数设置为 OFF 表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；</li><li>这个参数设置为 ON 表示的是，每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文件中。</li></ul><a id="more"></a><h1 id="数据删除流程"><a href="#数据删除流程" class="headerlink" title="数据删除流程"></a>数据删除流程</h1><p><img src="http://liyong.ac.cn/pic/5C1551926495798.png" alt="1551926495798"></p><h1 id="不止是删除数据会造成空洞，插入数据也会"><a href="#不止是删除数据会造成空洞，插入数据也会" class="headerlink" title="不止是删除数据会造成空洞，插入数据也会"></a>不止是删除数据会造成空洞，插入数据也会</h1><p><img src="http://liyong.ac.cn/pic/5C1551926834063.png" alt="1551926834063"></p><p>另外，更新索引上的值，可以理解为删除一个旧的值，再插入一个新值。不难理解，这也是会造成空洞的。</p>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> db </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper入门</title>
      <link href="/2019/03/11/aa_category/middleware/zookeeper/zookeeper%E5%85%A5%E9%97%A8/"/>
      <url>/2019/03/11/aa_category/middleware/zookeeper/zookeeper%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="EventType"><a href="#EventType" class="headerlink" title="EventType"></a>EventType</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">None (<span class="number">-1</span>),</span><br><span class="line">NodeCreated (<span class="number">1</span>),</span><br><span class="line">NodeDeleted (<span class="number">2</span>),</span><br><span class="line">NodeDataChanged (<span class="number">3</span>),</span><br><span class="line">NodeChildrenChanged (<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h2 id="KeeperState"><a href="#KeeperState" class="headerlink" title="KeeperState"></a>KeeperState</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 失去连接</span></span><br><span class="line">Disconnected (<span class="number">0</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步连接</span></span><br><span class="line">SyncConnected (<span class="number">3</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验失败</span></span><br><span class="line">AuthFailed (<span class="number">4</span>),</span><br><span class="line"><span class="comment">// 只读连接</span></span><br><span class="line">ConnectedReadOnly (<span class="number">5</span>),</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">SaslAuthenticated(<span class="number">6</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment">// 失效</span></span><br><span class="line">Expired (<span class="number">-112</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> middleware </category>
          
      </categories>
      
      
        <tags>
            
            <tag> middleware </tag>
            
            <tag> zk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zk使用场景</title>
      <link href="/2019/03/11/aa_category/middleware/zookeeper/zk%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2019/03/11/aa_category/middleware/zookeeper/zk%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<ul><li>分布式协调</li><li>分布式锁</li><li>配置信息管理</li><li>HA高可用</li></ul><a id="more"></a><h1 id="分布式协调"><a href="#分布式协调" class="headerlink" title="分布式协调"></a>分布式协调</h1>]]></content>
      
      
      <categories>
          
          <category> middleware </category>
          
      </categories>
      
      
        <tags>
            
            <tag> middleware </tag>
            
            <tag> zk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10MySQL为什么有时候会选错索引</title>
      <link href="/2019/03/11/aa_category/db/mysql/mysql%E5%AE%9E%E6%88%98/10MySQL%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E5%80%99%E4%BC%9A%E9%80%89%E9%94%99%E7%B4%A2%E5%BC%95/"/>
      <url>/2019/03/11/aa_category/db/mysql/mysql%E5%AE%9E%E6%88%98/10MySQL%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E5%80%99%E4%BC%9A%E9%80%89%E9%94%99%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> long_query_time=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>; <span class="comment">/*Q1*/</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">force</span> <span class="keyword">index</span>(a) <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>;<span class="comment">/*Q2*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> t;</span><br></pre></td></tr></table></figure><ul><li>对于由于索引统计信息不准确导致的问题用 analyze table 来解决</li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> db </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6全局锁和表锁 ：给表加个字段怎么有这么多阻碍</title>
      <link href="/2019/03/11/aa_category/db/mysql/mysql%E5%AE%9E%E6%88%98/6%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81%20%EF%BC%9A%E7%BB%99%E8%A1%A8%E5%8A%A0%E4%B8%AA%E5%AD%97%E6%AE%B5%E6%80%8E%E4%B9%88%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E9%98%BB%E7%A2%8D/"/>
      <url>/2019/03/11/aa_category/db/mysql/mysql%E5%AE%9E%E6%88%98/6%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81%20%EF%BC%9A%E7%BB%99%E8%A1%A8%E5%8A%A0%E4%B8%AA%E5%AD%97%E6%AE%B5%E6%80%8E%E4%B9%88%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E9%98%BB%E7%A2%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h1><ul><li>加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</li><li>全局锁的典型使用场景是，做全库逻辑备份</li><li>single-transaction 方法只适用于所有的表使用事务引擎的库</li></ul><a id="more"></a><h1 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h1><ul><li>MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)</li><li>表锁的语法是 lock tables … read/write<!-- more --></li></ul><h2 id="另一类表级的锁是-MDL（metadata-lock"><a href="#另一类表级的锁是-MDL（metadata-lock" class="headerlink" title="另一类表级的锁是 MDL（metadata lock)"></a>另一类表级的锁是 MDL（metadata lock)</h2><ul><li>MDL 不需要显式使用，在访问一个表的时候会被自动加上</li><li>MDL 的作用是，保证读写的正确性</li><li>当对一个表做增删改查操作的时候，加 MDL 读锁</li><li>当要对表做结构变更操作的时候，加 MDL 写锁。</li></ul><p><img src="http://liyong.ac.cn/pic/5C1550225203730.png" alt="1550225203730"></p><h1 id="上期问题"><a href="#上期问题" class="headerlink" title="上期问题"></a>上期问题</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`geek`</span> (</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`a`</span>,<span class="string">`b`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`ca`</span> (<span class="string">`c`</span>,<span class="string">`a`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`cb`</span> (<span class="string">`c`</span>,<span class="string">`b`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> db </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5深入浅出索引</title>
      <link href="/2019/03/11/aa_category/db/mysql/mysql%E5%AE%9E%E6%88%98/5%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95/"/>
      <url>/2019/03/11/aa_category/db/mysql/mysql%E5%AE%9E%E6%88%98/5%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T (</span><br><span class="line"><span class="keyword">ID</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">k <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>, </span><br><span class="line">s <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line"><span class="keyword">index</span> k(k))</span><br><span class="line"><span class="keyword">engine</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T <span class="keyword">values</span>(<span class="number">100</span>,<span class="number">1</span>, <span class="string">'aa'</span>),(<span class="number">200</span>,<span class="number">2</span>,<span class="string">'bb'</span>),(<span class="number">300</span>,<span class="number">3</span>,<span class="string">'cc'</span>),(<span class="number">500</span>,<span class="number">5</span>,<span class="string">'ee'</span>),(<span class="number">600</span>,<span class="number">6</span>,<span class="string">'ff'</span>),(<span class="number">700</span>,<span class="number">7</span>,<span class="string">'gg'</span>);</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="http://liyong.ac.cn/pic/5C1550197920438.png" alt="1550197920438"></p><p>如果我执行 select * from T where k between 3 and 5，需要执行几次树的搜索操作，会扫描多少行？</p><ul><li>在 k 索引树上找到 k=3 的记录，取得 ID = 300；</li><li>再到 ID 索引树查到 ID=300 对应的 R3；</li><li>在 k 索引树取下一个值 k=5，取得 ID=500；</li><li>再回到 ID 索引树查到 ID=500 对应的 R4；</li><li>在 k 索引树取下一个值 k=6，不满足条件，循环结束。</li></ul><h1 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h1><p>如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p><h1 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tuser`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`id_card`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`ismale`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`id_card`</span> (<span class="string">`id_card`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`name_age`</span> (<span class="string">`name`</span>,<span class="string">`age`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span></span><br></pre></td></tr></table></figure><p>B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。</p><p><img src="https://liyong.ac.cn/pic/5C1550198379676.png" alt="1550198379676"></p><p>只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。</p><h1 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h1><h2 id="索引没有下推"><a href="#索引没有下推" class="headerlink" title="索引没有下推"></a>索引没有下推</h2><p><img src="https://liyong.ac.cn/pic/5C1550198618053.png" alt="1550198618053"></p><h2 id="索引有下推"><a href="#索引有下推" class="headerlink" title="索引有下推"></a>索引有下推</h2><p><img src="https://liyong.ac.cn/pic/5C1550198657359.png" alt="1550198657359"></p>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> db </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21为什么我只改一行的语句，锁这么多</title>
      <link href="/2019/03/11/aa_category/db/mysql/mysql%E5%AE%9E%E6%88%98/21%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%94%B9%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%EF%BC%8C%E9%94%81%E8%BF%99%E4%B9%88%E5%A4%9A/"/>
      <url>/2019/03/11/aa_category/db/mysql/mysql%E5%AE%9E%E6%88%98/21%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%94%B9%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%EF%BC%8C%E9%94%81%E8%BF%99%E4%B9%88%E5%A4%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="两个“原则”、两个“优化”和一个“bug"><a href="#两个“原则”、两个“优化”和一个“bug" class="headerlink" title="两个“原则”、两个“优化”和一个“bug"></a>两个“原则”、两个“优化”和一个“bug</h1><ul><li><p>原则 1：加锁的基本单位是 next-key lock。</p></li><li><p>原则 2：查找过程中访问到的对象才会加锁。</p></li><li><p>优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。</p></li><li><p>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</p></li><li><p>一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止</p></li></ul><a id="more"></a><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t21`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t21 <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure><h1 id="案例一：等值查询间隙锁"><a href="#案例一：等值查询间隙锁" class="headerlink" title="案例一：等值查询间隙锁"></a>案例一：等值查询间隙锁</h1><table><thead><tr><th>session A</th><th>session B</th><th>session C</th></tr></thead><tbody><tr><td>start TRANSACTION;<br>update t21 set d=d+1 where id=7;</td><td></td><td></td></tr><tr><td></td><td>start TRANSACTION;<br>insert into t21 values(8,8,8)</td><td></td></tr><tr><td></td><td></td><td>start TRANSACTION;<br>update t21 set d=d+1 where id=10;</td></tr></tbody></table><p>由于表 t 中没有 id=7 的记录，所以用我们上面提到的加锁规则判断一下的话：</p><ol><li>根据原则 1，加锁单位是 next-key lock，session A 加锁范围就是 (5,10]；</li><li>同时根据优化 2，这是一个等值查询 (id=7)，而 id=10 不满足查询条件，next-key lock 退化成间隙锁，因此最终加锁的范围是 (5,10)。</li></ol><p>所以，session B 要往这个间隙里面插入 id=8 的记录会被锁住，但是 session C 修改 id=10 这行是可以的。</p><h1 id="案例二：非唯一索引等值锁"><a href="#案例二：非唯一索引等值锁" class="headerlink" title="案例二：非唯一索引等值锁"></a>案例二：非唯一索引等值锁</h1><table><thead><tr><th>session A</th><th>session B</th><th>session C</th></tr></thead><tbody><tr><td>start TRANSACTION;<br>SELECT id from t21 where c=5 lock in SHARE mode;</td><td></td><td></td></tr><tr><td></td><td>start TRANSACTION;<br>update t21 set d=d+1 where id=5;</td><td></td></tr><tr><td></td><td></td><td>start TRANSACTION;<br>insert into t21 values(8,8,8)</td></tr></tbody></table><p>这里 session A 要给索引 c 上 c=5 的这一行加上读锁。</p><ol><li>根据原则 1，加锁单位是 next-key lock，因此会给 (0,5] 加上 next-key lock。</li><li>要注意 c 是普通索引，因此仅访问 c=5 这一条记录是不能马上停下来的，需要向右遍历，查到 c=10 才放弃。根据原则 2，访问到的都要加锁，因此要给 (5,10] 加 next-key lock。</li><li>但是同时这个符合优化 2：等值判断，向右遍历，最后一个值不满足 c=5 这个等值条件，因此退化成间隙锁 (5,10)。</li><li>根据原则 2 ，<strong>只有访问到的对象才会加锁</strong>，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么 session B 的 update 语句可以执行完成。</li></ol><h1 id="案例三：主键索引范围锁"><a href="#案例三：主键索引范围锁" class="headerlink" title="案例三：主键索引范围锁"></a>案例三：主键索引范围锁</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>&gt;=<span class="number">10</span> <span class="keyword">and</span> <span class="keyword">id</span>&lt;<span class="number">11</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>在逻辑上，这两条查语句肯定是等价的，但是它们的加锁规则不太一样</p><table><thead><tr><th>session A</th><th>session B</th><th>session C</th></tr></thead><tbody><tr><td>start TRANSACTION;<br><br>SELECT * from t21 where id&gt;=10 and id&lt;11 for update;</td><td></td><td></td></tr><tr><td></td><td>start TRANSACTION;<br> <br>insert into t21 values(8,8,8);<br><br>insert into t21 values(13,13,13);</td><td></td></tr><tr><td></td><td></td><td>start TRANSACTION;<br><br>update t21 set d=d+1 where id=15</td></tr></tbody></table><ol><li>开始执行的时候，要找到第一个 id=10 的行，因此本该是 next-key lock(5,10]。 根据优化 1， 主键 id 上的等值条件，退化成行锁，只加了 id=10 这一行的行锁。</li><li>范围查找就往后继续找，找到 id=15 这一行停下来，因此需要加 next-key lock(10,15]。</li></ol><p>所以，session A 这时候锁的范围就是主键索引上，行锁 id=10 和 next-key lock(10,15]。这样，session B 和 session C 的结果你就能理解了。</p><p>这里你需要注意一点，首次 session A 定位查找 id=10 的行的时候，是当做等值查询来判断的，而向右扫描到 id=15 的时候，用的是范围查询判断。</p><h1 id="案例四：非唯一索引范围锁"><a href="#案例四：非唯一索引范围锁" class="headerlink" title="案例四：非唯一索引范围锁"></a>案例四：非唯一索引范围锁</h1><table><thead><tr><th>session A</th><th>session B</th><th>session C</th></tr></thead><tbody><tr><td>start TRANSACTION;<br><br>SELECT * from t21 where c&gt;=10 and id&lt;11 for update;</td><td></td><td></td></tr><tr><td></td><td>start TRANSACTION;<br> <br>insert into t21 values(8,8,8);<br><br>insert into t21 values(13,13,13);</td><td></td></tr><tr><td></td><td></td><td>start TRANSACTION;<br><br>update t21 set d=d+1 where c=15</td></tr></tbody></table><p>这次 session A 用字段 c 来判断，加锁规则跟案例三唯一的不同是：在第一次用 c=10 定位记录的时候，索引 c 上加了 (5,10] 这个 next-key lock 后，由于索引 c 是非唯一索引，没有优化规则，也就是说不会蜕变为行锁，因此最终 sesion A 加的锁是，索引 c 上的 (5,10] 和 (10,15] 这两个 next-key lock。</p><p>所以从结果上来看，sesson B 要插入（8,8,8) 的这个 insert 语句时就被堵住了。</p><p>这里需要扫描到 c=15 才停止扫描，是合理的，因为 InnoDB 要扫到 c=15，才知道不需要继续往后找了。</p><h1 id="案例五：唯一索引范围锁-bug"><a href="#案例五：唯一索引范围锁-bug" class="headerlink" title="案例五：唯一索引范围锁 bug"></a>案例五：唯一索引范围锁 bug</h1><table><thead><tr><th>session A</th><th>session B</th><th>session C</th></tr></thead><tbody><tr><td>start TRANSACTION;<br><br>SELECT * from t21 where id&gt;10 and id&lt;=15 for update;</td><td></td><td></td></tr><tr><td></td><td>start TRANSACTION;<br><br>SELECT * from t21 where id&gt;10 and id&lt;=15 for update;</td><td></td></tr><tr><td></td><td></td><td>start TRANSACTION;<br><br>SELECT * from t21 where id&gt;10 and id&lt;=15 for update;</td></tr></tbody></table><p>session A 是一个范围查询，按照原则 1 的话，应该是索引 id 上只加 (10,15] 这个 next-key lock，并且因为 id 是唯一键，所以循环判断到 id=15 这一行就应该停止了。</p><p>但是实现上，InnoDB 会往前扫描到第一个不满足条件的行为止，也就是 id=20。而且由于这是个范围扫描，因此索引 id 上的 (15,20] 这个 next-key lock 也会被锁上。</p><p>所以你看到了，session B 要更新 id=20 这一行，是会被锁住的。同样地，session C 要插入 id=16 的一行，也会被锁住。</p><p>照理说，这里锁住 id=20 这一行的行为，其实是没有必要的。因为扫描到 id=15，就可以确定不用往后再找了。但实现上还是这么做了，因此我认为这是个 bug。</p><h1 id="案例六：非唯一索引上存在”等值”的例子"><a href="#案例六：非唯一索引上存在”等值”的例子" class="headerlink" title="案例六：非唯一索引上存在”等值”的例子"></a>案例六：非唯一索引上存在”等值”的例子</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">30</span>,<span class="number">10</span>,<span class="number">30</span>);</span><br></pre></td></tr></table></figure><p><img src="https://static001.geekbang.org/resource/image/c1/59/c1fda36c1502606eb5be3908011ba159.png" alt></p><p>可以看到，虽然有两个 c=10，但是它们的主键值 id 是不同的（分别是 10 和 30），因此这两个 c=10 的记录之间，也是有间隙的。</p><p>图中我画出了索引 c 上的主键 id。为了跟间隙锁的开区间形式进行区别，我用 (c=10,id=30) 这样的形式，来表示索引上的一行。</p><p>现在，我们来看一下案例六。</p><p>这次我们用 delete 语句来验证。注意，delete 语句加锁的逻辑，其实跟 select … for update 是类似的，也就是我在文章开始总结的两个“原则”、两个“优化”和一个“bug”</p><table><thead><tr><th>session A</th><th>session B</th><th>session C</th></tr></thead><tbody><tr><td>start TRANSACTION;<br><br>DELETE from t21 where c=10;</td><td></td><td></td></tr><tr><td></td><td>start TRANSACTION;<br> <br>insert into t21 values(12,12,12);</td><td></td></tr><tr><td></td><td></td><td>start TRANSACTION;<br><br>update t21 set d=d+1 where c=15</td></tr></tbody></table><p>session A 是一个范围查询</p><p>这时，session A 在遍历的时候，先访问第一个 c=10 的记录。同样地，根据原则 1，这里加的是 (c=5,id=5) 到 (c=10,id=10) 这个 next-key lock。</p><p>然后，session A 向右查找，直到碰到 (c=15,id=15) 这一行，循环才结束。根据优化 2，这是一个等值查询，向右查找到了不满足条件的行，所以会退化成 (c=10,id=10) 到 (c=15,id=15) 的间隙锁。</p><h1 id="案例七：limit-语句加锁"><a href="#案例七：limit-语句加锁" class="headerlink" title="案例七：limit 语句加锁"></a>案例七：limit 语句加锁</h1><p>我在文章开始总结的两个“原则”、两个“优化”和一个“bug”</p><table><thead><tr><th>session A</th><th>session B</th></tr></thead><tbody><tr><td>start TRANSACTION;<br><br>DELETE from t21 where c=10 LIMIT 2;</td><td></td></tr><tr><td></td><td>start TRANSACTION;<br> <br>insert into t21 values(12,12,12);</td></tr></tbody></table><p>session A 的 delete 语句加了 limit 2。你知道表 t 里 c=10 的记录其实只有两条，因此加不加 limit 2，删除的效果都是一样的，但是加锁的效果却不同。可以看到，session B 的 insert 语句执行通过了，跟案例六的结果不同。</p><p>这是因为，案例七里的 delete 语句明确加了 limit 2 的限制，因此在遍历到 (c=10, id=30) 这一行之后，满足条件的语句已经有两条，循环就结束了。</p><p>因此，索引 c 上的加锁范围就变成了从（c=5,id=5) 到（c=10,id=30) 这个前开后闭区间</p><h1 id="案例八：一个死锁的例子"><a href="#案例八：一个死锁的例子" class="headerlink" title="案例八：一个死锁的例子"></a>案例八：一个死锁的例子</h1><p>我在文章开始总结的两个“原则”、两个“优化”和一个“bug”</p><table><thead><tr><th>session A</th><th>session B</th></tr></thead><tbody><tr><td>start TRANSACTION;<br><br>SELECT id from t21 where c=10 lock in share MODE;</td><td></td></tr><tr><td></td><td>start TRANSACTION;<br><br>update t21 set d=d+1 where c=10</td></tr><tr><td>insert into t21 values(8,8,8);</td><td></td></tr><tr><td></td><td>[Err] 1213 - Deadlock found when trying to get lock; try restarting transaction</td></tr></tbody></table><p> 现在，我们按时间顺序来分析一下为什么是这样的结果。</p><ol><li>session A 启动事务后执行查询语句加 lock in share mode，在索引 c 上加了 next-key lock(5,10] 和间隙锁 (10,15)；</li><li>session B 的 update 语句也要在索引 c 上加 next-key lock(5,10] ，进入锁等待；</li><li>然后 session A 要再插入 (8,8,8) 这一行，被 session B 的间隙锁锁住。由于出现了死锁，InnoDB 让 session B 回滚。</li></ol><p>你可能会问，session B 的 next-key lock 不是还没申请成功吗？</p><p>其实是这样的，session B 的“加 next-key lock(5,10] ”操作，实际上分成了两步，先是加 (5,10) 的间隙锁，加锁成功；然后加 c=10 的行锁，这时候才被锁住的。</p><p>也就是说，我们在分析加锁规则的时候可以用 next-key lock 来分析。但是要知道，具体执行的时候，是要分成间隙锁和行锁两段来执行的。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这里我再次说明一下，我们上面的所有案例都是在可重复读隔离级别 (repeatable-read) 下验证的。同时，可重复读隔离级别遵守两阶段锁协议，所有加锁的资源，都是在事务提交或者回滚的时候才释放的</p><p>在最后的案例中，你可以清楚地知道 next-key lock 实际上是由间隙锁加行锁实现的。如果切换到读提交隔离级别 (read-committed) 的话，就好理解了，过程中去掉间隙锁的部分，也就是只剩下行锁的部分</p>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> db </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9普通索引和唯一索引，应该怎么选择</title>
      <link href="/2019/03/11/aa_category/db/mysql/mysql%E5%AE%9E%E6%88%98/9%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%EF%BC%8C%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9/"/>
      <url>/2019/03/11/aa_category/db/mysql/mysql%E5%AE%9E%E6%88%98/9%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%EF%BC%8C%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h1><ul><li><p>InnoDB 的数据是按数据页为单位来读写的</p></li><li><p>每个数据页的大小默认是 16KB</p></li></ul><h1 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h1><ul><li>如果数据页在内存中就直接更新</li><li>如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作</li><li>唯一索引的更新就不能使用 change buffer，实际上也只有普通索引可以使用。</li></ul><a id="more"></a><h2 id="插入一个新记录-4-400"><a href="#插入一个新记录-4-400" class="headerlink" title="插入一个新记录 (4,400)"></a>插入一个新记录 (4,400)</h2><h3 id="更新的目标页在内存中"><a href="#更新的目标页在内存中" class="headerlink" title="更新的目标页在内存中"></a>更新的目标页在内存中</h3><ul><li>对于唯一索引来说，找到 3 和 5 之间的位置，判断到没有冲突，插入这个值，语句执行结束；</li><li>对于普通索引来说，找到 3 和 5 之间的位置，插入这个值，语句执行结束。</li></ul><h3 id="更新的目标页不在内存中"><a href="#更新的目标页不在内存中" class="headerlink" title="更新的目标页不在内存中"></a>更新的目标页不在内存中</h3><ul><li>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；</li><li>对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。</li></ul><p>将数据从磁盘读入内存涉及随机 IO 的访问，是数据库里面成本最高的操作之一。change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。</p><h1 id="change-buffer-的使用场景"><a href="#change-buffer-的使用场景" class="headerlink" title="change buffer 的使用场景"></a>change buffer 的使用场景</h1><p> 对于写多读少.例如，账单类、日志类的系统。</p><h1 id="change-buffer-和-redo-log"><a href="#change-buffer-和-redo-log" class="headerlink" title="change buffer 和 redo log"></a>change buffer 和 redo log</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(<span class="keyword">id</span>,k) <span class="keyword">values</span>(id1,k1),(id2,k2);</span><br></pre></td></tr></table></figure><p>k1 所在的数据页在内存 (InnoDB buffer pool) 中，k2 所在的数据页不在内存中</p><p><img src="http://liyong.ac.cn/pic/5C1550469162292.png" alt="1550469162292"></p><ol><li>Page 1 在内存中，直接更新内存；</li><li>Page 2 没有在内存中，就在内存的 change buffer 区域，记录下“我要往 Page 2 插入一行”这个信息</li><li>将上述两个动作记入 redo log 中（图中 3 和 4）。</li><li>图中的两个虚线箭头，是后台操作，不影响更新的响应时间。</li></ol><h1 id="那在这之后的读请求，要怎么处理呢？"><a href="#那在这之后的读请求，要怎么处理呢？" class="headerlink" title="那在这之后的读请求，要怎么处理呢？"></a>那在这之后的读请求，要怎么处理呢？</h1><p> 要执行 select * from t where k in (k1, k2)</p><h3 id="如果读语句发生在更新语句后不久，内存中的数据都还在"><a href="#如果读语句发生在更新语句后不久，内存中的数据都还在" class="headerlink" title="如果读语句发生在更新语句后不久，内存中的数据都还在"></a>如果读语句发生在更新语句后不久，内存中的数据都还在</h3><p><img src="https://liyong.ac.cn/pic/5C1550469595781.png" alt="1550469595781"></p><ul><li>读 Page 1 的时候，直接从内存返回</li><li>读 Page 2 的时候，需要把 Page 2 从磁盘读入内存中，然后应用 change buffer 里面的操作日志，生成一个正确的版本并返回结果。</li></ul><p>redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗。</p>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> db </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工具篇】常用工具</title>
      <link href="/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/%E3%80%90%E5%B7%A5%E5%85%B7%E7%AF%87%E3%80%91%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
      <url>/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/%E3%80%90%E5%B7%A5%E5%85%B7%E7%AF%87%E3%80%91%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="javap"><a href="#javap" class="headerlink" title="javap"></a>javap</h1><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/javap.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/javap.html</a></p><h2 id="v-选项"><a href="#v-选项" class="headerlink" title="-v 选项"></a>-v 选项</h2><ul><li>基本信息，涵盖了class文件的相关信息。</li><li>常量池，存放各种产量以及符号引用</li><li>字段区域，用来列举该类中的各个字段。</li><li>方法区域</li></ul><a id="more"></a><h3 id="方法区域"><a href="#方法区域" class="headerlink" title="方法区域"></a>方法区域</h3><ul><li>异常表</li><li>LineNumberTable，源码到字节码偏移量的映射</li><li>LocalVariableTable（javac -g）每个局部变量的名字类型，以及作用域</li><li>字节码操作数映射表（StackMapTable）</li><li>-g 编译  LocalVariableTable</li><li>-parameters 编译 MethodParameters</li></ul><h1 id="OpenJDK-项目-Code-Tools：实用小工具集"><a href="#OpenJDK-项目-Code-Tools：实用小工具集" class="headerlink" title="OpenJDK 项目 Code Tools：实用小工具集"></a>OpenJDK 项目 Code Tools：实用小工具集</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://docs.oracle.com/javase/specs/jvms/se10/html/jvms-4.html#jvms-4.1" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se10/html/jvms-4.html#jvms-4.1</a></li><li><a href="http://openjdk.java.net/projects/code-tools/" target="_blank" rel="noopener">http://openjdk.java.net/projects/code-tools/</a></li><li><a href="https://wiki.openjdk.java.net/display/CodeTools/asmtools" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/CodeTools/asmtools</a></li><li><a href="https://cs.au.dk/~mis/dOvs/jvmspec/ref--21.html" target="_blank" rel="noopener">https://cs.au.dk/~mis/dOvs/jvmspec/ref--21.html</a></li><li><a href="http://openjdk.java.net/projects/code-tools/jol/" target="_blank" rel="noopener">http://openjdk.java.net/projects/code-tools/jol/</a></li><li><a href="https://asm.ow2.io/" target="_blank" rel="noopener">https://asm.ow2.io/</a></li><li><a href="http://web.cs.ucla.edu/~msb/cs239-tutorial/" target="_blank" rel="noopener">http://web.cs.ucla.edu/~msb/cs239-tutorial/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm资源</title>
      <link href="/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/jvm%E8%B5%84%E6%BA%90/"/>
      <url>/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/jvm%E8%B5%84%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h3 id="虚拟机牛人"><a href="#虚拟机牛人" class="headerlink" title="虚拟机牛人"></a>虚拟机牛人</h3><ul><li>RednaxelaFX  <a href="https://www.zhihu.com/people/rednaxelafx/activities" target="_blank" rel="noopener">https://www.zhihu.com/people/rednaxelafx/activities</a></li><li>你假苯  <a href="http://xxfox.perfma.com/" target="_blank" rel="noopener">http://xxfox.perfma.com/</a></li><li>江南白衣</li><li>占小狼</li><li>杨晓峰</li><li><a href="https://medium.com/graalvm" target="_blank" rel="noopener">https://medium.com/graalvm</a></li><li><a href="http://cliffc.org/blog/" target="_blank" rel="noopener">http://cliffc.org/blog/</a></li><li><a href="https://shipilev.net/jvm/anatomy-quarks/" target="_blank" rel="noopener">https://shipilev.net/jvm/anatomy-quarks/</a></li><li><a href="https://shipilev.net/" target="_blank" rel="noopener">https://shipilev.net/</a></li><li><a href="http://psy-lob-saw.blogspot.com/" target="_blank" rel="noopener">http://psy-lob-saw.blogspot.com/</a></li><li><a href="http://openjdk.java.net/projects/mlvm/jvmlangsummit/" target="_blank" rel="noopener">http://openjdk.java.net/projects/mlvm/jvmlangsummit/</a></li><li><a href="https://www.oracle.com/code-one/" target="_blank" rel="noopener">https://www.oracle.com/code-one/</a></li><li><a href="https://github.com/deephacks/awesome-jvm" target="_blank" rel="noopener">https://github.com/deephacks/awesome-jvm</a></li></ul><a id="more"></a><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://docs.oracle.com/javase/specs/jvms/se10/html/jvms-4.html#jvms-4.1" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se10/html/jvms-4.html#jvms-4.1</a></li><li><a href="http://openjdk.java.net/projects/code-tools/" target="_blank" rel="noopener">http://openjdk.java.net/projects/code-tools/</a></li><li><a href="https://wiki.openjdk.java.net/display/CodeTools/asmtools" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/CodeTools/asmtools</a></li><li><a href="https://cs.au.dk/~mis/dOvs/jvmspec/ref--21.html" target="_blank" rel="noopener">https://cs.au.dk/~mis/dOvs/jvmspec/ref--21.html</a></li><li><a href="http://openjdk.java.net/projects/code-tools/jol/" target="_blank" rel="noopener">http://openjdk.java.net/projects/code-tools/jol/</a></li><li><a href="https://asm.ow2.io/" target="_blank" rel="noopener">https://asm.ow2.io/</a></li><li><a href="http://web.cs.ucla.edu/~msb/cs239-tutorial/" target="_blank" rel="noopener">http://web.cs.ucla.edu/~msb/cs239-tutorial/</a></li></ul><ul><li><a href="http://openjdk.java.net/groups/compiler/doc/compilation-overview/index.html" target="_blank" rel="noopener">http://openjdk.java.net/groups/compiler/doc/compilation-overview/index.html</a></li><li><a href="http://hannesdorfmann.com/annotation-processing/annotationprocessing101" target="_blank" rel="noopener">http://hannesdorfmann.com/annotation-processing/annotationprocessing101</a></li><li><a href="https://docs.oracle.com/javase/10/docs/api/javax/lang/model/element/package-summary.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/10/docs/api/javax/lang/model/element/package-summary.html</a></li><li><a href="https://projectlombok.org/" target="_blank" rel="noopener">https://projectlombok.org/</a></li><li><a href="http://notatube.blogspot.com/2010/11/project-lombok-trick-explained.html" target="_blank" rel="noopener">http://notatube.blogspot.com/2010/11/project-lombok-trick-explained.html</a></li><li><a href="http://jnb.ociweb.com/jnb/jnbJan2010.html#controversy" target="_blank" rel="noopener">http://jnb.ociweb.com/jnb/jnbJan2010.html#controversy</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se10/html/jvms-6.html#jvms-6.5" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se10/html/jvms-6.html#jvms-6.5</a></li></ul><ul><li><a href="https://en.wikipedia.org/wiki/Static_single_assignment_form" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Static_single_assignment_form</a></li><li><a href="https://en.wikipedia.org/wiki/Reaching_definition" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Reaching_definition</a></li></ul><ul><li><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/HotSpot/Synchronization</a></li></ul><ul><li><a href="https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4</a></li><li><a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html" target="_blank" rel="noopener">http://gee.cs.oswego.edu/dl/jmm/cookbook.html</a></li><li><a href="https://blogs.oracle.com/dave/instruction-selection-for-volatile-fences-:-mfence-vs-lock:add" target="_blank" rel="noopener">https://blogs.oracle.com/dave/instruction-selection-for-volatile-fences-:-mfence-vs-lock:add</a></li><li><a href="https://vlkan.com/blog/post/2014/02/14/java-safe-publication/" target="_blank" rel="noopener">https://vlkan.com/blog/post/2014/02/14/java-safe-publication/</a></li><li><a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/CodeTools/jcstress</a></li><li><a href="http://hg.openjdk.java.net/code-tools/jcstress/file/64f2cf32fa0a/tests-custom/src/main/java/org/openjdk/jcstress/tests/unsafe/UnsafePublication.java" target="_blank" rel="noopener">http://hg.openjdk.java.net/code-tools/jcstress/file/64f2cf32fa0a/tests-custom/src/main/java/org/openjdk/jcstress/tests/unsafe/UnsafePublication.java</a></li></ul><ul><li><p><a href="http://psy-lob-saw.blogspot.com/2015/12/safepoints.html" target="_blank" rel="noopener">http://psy-lob-saw.blogspot.com/2015/12/safepoints.html</a></p></li><li><p><a href="http://openjdk.java.net/jeps/122" target="_blank" rel="noopener">http://openjdk.java.net/jeps/122</a></p></li><li><p><a href="http://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html" target="_blank" rel="noopener">http://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html</a></p></li><li><p><a href="https://blogs.oracle.com/dave/false-sharing-induced-by-card-table-marking" target="_blank" rel="noopener">https://blogs.oracle.com/dave/false-sharing-induced-by-card-table-marking</a></p></li><li><p><a href="http://openjdk.java.net/jeps/291" target="_blank" rel="noopener">http://openjdk.java.net/jeps/291</a></p></li><li><p><a href="https://wiki.openjdk.java.net/display/HotSpot/CompressedOops" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/HotSpot/CompressedOops</a></p></li><li><p><a href="http://openjdk.java.net/jeps/142" target="_blank" rel="noopener">http://openjdk.java.net/jeps/142</a></p></li></ul><ul><li><a href="https://en.wikipedia.org/wiki/Duck_typing" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Duck_typing</a></li><li><a href="https://docs.oracle.com/javase/10/docs/api/java/lang/invoke/MethodHandle.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/10/docs/api/java/lang/invoke/MethodHandle.html</a></li><li><a href="https://en.wikipedia.org/wiki/Currying" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Currying</a></li><li><a href="http://openjdk.java.net/jeps/303" target="_blank" rel="noopener">http://openjdk.java.net/jeps/303</a></li></ul><ul><li><p><a href="https://docs.oracle.com/javase/tutorial/reflect/" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/reflect/</a></p></li><li><p><a href="http://hg.openjdk.java.net/jdk10/jdk10/jdk/file/777356696811/src/java.base/share/classes/jdk/internal/reflect/ReflectionFactory.java#l80" target="_blank" rel="noopener">http://hg.openjdk.java.net/jdk10/jdk10/jdk/file/777356696811/src/java.base/share/classes/jdk/internal/reflect/ReflectionFactory.java#l80</a></p></li><li><p><a href="http://hg.openjdk.java.net/jdk10/jdk10/jdk/file/777356696811/src/java.base/share/classes/jdk/internal/reflect/ReflectionFactory.java#l78" target="_blank" rel="noopener">http://hg.openjdk.java.net/jdk10/jdk10/jdk/file/777356696811/src/java.base/share/classes/jdk/internal/reflect/ReflectionFactory.java#l78</a></p></li><li><p><a href="https://docs.oracle.com/javase/tutorial/reflect/class/classMembers.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/reflect/class/classMembers.html</a></p></li><li><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/language/varargs.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/language/varargs.html</a></p></li><li><p><a href="https://docs.oracle.com/javase/tutorial/java/generics/bridgeMethods.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/java/generics/bridgeMethods.html</a></p></li><li><p><a href="https://wiki.openjdk.java.net/display/HotSpot/VirtualCalls" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/HotSpot/VirtualCalls</a></p></li><li><p><a href="https://wiki.openjdk.java.net/display/HotSpot/InterfaceCalls" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/HotSpot/InterfaceCalls</a></p></li><li><p><a href="https://docs.oracle.com/javase/specs/jvms/se10/html/jvms-4.html#jvms-4.1" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se10/html/jvms-4.html#jvms-4.1</a></p></li><li><p><a href="http://openjdk.java.net/projects/code-tools/" target="_blank" rel="noopener">http://openjdk.java.net/projects/code-tools/</a></p></li><li><p><a href="https://wiki.openjdk.java.net/display/CodeTools/asmtools" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/CodeTools/asmtools</a></p></li><li><p><a href="https://cs.au.dk/~mis/dOvs/jvmspec/ref--21.html" target="_blank" rel="noopener">https://cs.au.dk/~mis/dOvs/jvmspec/ref--21.html</a></p></li><li><p><a href="http://openjdk.java.net/projects/code-tools/jol/" target="_blank" rel="noopener">http://openjdk.java.net/projects/code-tools/jol/</a></p></li><li><p><a href="https://asm.ow2.io/" target="_blank" rel="noopener">https://asm.ow2.io/</a></p></li><li><p><a href="http://web.cs.ucla.edu/~msb/cs239-tutorial/" target="_blank" rel="noopener">http://web.cs.ucla.edu/~msb/cs239-tutorial/</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>35SubstrateVM：AOT编译框架</title>
      <link href="/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/35SubstrateVM%EF%BC%9AAOT%E7%BC%96%E8%AF%91%E6%A1%86%E6%9E%B6/"/>
      <url>/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/35SubstrateVM%EF%BC%9AAOT%E7%BC%96%E8%AF%91%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>Substrate VM is a framework that allows ahead-of-time (AOT) compilation of Java applications under closed-world assumption into executable images or shared objects (ELF-64 or 64-bit Mach-O).</p><p>所谓 AOT 编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql-explain</title>
      <link href="/2019/03/11/aa_category/db/mysql/mysql-explain/"/>
      <url>/2019/03/11/aa_category/db/mysql/mysql-explain/</url>
      
        <content type="html"><![CDATA[<h1 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h1><h2 id="SIMPLE"><a href="#SIMPLE" class="headerlink" title="SIMPLE"></a>SIMPLE</h2><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>SIMPLE</td><td>简单表，不使用表连接或子查询</td></tr><tr><td>PRIMARY</td><td>主查询，即外层的查询</td></tr><tr><td>UNION</td><td></td></tr><tr><td>SUBQUERY</td><td></td></tr></tbody></table><a id="more"></a><h1 id="table"><a href="#table" class="headerlink" title="table"></a>table</h1><h1 id="type"><a href="#type" class="headerlink" title="type"></a>type</h1><table><thead><tr><th>ALL</th><th>全表扫描</th></tr></thead><tbody><tr><td>index</td><td>索引全扫描</td></tr><tr><td>range</td><td>索引范围扫描</td></tr><tr><td>ref</td><td>非唯一索引扫描</td></tr><tr><td>eq_ref</td><td>唯一索引扫描</td></tr><tr><td>const,system</td><td>单表最多有一个匹配行</td></tr><tr><td>NULL</td><td>不用扫描表或索引</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> db </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4深入浅出索引</title>
      <link href="/2019/03/11/aa_category/db/mysql/mysql%E5%AE%9E%E6%88%98/4%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95/"/>
      <url>/2019/03/11/aa_category/db/mysql/mysql%E5%AE%9E%E6%88%98/4%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><ul><li>和hashmap的思路一样</li><li>区间查询比较慢</li><li>适用于等值查询的场景</li></ul><p><img src="http://liyong.ac.cn/pic/20190215_01.png" alt="1550194991315"></p><a id="more"></a><h1 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h1><ul><li>等值查询和范围查询性能非常优秀</li><li>但是更新成本太高</li></ul><p><img src="http://liyong.ac.cn/pic/5C1550195174282.png" alt="1550195174282"></p><h1 id="搜索树"><a href="#搜索树" class="headerlink" title="搜索树"></a>搜索树</h1><h1 id="InnoDB-的索引模型"><a href="#InnoDB-的索引模型" class="headerlink" title="InnoDB 的索引模型"></a>InnoDB 的索引模型</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>, </span><br><span class="line">k <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>, </span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">16</span>),</span><br><span class="line"><span class="keyword">index</span> (k))<span class="keyword">engine</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure><p>表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树的示例示意图如下。</p><p><img src="http://liyong.ac.cn/pic/5C1550195640200.png" alt="1550195640200"></p><h2 id="基于主键索引和普通索引的查询有什么区别？"><a href="#基于主键索引和普通索引的查询有什么区别？" class="headerlink" title="基于主键索引和普通索引的查询有什么区别？"></a>基于主键索引和普通索引的查询有什么区别？</h2><ul><li>如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；</li><li>如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。</li></ul><h2 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h2><p>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</p><p>有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的?</p><ul><li><p>只有一个索引；</p></li><li><p>该索引必须是唯一索引</p></li></ul><h1 id="如何避免长事务对业务的影响？"><a href="#如何避免长事务对业务的影响？" class="headerlink" title="如何避免长事务对业务的影响？"></a>如何避免长事务对业务的影响？</h1><ul><li>确认是否使用了 set autocommit=0。这个确认工作可以在测试环境中开展，把 MySQL 的 general_log 开起来，然后随便跑一个业务逻辑，通过 general_log 的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成 1。</li><li>确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用 begin/commit 框起来。我见过有些是业务并没有这个需要，但是也把好几个 select 语句放到了事务中。这种只读事务可以去掉。</li><li>业务连接数据库的时候，根据业务本身的预估，通过 SET MAX_EXECUTION_TIME 命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。（为什么会意外？在后续的文章中会提到这类案例）</li><li>监控 information_schema.Innodb_trx 表，设置长事务阈值，超过就报警 / 或者 kill；</li><li>Percona 的 pt-kill 这个工具不错，推荐使用；</li><li>在业务功能测试阶段要求输出所有的 general_log，分析日志行为提前发现问题；</li><li>把 innodb_undo_tablespaces 设置成 2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。</li></ul><h1 id="General-log"><a href="#General-log" class="headerlink" title="General_log"></a>General_log</h1><p>开启 general log 将所有到达MySQL Server的SQL语句记录下来。</p><p>一般不会开启开功能，因为log的量会非常庞大。但个别情况下可能会临时的开一会儿general log以供排障使用。<br>相关参数一共有3：general_log、log_output、general_log_file</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'general_log'</span>; <span class="comment">-- 查看日志是否开启</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log=<span class="keyword">on</span>; <span class="comment">-- 开启日志功能</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'general_log_file'</span>; <span class="comment">-- 看看日志文件保存位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log_file=<span class="string">'tmp/general.lg'</span>; <span class="comment">-- 设置日志文件保存位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'log_output'</span>; <span class="comment">-- 看看日志输出类型 table或file</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_output=<span class="string">'table'</span>; <span class="comment">-- 设置输出类型为 table</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_output=<span class="string">'file'</span>; <span class="comment">-- 设置输出类型为file</span></span><br></pre></td></tr></table></figure><p> log_output=’FILE’ 表示将日志存入文件,默认值是FILE　<br>log_output=’TABLE’表示将日志存入数据库,这样日志信息就会被写入到mysql.slow_log表中.</p>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> db </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用sql</title>
      <link href="/2019/03/11/aa_category/db/mysql/%E5%B8%B8%E7%94%A8sql/"/>
      <url>/2019/03/11/aa_category/db/mysql/%E5%B8%B8%E7%94%A8sql/</url>
      
        <content type="html"><![CDATA[<h1 id="查看搜索引擎"><a href="#查看搜索引擎" class="headerlink" title="查看搜索引擎"></a>查看搜索引擎</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">ENGINES</span></span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="查看搜索引擎的状态"><a href="#查看搜索引擎的状态" class="headerlink" title="查看搜索引擎的状态"></a>查看搜索引擎的状态</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">engine</span>   <span class="keyword">INNODB</span> <span class="keyword">STATUS</span></span><br></pre></td></tr></table></figure><p>查看搜索引擎版本</p><h1 id="查看搜索引擎版本"><a href="#查看搜索引擎版本" class="headerlink" title="查看搜索引擎版本"></a>查看搜索引擎版本</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">VARIABLES</span> <span class="keyword">like</span> <span class="string">'innodb_version'</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span></span><br><span class="line">// 设置<span class="keyword">binlog</span>格式</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> binlog_format = <span class="string">'STATEMENT'</span>;</span><br><span class="line">// 查看警告信息</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">warnings</span></span><br></pre></td></tr></table></figure><h1 id="查看表的信息"><a href="#查看表的信息" class="headerlink" title="查看表的信息"></a>查看表的信息</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">  t<span class="selector-class">.COLUMN_NAME</span>,</span><br><span class="line">  t<span class="selector-class">.COLUMN_type</span>,</span><br><span class="line">  t<span class="selector-class">.IS_NULLABLE</span>,</span><br><span class="line">  t<span class="selector-class">.COLUMN_DEFAULT</span>,</span><br><span class="line">  t<span class="selector-class">.COLUMN_key</span>,</span><br><span class="line">  t<span class="selector-class">.EXTRA</span>,</span><br><span class="line">  t.COLUMN_COMMENT</span><br><span class="line">from information_schema<span class="selector-class">.columns</span> t</span><br><span class="line">where table_schema = <span class="string">'table_schema'</span> and TABLE_NAME = <span class="string">'TABLE_NAME'</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> db </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3为什么你改了我还看不见</title>
      <link href="/2019/03/11/aa_category/db/mysql/mysql%E5%AE%9E%E6%88%98/3%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E6%94%B9%E4%BA%86%E6%88%91%E8%BF%98%E7%9C%8B%E4%B8%8D%E8%A7%81/"/>
      <url>/2019/03/11/aa_category/db/mysql/mysql%E5%AE%9E%E6%88%98/3%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E6%94%B9%E4%BA%86%E6%88%91%E8%BF%98%E7%9C%8B%E4%B8%8D%E8%A7%81/</url>
      
        <content type="html"><![CDATA[<h1 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h1><ul><li><p>Atomicity、Consistency、Isolation、Durability</p></li><li><p>脏读（dirty read）、不可重复读(non-repeatable read)、幻读(phantom read)</p></li><li><p>读未提交（read uncommitted）,一个事务还没有提交，就能被其它事务看到</p></li><li><p>读提交（read committed），一个事务提交才能被其它事务看到</p></li><li><p>可重复读（repeatable read），一个事务执行过程中看到的数据和启动时看到的数据一致</p></li><li><p>串行化（serializable ），对于同一行记录，写会加写锁，读会加读锁，当出现读写锁冲突的时候，必须等待前一个事务结束，才能继续</p></li><li><p>查看隔离级别  show variables like ‘transaction_isolation’;  SELECT @@tx_isolation</p></li></ul><a id="more"></a>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T(c <span class="built_in">int</span>) <span class="keyword">engine</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T(c) <span class="keyword">values</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>   <img src="http://liyong.ac.cn/pic/1547083654928.png" alt="1547083654928"></p><h1 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h1><p>假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面有类似的记录</p><p><img src="http://liyong.ac.cn/pic/1547084068069.png" alt="1547084068069"></p><p>不要使用长事务</p><h2 id="不要使用长事务"><a href="#不要使用长事务" class="headerlink" title="不要使用长事务"></a>不要使用长事务</h2><ul><li>长事务意味系统里会存在很多老的事务视图</li></ul><h2 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h2><ul><li>显式写begin 或 start transaction，提交commit，回滚写rollback</li><li>set autocommit=0 将自动提交关闭</li><li>select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60</li><li>SELECT @@tx_isolation</li><li>select version() from dual;</li><li>set session transaction isolation level  repeatable read</li></ul><h1 id="question"><a href="#question" class="headerlink" title="question"></a>question</h1>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> db </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>锁</title>
      <link href="/2019/03/11/aa_category/db/mysql/%E9%94%81/"/>
      <url>/2019/03/11/aa_category/db/mysql/%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h1><ul><li>读未提交（read uncommitted）,一个事务还没有提交，就能被其它事务看到</li><li>读提交（read committed），一个事务提交才能被其它事务看到</li><li>可重复读（repeatable read），一个事务执行过程中看到的数据和启动时看到的数据一致</li><li>串行化（serializable ），对于同一行记录，写会加写锁，读会加读锁，当出现读写锁冲突的时候，必须等待前一个事务结束，才能继续</li></ul><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ul><li>锁表LOCK TABLES  WRITE</li><li>释放锁  UNLOCK TABLES</li><li>select * from sys.innodb_lock_waits 查看等待</li></ul><h1 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h1><ul><li>用于读</li><li>SELECT k from t where id=1 可以进行写入操作</li><li>SELECT k from t where id=1 lock in share mode;则不可以进行写</li></ul><h1 id="排它锁"><a href="#排它锁" class="headerlink" title="排它锁"></a>排它锁</h1><ul><li><p>又称写锁，简称X锁，排它锁不能与其他锁并存，如果一个事物获取了一个数据的排它锁，其他事务就不能再获取该行的锁，只有获取了排它锁的事务可以对数据进行读取和修改</p></li><li><p>加锁释锁方式</p><ul><li>自动  delete/update/insert 默认加X锁</li><li>手动 select *  from t where id=1 for update</li><li>commit/rollback</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t1`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`k`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">VALUES</span>(<span class="number">7</span>,<span class="number">7</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">VALUES</span>(<span class="number">10</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h2 id="场景1-锁住整张表"><a href="#场景1-锁住整张表" class="headerlink" title="场景1-锁住整张表"></a>场景1-锁住整张表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事务1</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> t1 <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">7</span>  <span class="keyword">for</span> <span class="keyword">update</span> ; </span><br><span class="line"><span class="comment"># 事务2</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">VALUES</span>(<span class="number">11</span>,<span class="number">11</span>);</span><br></pre></td></tr></table></figure><ul><li>没有索引，或者没有命中索引就会锁住整张表</li></ul><h2 id="场景2"><a href="#场景2" class="headerlink" title="场景2-"></a>场景2-</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事务1</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> t1 <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">7</span>  <span class="keyword">for</span> <span class="keyword">update</span> ; </span><br><span class="line"><span class="comment"># 事务2</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">update</span> t1 <span class="keyword">set</span> k=<span class="number">22</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">22</span></span><br></pre></td></tr></table></figure><ul><li>会</li></ul><h1 id="意向共享锁"><a href="#意向共享锁" class="headerlink" title="意向共享锁"></a>意向共享锁</h1><ul><li>桥梁作用，行锁和表锁的桥梁</li><li>事务获取共享锁之前必须先获取意向共享锁</li></ul><h1 id="意向排它锁"><a href="#意向排它锁" class="headerlink" title="意向排它锁"></a>意向排它锁</h1><table><thead><tr><th></th><th><code>X</code></th><th><code>IX</code></th><th><code>S</code></th><th><code>IS</code></th></tr></thead><tbody><tr><td><code>X</code></td><td>Conflict</td><td>Conflict</td><td>Conflict</td><td>Conflict</td></tr><tr><td><code>IX</code></td><td>Conflict</td><td>Compatible</td><td>Conflict</td><td>Compatible</td></tr><tr><td><code>S</code></td><td>Conflict</td><td>Conflict</td><td>Compatible</td><td>Compatible</td></tr><tr><td><code>IS</code></td><td>Conflict</td><td>Compatible</td><td>Compatible</td><td>Compatible</td></tr></tbody></table><h1 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h1><ul><li>锁住的是索引</li><li>对于非聚集索引，先锁住普通索引，再锁住聚集索引</li><li>对于没有聚集索引的表，mysql会生成默认的聚集索引，所以会锁住所有的表</li></ul><h1 id="间隙锁-amp-临键锁"><a href="#间隙锁-amp-临键锁" class="headerlink" title="间隙锁&amp;临键锁"></a>间隙锁&amp;临键锁</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t2`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`k`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">VALUES</span>(<span class="number">7</span>,<span class="number">7</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">VALUES</span>(<span class="number">10</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure><ul><li><p>间隙锁 (-无穷，1) ,(1,4),(4,7),(7,10),(10,+无穷)</p></li><li><p>临键锁  (-negative infinity，1] ,(1,4],(4,7],(7,10],(10,+positive infinity)</p></li><li><p>使用于范围查询</p></li><li><p>间隔锁只会阻止其他事务的插入操作，就是只有 insert 操作会产生 GAP 锁，update 操作不会参数 GAP 锁</p></li><li><p>目的是为了防止其他事务插入数据，所以读写不会阻塞</p></li><li><p>在可重复读级别启用</p></li></ul><h2 id="场景1-临键锁"><a href="#场景1-临键锁" class="headerlink" title="场景1-临键锁"></a>场景1-临键锁</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事务1</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">TRANSACTION</span>; </span><br><span class="line"><span class="keyword">select</span> *  <span class="keyword">from</span> t2 <span class="keyword">where</span>  <span class="keyword">id</span>&gt;<span class="number">5</span> <span class="keyword">and</span> <span class="keyword">id</span>&lt;<span class="number">9</span> <span class="keyword">for</span> <span class="keyword">update</span> ; </span><br><span class="line"><span class="comment"># 事务2</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">TRANSACTION</span>; </span><br><span class="line"><span class="keyword">select</span> *  <span class="keyword">from</span> t2 <span class="keyword">where</span>  <span class="keyword">id</span>&gt;<span class="number">5</span> <span class="keyword">and</span> <span class="keyword">id</span>&lt;<span class="number">9</span> <span class="keyword">for</span> <span class="keyword">update</span> ;</span><br></pre></td></tr></table></figure><ul><li>由于  5,9之间有有记录7，所以是临键锁，锁住 (4,7],(7,10]</li><li>临键锁之间互斥的</li></ul><h2 id="场景2-间隙锁"><a href="#场景2-间隙锁" class="headerlink" title="场景2-间隙锁"></a>场景2-间隙锁</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事务1</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">TRANSACTION</span>; </span><br><span class="line"><span class="keyword">select</span> *  <span class="keyword">from</span> t2 <span class="keyword">where</span>  <span class="keyword">id</span>&gt;<span class="number">20</span>  <span class="keyword">for</span> <span class="keyword">update</span> ;   </span><br><span class="line"><span class="comment"># 事务2</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">TRANSACTION</span>; </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">VALUES</span>(<span class="number">12</span>,<span class="number">12</span>);</span><br></pre></td></tr></table></figure><ul><li>事务1是间隙锁，锁住 (10,+无穷)，防止区间的数据变动</li><li>事务2 插入阻塞</li></ul><h2 id="场景3-间隙锁"><a href="#场景3-间隙锁" class="headerlink" title="场景3-间隙锁"></a>场景3-间隙锁</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事务1</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">TRANSACTION</span>; </span><br><span class="line"><span class="keyword">select</span> *  <span class="keyword">from</span> t2 <span class="keyword">where</span>  <span class="keyword">id</span>&gt;<span class="number">20</span>  <span class="keyword">for</span> <span class="keyword">update</span> ;   </span><br><span class="line"><span class="comment"># 事务2</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">TRANSACTION</span>; </span><br><span class="line"><span class="keyword">select</span> *  <span class="keyword">from</span> t2 <span class="keyword">where</span>  <span class="keyword">id</span>&gt;<span class="number">20</span>  <span class="keyword">for</span> <span class="keyword">update</span> ;</span><br></pre></td></tr></table></figure><ul><li>由于 没有大于20的记录，所以是间隙锁，锁住 (10,+无穷)</li><li>间隙锁之间不互斥</li></ul><h2 id="场景4-排它锁-amp-间隙锁"><a href="#场景4-排它锁-amp-间隙锁" class="headerlink" title="场景4-排它锁&amp;间隙锁"></a>场景4-排它锁&amp;间隙锁</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事务1</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">TRANSACTION</span>; </span><br><span class="line"><span class="keyword">select</span> *  <span class="keyword">from</span> t2 <span class="keyword">where</span>  <span class="keyword">id</span>=<span class="number">7</span>  <span class="keyword">for</span> <span class="keyword">update</span> ;</span><br><span class="line"><span class="comment"># 事务2</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">TRANSACTION</span>; </span><br><span class="line"><span class="keyword">select</span> *  <span class="keyword">from</span> t2 <span class="keyword">where</span>  <span class="keyword">id</span>=<span class="number">7</span>  <span class="keyword">for</span> <span class="keyword">update</span> ;</span><br></pre></td></tr></table></figure><ul><li>有主键等于7的记录，所以是排它锁，会互斥</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事务1</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">TRANSACTION</span>; </span><br><span class="line"><span class="keyword">select</span> *  <span class="keyword">from</span> t2 <span class="keyword">where</span>  <span class="keyword">id</span>=<span class="number">8</span>  <span class="keyword">for</span> <span class="keyword">update</span> ;</span><br><span class="line"><span class="comment"># 事务2</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">TRANSACTION</span>; </span><br><span class="line"><span class="keyword">select</span> *  <span class="keyword">from</span> t2 <span class="keyword">where</span>  <span class="keyword">id</span>=<span class="number">8</span>  <span class="keyword">for</span> <span class="keyword">update</span> ;</span><br></pre></td></tr></table></figure><ul><li>没有主键等于8的记录，所以是间隙锁，不会互斥</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事务1</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">TRANSACTION</span>; </span><br><span class="line"><span class="keyword">select</span> *  <span class="keyword">from</span> t2 <span class="keyword">where</span>  <span class="keyword">id</span>=<span class="number">8</span>  <span class="keyword">for</span> <span class="keyword">update</span> ;</span><br><span class="line"><span class="comment"># 事务2</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">TRANSACTION</span>; </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">VALUES</span>(<span class="number">8</span>,<span class="number">8</span>);</span><br></pre></td></tr></table></figure><ul><li>没有主键等于8的记录，间隙(7,10)，会互斥</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事务1</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">TRANSACTION</span>; </span><br><span class="line"><span class="keyword">select</span> *  <span class="keyword">from</span> t2 <span class="keyword">where</span>  <span class="keyword">id</span>=<span class="number">8</span>  <span class="keyword">for</span> <span class="keyword">update</span> ;</span><br><span class="line"><span class="comment"># 事务2</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">TRANSACTION</span>; </span><br><span class="line"><span class="keyword">update</span> t2 <span class="keyword">set</span> k=<span class="number">8</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">8</span></span><br></pre></td></tr></table></figure><ul><li>没有主键等于8的记录，间隙(7,10)，不会互斥，具体原因不清楚</li></ul><h1 id="refenerence"><a href="#refenerence" class="headerlink" title="refenerence"></a>refenerence</h1><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html</a></p>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> db </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2一条SQL更新语句是如何执行的</title>
      <link href="/2019/03/11/aa_category/db/mysql/mysql%E5%AE%9E%E6%88%98/2%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/"/>
      <url>/2019/03/11/aa_category/db/mysql/mysql%E5%AE%9E%E6%88%98/2%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="summarize"><a href="#summarize" class="headerlink" title="summarize"></a>summarize</h1><h1 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h1><ul><li>Write-Ahead Logging，先写日志，再写磁盘</li><li>先写日志，更新内存，当系统比较清闲的时候，写入磁盘</li><li>write pos 是当前记录的位置</li><li>chekpoint 是当前要擦出的位置</li><li>write pos 到chekpoint 之间的位置是可以记录的空间</li><li>crash-safe</li></ul><a id="more"></a><p><img src="http://liyong.ac.cn/pic/1547038695475.png" alt="1547038695475"></p><h1 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h1><h2 id="和redo-log区别"><a href="#和redo-log区别" class="headerlink" title="和redo log区别"></a>和redo log区别</h2><ul><li>redo log 是物理日志，binlog是逻辑日志</li><li>redo log是循环写的，binglog是追加的</li></ul><h1 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h1><p><img src="http://liyong.ac.cn/pic/1547039570226.png" alt="1547039570226"></p><h1 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h1>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> db </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>30Java虚拟机的监控及诊断工具</title>
      <link href="/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/30-31Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/"/>
      <url>/2019/03/11/aa_category/se/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/30-31Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h1><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jps.html#CHDCGECD" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jps.html#CHDCGECD</a></p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jps -mlv</span><br><span class="line">18331 org.example.Foo Hello World</span><br><span class="line">18332 jdk.jcmd/sun.tools.jps.Jps -mlv -Dapplication.home=/Library/Java/JavaVirtualMachines/jdk-11.jdk/Contents/Home -Xms8m -Djdk.module.main=jdk.jcmd</span><br></pre></td></tr></table></figure><h1 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> $ jstat -options</span><br><span class="line">-class</span><br><span class="line">-compiler</span><br><span class="line">-gc</span><br><span class="line">-gccapacity</span><br><span class="line">-gccause</span><br><span class="line">-gcmetacapacity</span><br><span class="line">-gcnew</span><br><span class="line">-gcnewcapacity</span><br><span class="line">-gcold</span><br><span class="line">-gcoldcapacity</span><br><span class="line">-gcutil</span><br><span class="line">-printcompilation</span><br></pre></td></tr></table></figure><p>使用 G1 GC 时，Java 虚拟机不再设置 Eden 区、Survivor 区，老年代区的内存边界，而是将堆划分为若干个等长内存区域。</p><p>每个内存区域都可以作为 Eden 区、Survivor 区以及老年代区中的任一种，并且可以在不同区域类型之间来回切换。(<a href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html</a>)</p><h1 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h1><h1 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo -flag +HeapDumpAfterFullGC <span class="tag">&lt;<span class="name">pid</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h1><h1 id="jcmd"><a href="#jcmd" class="headerlink" title="jcmd"></a>jcmd</h1><p>需要重点关注</p><h1 id="eclipse-MAT"><a href="#eclipse-MAT" class="headerlink" title="eclipse MAT"></a>eclipse MAT</h1><h1 id="Java-Mission-Control"><a href="#Java-Mission-Control" class="headerlink" title="Java Mission Control"></a>Java Mission Control</h1><h1 id="JITWatch"><a href="#JITWatch" class="headerlink" title="JITWatch"></a>JITWatch</h1>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>架构演进之路-网关</title>
      <link href="/2019/02/01/aa_category/methodology/%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF-%E7%BD%91%E5%85%B3/"/>
      <url>/2019/02/01/aa_category/methodology/%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF-%E7%BD%91%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><ul><li>请求鉴权</li><li>数据完整性检查</li><li>协议转换</li><li>路由转发</li><li>服务治理(限流/熔断)</li></ul><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ul><li><p>newsql</p></li><li><p>tidb</p></li><li><p><a href="https://pingcap.com/docs-cn/" target="_blank" rel="noopener">https://pingcap.com/docs-cn/</a></p></li><li><p><a href="https://github.com/CodisLabs/codis" target="_blank" rel="noopener">https://github.com/CodisLabs/codis</a></p></li><li><p>同步转异步架构通过mq</p></li><li><p>读不能用异步</p></li><li><p>写可以异步</p></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> standard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> standard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13线性排序：如何根据年龄给100万用户数据排序</title>
      <link href="/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/13%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F%EF%BC%9A%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E5%B9%B4%E9%BE%84%E7%BB%99100%E4%B8%87%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/13%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F%EF%BC%9A%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E5%B9%B4%E9%BE%84%E7%BB%99100%E4%B8%87%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="桶排序（Bucket-sort）"><a href="#桶排序（Bucket-sort）" class="headerlink" title="桶排序（Bucket sort）"></a>桶排序（Bucket sort）</h1><p>首先，我们来看桶排序。桶排序，顾名思义，会用到“桶”，核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了</p><a id="more"></a><p><img src="http://liyong.ac.cn/pic/987564607b864255f81686829503abae.jpg" alt></p><p><strong>桶排序比较适合用在外部排序中</strong>。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中</p><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><ul><li>要排序的数据需要很容易就能划分成 m 个桶</li><li>桶与桶之间有着天然的大小顺序</li></ul><h1 id="计数排序（Counting-sort）"><a href="#计数排序（Counting-sort）" class="headerlink" title="计数排序（Counting sort）"></a>计数排序（Counting sort）</h1><p>假设只有 8 个考生，分数在 0 到 5 分之间。这 8 个考生的成绩我们放在一个数组 A[8] 中，它们分别是：2，5，3，0，2，3，0，3</p><p>考生的成绩从 0 到 5 分，我们使用大小为 6 的数组 C[6] 表示桶，其中下标对应分数。不过，C[6] 内存储的并不是考生，而是对应的考生个数。像我刚刚举的那个例子，我们只需要遍历一遍考生分数，就可以得到 C[6] 的值。</p><p><img src="http://liyong.ac.cn/pic/adc75672ef33fa54b023a040834fcbc9.jpg" alt></p><p><img src="http://liyong.ac.cn/pic/361f4d781d2a2d144dcbbbb0b9e6db29.jpg" alt></p><p><img src="http://liyong.ac.cn/pic/dd6c62b12b0dc1b3a294af0fa1ce371f.jpg" alt></p><p><img src="http://liyong.ac.cn/pic/1d730cb17249f8e92ef5cab53ae65784.jpg" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统计最大的值</span></span><br><span class="line"><span class="comment"> * 申请数组c[max+1]</span></span><br><span class="line"><span class="comment"> * 记录每个元素出现的次数</span></span><br><span class="line"><span class="comment"> * 累计每个元素出现的次数</span></span><br><span class="line"><span class="comment"> * 申请数组t[n]</span></span><br><span class="line"><span class="comment"> * 数组a复制给t</span></span><br><span class="line"><span class="comment"> * 计算</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &gt; max) &#123;</span><br><span class="line">      max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    c[a[i]]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; c.length; i++) &#123;</span><br><span class="line">    c[i] = c[i] + c[i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span>[] t = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line"></span><br><span class="line">  System.arraycopy(a, <span class="number">0</span>, t, <span class="number">0</span>, a.length);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = t.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">int</span> aValue = t[i];</span><br><span class="line">    <span class="keyword">int</span> index = c[aValue] - <span class="number">1</span>;</span><br><span class="line">    a[index] = aValue;</span><br><span class="line">    c[aValue]--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基数排序（Radix-sort）"><a href="#基数排序（Radix-sort）" class="headerlink" title="基数排序（Radix sort）"></a>基数排序（Radix sort）</h1>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21-22哈希算法</title>
      <link href="/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/21-22%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
      <url>/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/21-22%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是哈希算法"><a href="#什么是哈希算法" class="headerlink" title="什么是哈希算法"></a>什么是哈希算法</h1><ul><li>从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）</li><li>对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同</li><li>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小</li></ul><a id="more"></a><ul><li>安全加密<ul><li>鸽巢原理，如果有 10 个鸽巢，有 11 只鸽子，那肯定有 1 个鸽巢中的鸽子数量多于 1 个</li></ul></li><li>唯一标识</li><li>数据校验</li><li>散列函数</li><li>负载均衡</li><li>数据分片</li><li>分布式存储</li></ul>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20散列表（下）：为什么散列表和链表经常会一起使用</title>
      <link href="/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/20%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%A3%E5%88%97%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%BB%8F%E5%B8%B8%E4%BC%9A%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/20%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%A3%E5%88%97%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%BB%8F%E5%B8%B8%E4%BC%9A%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。也就说，它无法支持按照某种顺序快速地遍历数据。如果希望按照顺序遍历散列表中的数据，那我们需要将散列表中的数据拷贝到数组中，然后排序，再遍历</p><a id="more"></a><p>因为散列表是动态数据结构，不停地有数据的插入、删除，所以每当我们希望按顺序遍历散列表中的数据的时候，都需要先排序，那效率势必会很低。为了解决这个问题，我们将散列表和链表（或者跳表）结合在一起使用</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17跳表：为什么Redis一定要用跳表来实现有序集合</title>
      <link href="/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/17%E8%B7%B3%E8%A1%A8%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E4%B8%80%E5%AE%9A%E8%A6%81%E7%94%A8%E8%B7%B3%E8%A1%A8%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/"/>
      <url>/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/17%E8%B7%B3%E8%A1%A8%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E4%B8%80%E5%AE%9A%E8%A6%81%E7%94%A8%E8%B7%B3%E8%A1%A8%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="理解调表"><a href="#理解调表" class="headerlink" title="理解调表"></a>理解调表</h1><p><strong>种链表加多级索引的结构，就是跳表</strong></p><p><img src="http://liyong.ac.cn/pic/e18303fcedc068e5a168de04df956f6d.jpg" alt></p><a id="more"></a><p><img src="http://liyong.ac.cn/pic/14753c824a5ee4a976ea799727adc78e.jpg" alt></p><p><img src="http://liyong.ac.cn/pic/46d283cd82c987153b3fe0c76dfba8a9.jpg" alt></p><h1 id="用跳表查询到底有多快"><a href="#用跳表查询到底有多快" class="headerlink" title="用跳表查询到底有多快"></a>用跳表查询到底有多快</h1><p>每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是 n/2，第二级索引的结点个数大约就是 n/4，第三级索引的结点个数大约就是 n/8，依次类推，也就是说，<strong>第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那第 k级索引结点的个数就是 n/(2^k)</strong></p><p>设索引有 h 级，最高级的索引有 2 个结点。通过上面的公式，我们可以得到 n/(2h)=2，从而求得 h=log2n-1。如果包含原始链表这一层，整个跳表的高度就是 log2n。我们在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 O(m*logn)</p><p>跳表中查询任意数据的时间复杂度就是 O(logn)</p><h1 id="跳表是不是很浪费内存"><a href="#跳表是不是很浪费内存" class="headerlink" title="跳表是不是很浪费内存"></a>跳表是不是很浪费内存</h1><p>n/2+n/4+n/8…+8+4+2=n-2</p><p>n/3+n/9+n/27+…+9+3+1=n/2</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19散列表：如何打造一个工业级水平的散列表</title>
      <link href="/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/19%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%9A%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E5%B7%A5%E4%B8%9A%E7%BA%A7%E6%B0%B4%E5%B9%B3%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8/"/>
      <url>/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/19%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%9A%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E5%B7%A5%E4%B8%9A%E7%BA%A7%E6%B0%B4%E5%B9%B3%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="如何设计散列函数"><a href="#如何设计散列函数" class="headerlink" title="如何设计散列函数"></a>如何设计散列函数</h1><ul><li>散列函数的设计不能太复杂。过于复杂的散列函数，势必会消耗很多计算时间，也就间接的影响到散列表的性能</li><li>散列函数生成的值要尽可能随机并且均匀分布，这样才能避免或者最小化散列冲突</li></ul><a id="more"></a><h1 id="装载因子过大了怎么办"><a href="#装载因子过大了怎么办" class="headerlink" title="装载因子过大了怎么办"></a>装载因子过大了怎么办</h1><p> 当装载因子过大时，我们也可以进行动态扩容，重新申请一个更大的散列表，将数据搬移到这个新散列表中。假设每次扩容我们都申请一个原来散列表大小两倍的空间</p><h1 id="如何避免低效地扩容"><a href="#如何避免低效地扩容" class="headerlink" title="如何避免低效地扩容"></a>如何避免低效地扩容</h1><p>为了解决一次性扩容耗时过多的情况，我们可以将扩容操作穿插在插入操作的过程中，分批完成。当装载因子触达阈值之后，我们只申请新空间，但并不将老的数据搬移到新散列表中。</p><p>当有新数据要插入时，我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，我们都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。</p><p>这期间的查询操作怎么来做呢？对于查询操作，为了兼容了新、老散列表中的数据，我们先从新散列表中查找，如果没有找到，再去老的散列表中查找</p><h1 id="如何选择冲突解决方法"><a href="#如何选择冲突解决方法" class="headerlink" title="如何选择冲突解决方法"></a>如何选择冲突解决方法</h1><h2 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h2><p>当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的ThreadLocalMap使用开放寻址法解决散列冲突的原因</p><h2 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h2><p>开放寻址法只能适用装载因子小于 1 的情况。接近 1 时，就可能会有大量的散列冲突，导致大量的探测、再散列等，性能会下降很多。但是对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成 10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多</p><p>链表因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，还有可能会让内存的消耗翻倍。而且，因为链表中的结点是零散分布在内存中的，不是连续的，所以对 CPU 缓存是不友好的</p><p>基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。</p><h1 id="工业级散列表举例分析"><a href="#工业级散列表举例分析" class="headerlink" title="工业级散列表举例分析"></a>工业级散列表举例分析</h1><ul><li>初始大小</li><li>装载因子和动态扩容</li><li>散列冲突解决方法</li><li>散列函数</li></ul>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>24二叉树基础：有了如此高效的散列表，为什么还需要二叉树</title>
      <link href="/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/24%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%9C%89%E4%BA%86%E5%A6%82%E6%AD%A4%E9%AB%98%E6%95%88%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/24%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%9C%89%E4%BA%86%E5%A6%82%E6%AD%A4%E9%AB%98%E6%95%88%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉查找树（Binary-Search-Tree）"><a href="#二叉查找树（Binary-Search-Tree）" class="headerlink" title="二叉查找树（Binary Search Tree）"></a>二叉查找树（Binary Search Tree）</h1><p> 二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值</p><a id="more"></a><h1 id="二叉查找树的插入操作"><a href="#二叉查找树的插入操作" class="headerlink" title="二叉查找树的插入操作"></a>二叉查找树的插入操作</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inset</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tree == <span class="keyword">null</span>) &#123;</span><br><span class="line">    tree = <span class="keyword">new</span> Node(data);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Node p = tree;</span><br><span class="line">  <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p.data &gt; data) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        p.left = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p = p.left;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (p.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        p.right = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p = p.right;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉查找树的查找操作"><a href="#二叉查找树的查找操作" class="headerlink" title="二叉查找树的查找操作"></a>二叉查找树的查找操作</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">find</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">  Node node = tree;</span><br><span class="line">  <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.data == data) &#123;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.data &gt; data) &#123;</span><br><span class="line">      node = node.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.data &lt; data) &#123;</span><br><span class="line">      node = node.right;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉查找树的删除操作"><a href="#二叉查找树的删除操作" class="headerlink" title="二叉查找树的删除操作"></a>二叉查找树的删除操作</h1><ul><li>如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为 null</li><li>如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了</li><li>如果要删除的节点有两个子节点，这就比较复杂了。我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点</li></ul><p><img src="http://liyong.ac.cn/pic/299c615bc2e00dc32225f4d9e3490e2c.jpg" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">  Node p = tree;</span><br><span class="line">  Node pp = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.data != data) &#123;</span><br><span class="line">    pp = p;</span><br><span class="line">    <span class="keyword">if</span> (p.data &gt; data) &#123;</span><br><span class="line">      p = p.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      p = p.right;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Node minP = p.right;</span><br><span class="line">    Node minPP = p;</span><br><span class="line">    <span class="keyword">while</span> (minP.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">      minPP = minP;</span><br><span class="line">      minP = minP.left;</span><br><span class="line">    &#125;</span><br><span class="line">    p.data = minP.data;</span><br><span class="line">    pp = minPP;</span><br><span class="line">    p = minP;</span><br><span class="line">  &#125;</span><br><span class="line">  Node child = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">    child = p.left;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">    child = p.right;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    child = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (pp == <span class="keyword">null</span>) &#123;</span><br><span class="line">    tree = <span class="keyword">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p) &#123;</span><br><span class="line">    pp.left = child;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p) &#123;</span><br><span class="line">    pp.right = child;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉查找树的其他操作"><a href="#二叉查找树的其他操作" class="headerlink" title="二叉查找树的其他操作"></a>二叉查找树的其他操作</h1><ul><li>查找最大节点</li><li>查找最小节点</li><li>查找前驱节点</li><li>查找后继节点</li><li><strong>中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效</strong>。因此，二叉查找树也叫作二叉排序树。</li></ul><h1 id="支持重复数据的二叉查找树"><a href="#支持重复数据的二叉查找树" class="headerlink" title="支持重复数据的二叉查找树"></a>支持重复数据的二叉查找树</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>二叉查找树中每一个节点不仅会存储一个数据，通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止</p><h1 id="二叉查找树的时间复杂度分析"><a href="#二叉查找树的时间复杂度分析" class="headerlink" title="二叉查找树的时间复杂度分析"></a>二叉查找树的时间复杂度分析</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n &gt;= 1+2+4+8+...+2^(L-2)+1</span><br><span class="line">n &lt;= 1+2+4+8+...+2^(L-2)+2^(L-1)</span><br></pre></td></tr></table></figure><h1 id="有了散列表为什么还有二叉树"><a href="#有了散列表为什么还有二叉树" class="headerlink" title="有了散列表为什么还有二叉树"></a>有了散列表为什么还有二叉树</h1><ul><li>散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序</li><li>列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定</li><li>笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小</li><li>散列表的构造比二叉查找树要复杂，需要考虑的东西很多</li></ul>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18散列表：Word文档中的单词拼写检查功能是如何实现的</title>
      <link href="/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/18%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%9AWord%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%8B%BC%E5%86%99%E6%A3%80%E6%9F%A5%E5%8A%9F%E8%83%BD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/"/>
      <url>/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/18%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%9AWord%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%8B%BC%E5%86%99%E6%A3%80%E6%9F%A5%E5%8A%9F%E8%83%BD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="散列思想"><a href="#散列思想" class="headerlink" title="散列思想"></a>散列思想</h1><ul><li>散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表</li><li>散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性。我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。</li></ul><a id="more"></a><h1 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h1><ul><li>散列函数计算得到的散列值是一个非负整数；</li><li>如果 key1 = key2，那 hash(key1) == hash(key2)</li><li>如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)</li></ul><h1 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h1><h2 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h2><p>如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。那如何重新探测新的位置呢？</p><h3 id="线性探测（Linear-Probing）-开放寻址法"><a href="#线性探测（Linear-Probing）-开放寻址法" class="headerlink" title="线性探测（Linear Probing） 开放寻址法"></a>线性探测（Linear Probing） 开放寻址法</h3><p>往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止</p><p>线性探测法其实存在很大问题。当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。极端情况下，我们可能需要探测整个散列表，所以最坏情况下的时间复杂度为 O(n)。同理，在删除和查找时，也有可能会线性探测整张散列表，才能找到要查找或者删除的数据</p><p>对于开放寻址冲突解决方法，除了线性探测方法之外，还有另外两种比较经典的探测方法，<strong>二次探测</strong>（Quadratic probing）和<strong>双重散列</strong>（Double hashing）</p><h2 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h2><p><img src="http://liyong.ac.cn/pic/a4b77d593e4cb76acb2b0689294ec17f.jpg" alt></p><p>当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是 O(1)。当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。那查找或删除操作的时间复杂度是多少呢</p><p>这两个操作的时间复杂度跟链表的长度 k 成正比，也就是 O(k)。对于散列比较均匀的散列函数来说，理论上讲，k=n/m，其中 n 表示散列中数据的个数，m 表示散列表中“槽”的个数</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>16二分查找：如何快速定位IP对应的省份地址</title>
      <link href="/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/16%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8DIP%E5%AF%B9%E5%BA%94%E7%9A%84%E7%9C%81%E4%BB%BD%E5%9C%B0%E5%9D%80/"/>
      <url>/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/16%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8DIP%E5%AF%B9%E5%BA%94%E7%9A%84%E7%9C%81%E4%BB%BD%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h1 id="查找第一个值等于给定值的元素"><a href="#查找第一个值等于给定值的元素" class="headerlink" title="查找第一个值等于给定值的元素"></a>查找第一个值等于给定值的元素</h1><p><img src="http://liyong.ac.cn/pic/503c572dd0f9d734b55f1bd12765c4f8.jpg" alt></p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> low  = <span class="number">0</span> ;</span><br><span class="line">   <span class="keyword">int</span> high = a.length-<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> middle = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[middle] &gt; data) &#123;</span><br><span class="line">      high = middle - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[middle] &lt; data) &#123;</span><br><span class="line">      low = middle + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (middle == <span class="number">0</span> || a[middle - <span class="number">1</span>] != data) &#123;</span><br><span class="line">        <span class="keyword">return</span> middle;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        high = middle-<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="查找最后一个值等于给定值的元素"><a href="#查找最后一个值等于给定值的元素" class="headerlink" title="查找最后一个值等于给定值的元素"></a>查找最后一个值等于给定值的元素</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = a.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> middle = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[middle] &gt; data) &#123;</span><br><span class="line">      high = middle - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[middle] &lt; data) &#123;</span><br><span class="line">      low = middle + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (middle == a.length - <span class="number">1</span> || a[middle + <span class="number">1</span>] != data) &#123;</span><br><span class="line">        <span class="keyword">return</span> middle;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        low = middle + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="查找第一个大于等于给定值的元素"><a href="#查找第一个大于等于给定值的元素" class="headerlink" title="查找第一个大于等于给定值的元素"></a>查找第一个大于等于给定值的元素</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search4</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = a.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> middle = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[middle] &gt; data) &#123;</span><br><span class="line">      high = middle - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[middle] &lt; data) &#123;</span><br><span class="line">      low = middle + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (middle == a.length - <span class="number">1</span> || a[middle + <span class="number">1</span>] != data) &#123;</span><br><span class="line">        <span class="keyword">return</span> middle;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        low = middle + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="查找第一个大于等于给定值的元素-1"><a href="#查找第一个大于等于给定值的元素-1" class="headerlink" title="查找第一个大于等于给定值的元素"></a>查找第一个大于等于给定值的元素</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = a.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> middle = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[middle] &gt;= data) &#123;</span><br><span class="line">      <span class="keyword">if</span> (middle == <span class="number">0</span> || a[middle - <span class="number">1</span>] &lt; data) &#123;</span><br><span class="line">        <span class="keyword">return</span> middle;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        high = middle - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[middle] &lt; data) &#123;</span><br><span class="line">      low = middle + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="查找最后一个小于等于给定值的元素"><a href="#查找最后一个小于等于给定值的元素" class="headerlink" title="查找最后一个小于等于给定值的元素"></a>查找最后一个小于等于给定值的元素</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search6</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = a.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> middle = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[middle] &gt; data) &#123;</span><br><span class="line">      high = middle - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[middle] &lt;= data) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((middle == a.length - <span class="number">1</span>) || a[middle + <span class="number">1</span>] &gt; data) &#123;</span><br><span class="line">        <span class="keyword">return</span> middle;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        low = middle + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>25-26红黑树</title>
      <link href="/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/25-26%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/25-26%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是“平衡二叉查找树”"><a href="#什么是“平衡二叉查找树”" class="headerlink" title="什么是“平衡二叉查找树”"></a>什么是“平衡二叉查找树”</h1><p>二叉树中任意一个节点的左右子树的高度相差不能大于 1。从这个定义来看，上一节我们讲的完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树。</p><a id="more"></a><h1 id="如何定义一棵“红黑树”？"><a href="#如何定义一棵“红黑树”？" class="headerlink" title="如何定义一棵“红黑树”？"></a>如何定义一棵“红黑树”？</h1><ul><li>根节点是黑色的；</li><li>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；</li><li>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；</li><li>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；</li></ul><p><strong>左旋（rotate left）</strong>、<strong>右旋（rotate right）</strong>。左旋全称其实是叫<strong>围绕某个节点的左旋</strong>，那右旋的全称估计你已经猜到了，就叫<strong>围绕某个节点的右旋</strong>。</p><p><img src="http://liyong.ac.cn/pic/0e37e597737012593a93105ebbf4591e.jpg" alt></p><h1 id="插入操作的平衡调整"><a href="#插入操作的平衡调整" class="headerlink" title="插入操作的平衡调整"></a>插入操作的平衡调整</h1><p><strong>红黑树规定，插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是放在叶子节点上</strong>。所以，关于插入操作的平衡调整，有这样两种特殊情况，但是也都非常好处理。</p><ul><li>如果插入节点的父节点是黑色的，那我们什么都不用做，它仍然满足红黑树的定义。</li><li>如果插入的节点是根节点，那我们直接改变它的颜色，把它变成黑色就可以了。</li></ul><p>除此之外，其他情况都会违背红黑树的定义，于是我们就需要进行调整，调整的过程包含两种基础的操作：<strong>左右旋转</strong>和<strong>改变颜色</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15二分查找：如何用最省内存的方式实现快速查找功能</title>
      <link href="/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/15%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%A6%82%E4%BD%95%E7%94%A8%E6%9C%80%E7%9C%81%E5%86%85%E5%AD%98%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/"/>
      <url>/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/15%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%A6%82%E4%BD%95%E7%94%A8%E6%9C%80%E7%9C%81%E5%86%85%E5%AD%98%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="无处不在的二分思想"><a href="#无处不在的二分思想" class="headerlink" title="无处不在的二分思想"></a>无处不在的二分思想</h1><p>二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为0</p><a id="more"></a><h1 id="O-logn-惊人的查找速度"><a href="#O-logn-惊人的查找速度" class="headerlink" title="O(logn) 惊人的查找速度"></a>O(logn) 惊人的查找速度</h1><h1 id="二分查找的递归与非递归实现"><a href="#二分查找的递归与非递归实现" class="headerlink" title="二分查找的递归与非递归实现"></a>二分查找的递归与非递归实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> high = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">      <span class="keyword">int</span> middle = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (a[middle] == data) &#123;</span><br><span class="line">        <span class="keyword">return</span> middle;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[middle] &gt; data) &#123;</span><br><span class="line">        high = middle - <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        low = middle + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="1-循环退出条件"><a href="#1-循环退出条件" class="headerlink" title="1. 循环退出条件"></a>1. 循环退出条件</h2><p>注意是 low&lt;=high，而不是 low&lt;high</p><h2 id="2-mid-的取值"><a href="#2-mid-的取值" class="headerlink" title="2.mid 的取值"></a>2.mid 的取值</h2><p>mid=(low+high)/2 这种写法是有问题的。因为如果 low 和 high 比较大的话，两者之和就有可能会溢出</p><h2 id="3-low-和-high-的更新"><a href="#3-low-和-high-的更新" class="headerlink" title="3.low 和 high 的更新"></a>3.low 和 high 的更新</h2><p>low=mid+1，high=mid-1。注意这里的 +1 和 -1，如果直接写成 low=mid 或者 high=mid，就可能会发生死循环。比如，当 high=3，low=3 时，如果 a[3] 不等于 value，就会导致一直循环不退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> searchInternally(a, <span class="number">0</span>, a.length - <span class="number">1</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInternally</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> middle = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[middle] == data) &#123;</span><br><span class="line">      <span class="keyword">return</span> middle;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[middle] &gt; data) &#123;</span><br><span class="line">      <span class="keyword">return</span> searchInternally(a, low, middle - <span class="number">1</span>, data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> searchInternally(a, middle + <span class="number">1</span>, high, data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分查找应用场景的局限性"><a href="#二分查找应用场景的局限性" class="headerlink" title="二分查找应用场景的局限性"></a>二分查找应用场景的局限性</h1><ul><li><p>二分查找依赖的是顺序表结构，简单点说就是数组</p><ul><li>二分查找能否依赖其他数据结构呢？比如链表。答案是不可以的，主要原因是二分查找算法需要按照下标随机访问元</li></ul></li><li><p>二分查找针对的是有序数据</p></li><li><p>数据量太小不适合二分查找</p></li><li><p>数据量太大也不适合二分查找</p><ul><li>二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>27递归树：如何借助树来求解递归算法的时间复杂度</title>
      <link href="/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/27%E9%80%92%E5%BD%92%E6%A0%91%EF%BC%9A%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9%E6%A0%91%E6%9D%A5%E6%B1%82%E8%A7%A3%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/27%E9%80%92%E5%BD%92%E6%A0%91%EF%BC%9A%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9%E6%A0%91%E6%9D%A5%E6%B1%82%E8%A7%A3%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14序优化：如何实现一个通用的、高性能的排序函数</title>
      <link href="/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/14%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E3%80%81%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0/"/>
      <url>/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/14%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E3%80%81%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="如何选择合适的排序算法？"><a href="#如何选择合适的排序算法？" class="headerlink" title="如何选择合适的排序算法？"></a>如何选择合适的排序算法？</h1><p><img src="http://liyong.ac.cn/pic/1f6ef7e0a5365d6e9d68f0ccc71755fd.jpg" alt></p><a id="more"></a><h1 id="如何优化快速排序"><a href="#如何优化快速排序" class="headerlink" title="如何优化快速排序?"></a>如何优化快速排序?</h1><ul><li>这种 O(n2) 时间复杂度出现的主要原因还是因为我们分区点选的不够合理</li><li>最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多</li></ul><h2 id="三数取中法"><a href="#三数取中法" class="headerlink" title="三数取中法"></a>三数取中法</h2><p>我们从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点</p><h2 id="随机法"><a href="#随机法" class="headerlink" title="随机法"></a>随机法</h2><h1 id="举例分析排序函数qsort"><a href="#举例分析排序函数qsort" class="headerlink" title="举例分析排序函数qsort"></a>举例分析排序函数qsort</h1><ul><li>数据量小使用归并排序来排序输入数据</li><li>要排序的数据量比较大的时候，qsort() 会改为用快速排序算法来排序</li><li>元素的个数小于等于 4 时，qsort() 就退化为插入排序</li><li>O(n2) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长</li></ul>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>28-29堆和堆排序</title>
      <link href="/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/28-29%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/28-29%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="如何理解“堆”"><a href="#如何理解“堆”" class="headerlink" title="如何理解“堆”"></a>如何理解“堆”</h1><ul><li>堆是一个完全二叉树；</li><li>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。</li><li>每个节点的值都大于等于子树中每个节点值的堆，我们叫作“大顶堆”</li><li>对于每个节点的值都小于等于子树中每个节点值的堆，我们叫作“小顶堆</li></ul><a id="more"></a><h1 id="如何实现一个堆"><a href="#如何实现一个堆" class="headerlink" title="如何实现一个堆"></a>如何实现一个堆</h1><h2 id="往堆中插入一个元素"><a href="#往堆中插入一个元素" class="headerlink" title="往堆中插入一个元素"></a>往堆中插入一个元素</h2><p><img src="http://liyong.ac.cn/pic/e578654f930002a140ebcf72b11eb722.jpg" alt></p><p><img src="http://liyong.ac.cn/pic/e3744661e038e4ae570316bc862b2c0e.jpg" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (count &gt;= n) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  a[++count] = data;</span><br><span class="line">  <span class="keyword">int</span> i = count;</span><br><span class="line">  <span class="keyword">while</span> (i / <span class="number">2</span> &gt; <span class="number">0</span> &amp;&amp; a[i] &gt; a[i / <span class="number">2</span>]) &#123;</span><br><span class="line">    SortUtil.swap(a, i, i / <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除堆顶元素"><a href="#删除堆顶元素" class="headerlink" title="删除堆顶元素"></a>删除堆顶元素</h2><p><img src="http://liyong.ac.cn/pic/110d6f442e718f86d2a1d16095513260.jpg" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> maxPos = i;</span><br><span class="line">   <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (i * <span class="number">2</span> &lt;= n &amp;&amp; a[i] &lt; a[i * <span class="number">2</span>]) &#123;</span><br><span class="line">       maxPos = i * <span class="number">2</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> ((i * <span class="number">2</span> + <span class="number">1</span>) &lt;= n &amp;&amp; a[maxPos] &lt; a[i * <span class="number">2</span> + <span class="number">1</span>]) &#123;</span><br><span class="line">       maxPos = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (maxPos == i) &#123;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       SortUtil.swap(a, i, maxPos);</span><br><span class="line">       i = maxPos;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (count &lt; <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   a[<span class="number">1</span>] = a[count];</span><br><span class="line">   count--;</span><br><span class="line">   heapify(a, count, <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="如何基于堆实现排序"><a href="#如何基于堆实现排序" class="headerlink" title="如何基于堆实现排序"></a>如何基于堆实现排序</h1><h2 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h2><p><img src="http://liyong.ac.cn/pic/50c1e6bc6fe68378d0a66bdccfff441e.jpg" alt></p><p><img src="http://liyong.ac.cn/pic/aabb8d15b1b92d5e040895589c60419d.jpg" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">    heapify(a, n, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://liyong.ac.cn/pic/899b9f1b40302c9bd5a7f77f042542d5.jpg" alt></p><p><img src="http://liyong.ac.cn/pic/f712f8a7baade44c39edde839cefcc09.jpg" alt></p><p><img src="http://liyong.ac.cn/pic/629328315decd96e349d8cb3940636df.jpg" alt></p><p><img src="http://liyong.ac.cn/pic/46ca25edc69b556b967d2c62388b7436.jpg" alt></p><p> h=log2nh=log2⁡n，代入公式 SS，就能得到 S=O(n)S=O(n)，所以，建堆的时间复杂度就是 O(n)</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    buildHeap(a, n);</span><br><span class="line">    <span class="keyword">int</span> k = n;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      SortUtil.swap(a, <span class="number">1</span>, k);</span><br><span class="line">      k--;</span><br><span class="line">      heapify(a,k,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>建堆过程的时间复杂度是 O(n)，排序过程的时间复杂度是 O(nlogn)，所以，堆排序整体的时间复杂度是 O(nlogn)</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><ul><li>优先级队列</li><li>利用堆求TOP K<ul><li>维护一个大小为 K 的小顶堆，顺序遍历数组，从数组中取出取数据与堆顶元素比较。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理，继续遍历数组</li></ul></li><li>利用堆求中位数<ul><li>维护两个堆，一个大顶堆，一个小顶堆。大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据</li><li>新加入的数据小于等于大顶堆的堆顶元素，我们就将这个新数据插入到大顶堆；如果新加入的数据大于等于小顶堆的堆顶元素，我们就将这个新数据插入到小顶堆</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>30-31图</title>
      <link href="/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/30-31%E5%9B%BE/"/>
      <url>/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/30-31%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="如何理解“图”"><a href="#如何理解“图”" class="headerlink" title="如何理解“图”"></a>如何理解“图”</h1><h2 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h2><ul><li>图中的元素我们就叫作<strong>顶点</strong>（vertex）</li><li>图中的一个顶点可以与任意其他顶点建立连接关系,这种关系叫边</li><li><strong>度</strong>（degree），跟顶点相连接的边的条数。</li></ul><a id="more"></a><p><img src="http://liyong.ac.cn/pic/df85dc345a9726cab0338e68982fd1af.jpg" alt></p><h2 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h2><ul><li>入度，表示有多少条边指向这个顶点</li><li>出度，表示有多少条边是以这个顶点为起点指向其他顶点</li></ul><p><img src="http://liyong.ac.cn/pic/c31759a37d8a8719841f347bd479b796.jpg" alt></p><h2 id="带权图（weighted-graph）"><a href="#带权图（weighted-graph）" class="headerlink" title="带权图（weighted graph）"></a>带权图（weighted graph）</h2><p><img src="http://liyong.ac.cn/pic/55d7e4806dc47950ae098d959b03ace8.jpg" alt></p><h1 id="邻接矩阵存储方法"><a href="#邻接矩阵存储方法" class="headerlink" title="邻接矩阵存储方法"></a>邻接矩阵存储方法</h1><p><img src="http://liyong.ac.cn/pic/625e7493b5470e774b5aa91fb4fdb9d2.jpg" alt></p><ul><li>比较浪费存储空间<ul><li>定点多关系少</li></ul></li><li>存储方式简单，直观</li></ul><h1 id="邻接表存储方法"><a href="#邻接表存储方法" class="headerlink" title="邻接表存储方法"></a>邻接表存储方法</h1><p><img src="http://liyong.ac.cn/pic/039bc254b97bd11670cdc4bf2a8e1394.jpg" alt></p><h1 id="广度优先搜索（Breadth-First-Search）"><a href="#广度优先搜索（Breadth-First-Search）" class="headerlink" title="广度优先搜索（Breadth-First-Search）"></a>广度优先搜索（Breadth-First-Search）</h1><p><img src="http://liyong.ac.cn/pic/002e9e54fb0d4dbf5462226d946fa1ea.jpg" alt></p><ul><li><strong>visited</strong>是用来记录已经被访问的顶点，用来避免顶点被重复访问</li><li><strong>queue</strong>是一个队列，用来存储已经被访问、但相连的顶点还没有被访问的顶点</li><li><strong>prev</strong>用来记录搜索路径</li></ul><p><img src="http://liyong.ac.cn/pic/ea00f376d445225a304de4531dd82723.jpg" alt></p><p><img src="http://liyong.ac.cn/pic/4cd192d4c220cc9ac8049fd3547dba39.jpg" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[v];</span><br><span class="line">  Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="keyword">int</span>[] pre = <span class="keyword">new</span> <span class="keyword">int</span>[v];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; i++) &#123;</span><br><span class="line">    pre[i] = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  queue.add(s);</span><br><span class="line">  visited[s] = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">    Integer p = queue.poll();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[p].size(); i++) &#123;</span><br><span class="line">      Integer w = adj[p].get(i);</span><br><span class="line">      <span class="keyword">if</span> (!visited[w]) &#123;</span><br><span class="line">        pre[w] = p;</span><br><span class="line">        visited[w] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (w == t) &#123;</span><br><span class="line">          print(pre, s, t);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(w);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] prev, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s != t &amp;&amp; prev[t] != -<span class="number">1</span>)&#123;</span><br><span class="line">    print(prev, s, prev[t]);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.print(t+<span class="string">"  "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h1><p><img src="http://liyong.ac.cn/pic/8778201ce6ff7037c0b3f26b83efba85.jpg" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[v];</span><br><span class="line">  <span class="keyword">int</span>[] prev = <span class="keyword">new</span> <span class="keyword">int</span>[v];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; i++) &#123;</span><br><span class="line">    prev[i]=-<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  recurDfs(s, t, visited, prev);</span><br><span class="line">  print(prev, s, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recurDfs</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> t, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span>[] prev)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (found) &#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  visited[w] =<span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (w == t) &#123;</span><br><span class="line">    found = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[w].size(); i++) &#123;</span><br><span class="line">    Integer q = adj[w].get(i);</span><br><span class="line">    <span class="keyword">if</span> (!visited[q]) &#123;</span><br><span class="line">      prev[q] =w;</span><br><span class="line">      recurDfs(q, t, visited, prev);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23 二叉树基础：什么样的二叉树适合用数组来存储</title>
      <link href="/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/23%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%EF%BC%9A%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%82%E5%90%88%E7%94%A8%E6%95%B0%E7%BB%84%E6%9D%A5%E5%AD%98%E5%82%A8/"/>
      <url>/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/23%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%EF%BC%9A%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%82%E5%90%88%E7%94%A8%E6%95%B0%E7%BB%84%E6%9D%A5%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="树（Tree）"><a href="#树（Tree）" class="headerlink" title="树（Tree）"></a>树（Tree）</h1><p><img src="http://liyong.ac.cn/pic/b7043bf29a253bb36221eaec62b2e129.jpg" alt></p><a id="more"></a><p><img src="http://liyong.ac.cn/pic/4094a733986073fedb6b9d03f877d71e.jpg" alt></p><p><img src="http://liyong.ac.cn/pic/50f89510ad1f7570791dd12f4e9adeb4.jpg" alt></p><h1 id="二叉树（Binary-Tree）"><a href="#二叉树（Binary-Tree）" class="headerlink" title="二叉树（Binary Tree）"></a>二叉树（Binary Tree）</h1><p><img src="http://liyong.ac.cn/pic/09c2972d56eb0cf67e727deda0e9412b.jpg" alt></p><p>编号 2 的二叉树中，叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作<strong>满二叉树</strong></p><p>编号 3 的二叉树中，叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫作<strong>完全二叉树</strong></p><h2 id="表示（或者存储）一棵二叉树"><a href="#表示（或者存储）一棵二叉树" class="headerlink" title="表示（或者存储）一棵二叉树"></a>表示（或者存储）一棵二叉树</h2><h3 id="链式存储法"><a href="#链式存储法" class="headerlink" title="链式存储法"></a>链式存储法</h3><h3 id="顺序存储法"><a href="#顺序存储法" class="headerlink" title="顺序存储法"></a>顺序存储法</h3><p>根节点存储在下标 i = 1 的位置，那左子节点存储在下标 2 * i = 2 的位置，右子节点存储在 2 * i + 1 = 3 的位置。以此类推，B 节点的左子节点存储在 2 * i = 2 * 2 = 4 的位置，右子节点存储在 2 * i + 1 = 2 * 2 + 1 = 5 的位置</p><p><img src="http://liyong.ac.cn/pic/14eaa820cb89a17a7303e8847a412330.jpg" alt></p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><ul><li>前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树</li><li>中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树</li><li>印它的右子树。</li><li>后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身</li></ul><p><img src="http://liyong.ac.cn/pic/ab103822e75b5b15c615b68560cb2416.jpg" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.print(node.data + <span class="string">" , "</span>);</span><br><span class="line">  preOrder(node.left);</span><br><span class="line">  preOrder(node.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  inOrder(node.left);</span><br><span class="line">  System.out.print(node.data + <span class="string">" , "</span>);</span><br><span class="line">  inOrder(node.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  postOrder(node.left);</span><br><span class="line">  postOrder(node.right);</span><br><span class="line">  System.out.print(node.data + <span class="string">" , "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12排序：如何用快排思想在O(n)内查找第K大元素</title>
      <link href="/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/12%E6%8E%92%E5%BA%8F%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%E5%BF%AB%E6%8E%92%E6%80%9D%E6%83%B3%E5%9C%A8O(n)%E5%86%85%E6%9F%A5%E6%89%BE%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
      <url>/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/12%E6%8E%92%E5%BA%8F%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%E5%BF%AB%E6%8E%92%E6%80%9D%E6%83%B3%E5%9C%A8O(n)%E5%86%85%E6%9F%A5%E6%89%BE%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h1><p> 归并排序的核心思想还是蛮简单的。如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p><a id="more"></a><p><img src="http://liyong.ac.cn/pic/db7f892d3355ef74da9cd64aa926dc2b.jpg" alt></p><p>你可能已经发现了，merge(A[p…r], A[p…q], A[q+1…r]) 这个函数的作用就是，将已经有序的 A[p…q] 和 A[q+1…r] 合并成一个有序的数组，并且放入 A[p…r]。那这个过程具体该如何做呢？</p><p>如图所示，我们申请一个临时数组 tmp，大小与 A[p…r] 相同。我们用两个游标 i 和 j，分别指向 A[p…q] 和 A[q+1…r] 的第一个元素。比较这两个元素 A[i] 和 A[j]，如果 A[i]&lt;=A[j]，我们就把 A[i] 放入到临时数组 tmp，并且 i 后移一位，否则将 A[j] 放入到数组 tmp，j 后移一位。</p><p>继续上述比较过程，直到其中一个子数组中的所有数据都放入临时数组中，再把另一个数组中的数据依次加入到临时数组的末尾，这个时候，临时数组中存储的就是两个子数组合并之后的结果了。最后再把临时数组 tmp 中的数据拷贝到原数组 A[p…r] 中</p><p><img src="http://liyong.ac.cn/pic/95897ade4f7ad5d10af057b1d144a22f.jpg" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">  doSort(a, temp, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] t, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">    <span class="keyword">int</span> middle = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    doSort(a, t, start, middle);</span><br><span class="line">    doSort(a, t, middle + <span class="number">1</span>, end);</span><br><span class="line">    merge(a, t, start, middle, end);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] t, <span class="keyword">int</span> start, <span class="keyword">int</span> middle, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">  System.arraycopy(a, start, t, start, end - start + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> i = start;</span><br><span class="line">  <span class="keyword">int</span> j = middle + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> k = start;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= middle &amp;&amp; j &lt;= end) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t[i] &gt; t[j]) &#123;</span><br><span class="line">      a[k++] = t[j++];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      a[k++] = t[i++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= middle) &#123;</span><br><span class="line">    a[k++] = t[i++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (j &lt;= end) &#123;</span><br><span class="line">    a[k++] = t[j++];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序的时间复杂度是多少"><a href="#归并排序的时间复杂度是多少" class="headerlink" title="归并排序的时间复杂度是多少"></a>归并排序的时间复杂度是多少</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">T(a) = T(b) + T(c) + K</span><br><span class="line">T(1) = C；   n=1 时，只需要常量级的执行时间，所以表示为 C。</span><br><span class="line">T(n) = 2*T(n/2) + n； n&gt;1</span><br><span class="line">T(n) = 2*T(n/2) + n</span><br><span class="line">     = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n</span><br><span class="line">     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n</span><br><span class="line">     = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n</span><br><span class="line">     ......</span><br><span class="line">     = 2^k * T(n/2^k) + k * n</span><br><span class="line">     ......</span><br><span class="line">     </span><br><span class="line">T(n) = 2^k*T(n/2^k)+k*n</span><br><span class="line">T(n/2^k)=T(1) </span><br><span class="line"> n/2^k=1</span><br><span class="line"> k=log2^n </span><br><span class="line">T(n)=C*n+n*log2^n</span><br><span class="line">T(n) =O(nlogn)</span><br></pre></td></tr></table></figure><h1 id="快速排序的原理"><a href="#快速排序的原理" class="headerlink" title="快速排序的原理"></a>快速排序的原理</h1><p>快排的思想是这样的：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）</p><p>我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的</p><p><img src="http://liyong.ac.cn/pic/4d892c3a2e08a17f16097d07ea088a81.jpg" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">   doSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">     <span class="keyword">int</span> partition = partition(a, start, end);</span><br><span class="line">     doSort(a,start,partition);</span><br><span class="line">     doSort(a, partition + <span class="number">1</span>, end);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> key = a[p];</span><br><span class="line">   <span class="keyword">int</span> start = p;</span><br><span class="line">   <span class="keyword">int</span> end = r;</span><br><span class="line">   <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">     <span class="keyword">while</span> ( start &lt; end&amp;&amp;a[start] &lt;= key) &#123;</span><br><span class="line">       start++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">while</span> ( start &lt; end&amp;&amp; a[end] &gt;= key) &#123;</span><br><span class="line">       end--;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">       SortUtil.swap(a, start, end);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   SortUtil.swap(a, p, end);</span><br><span class="line">   <span class="keyword">return</span> end;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="http://liyong.ac.cn/pic/086002d67995e4769473b3f50dd96de7.jpg" alt></p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p><img src="http://liyong.ac.cn/pic/aa03ae570dace416127c9ccf9db8ac05.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10递归：如何用三行代码找到“最终推荐人”</title>
      <link href="/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/10%E9%80%92%E5%BD%92%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%E4%B8%89%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%89%BE%E5%88%B0%E6%9C%80%E7%BB%88%E6%8E%A8%E8%8D%90%E4%BA%BA/"/>
      <url>/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/10%E9%80%92%E5%BD%92%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%E4%B8%89%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%89%BE%E5%88%B0%E6%9C%80%E7%BB%88%E6%8E%A8%E8%8D%90%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="如何理解“递归”？"><a href="#如何理解“递归”？" class="headerlink" title="如何理解“递归”？"></a>如何理解“递归”？</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n)=f(n-1)+1 其中，f(1)=1</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="递归需要满足的三个条件"><a href="#递归需要满足的三个条件" class="headerlink" title="递归需要满足的三个条件"></a>递归需要满足的三个条件</h1><ul><li>一个问题的解可以分解为几个子问题的解</li><li>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</li><li>存在递归终止条件</li></ul><h1 id="如何编写递归代码"><a href="#如何编写递归代码" class="headerlink" title="如何编写递归代码"></a>如何编写递归代码</h1><ul><li>写出递推公式，找到终止条件</li><li>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码</li><li>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤</li></ul><h1 id="递归注意事项"><a href="#递归注意事项" class="headerlink" title="递归注意事项"></a>递归注意事项</h1><ul><li>递归代码要警惕堆栈溢出</li><li>递归代码要警惕重复计算</li></ul><h1 id="怎么将递归代码改写为非递归代码"><a href="#怎么将递归代码改写为非递归代码" class="headerlink" title="怎么将递归代码改写为非递归代码"></a>怎么将递归代码改写为非递归代码</h1><p>使用迭代循环改成非地柜的写法</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>32-33-34字符串匹配</title>
      <link href="/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/32-33-34%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
      <url>/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/32-33-34%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="BF-算法"><a href="#BF-算法" class="headerlink" title="BF 算法"></a>BF 算法</h1><p>BF 是 Brute Force 的缩写，中文叫作暴力匹配算法，也叫朴素匹配算法</p><p>在主串中，检查起始位置分别是 0、1、2…n-m 且长度为 m 的 n-m+1 个子串，看有没有跟模式串匹配的</p><p>最坏情况时间复杂度是 O(n*m)</p><p><img src="http://liyong.ac.cn/pic/f36fed972a5bdc75331d59c36eb15aa2.jpg" alt="img"></p><h2 id="常用算法的原因"><a href="#常用算法的原因" class="headerlink" title="常用算法的原因"></a>常用算法的原因</h2><ul><li>实际的软件开发中，大部分情况下，模式串和主串的长度都不会太长</li><li>朴素字符串匹配算法思想简单，代码实现也非常简单</li></ul><h1 id="RK-算法"><a href="#RK-算法" class="headerlink" title="RK 算法"></a>RK 算法</h1><p>我们通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了（这里先不考虑哈希冲突的问题）</p><h2 id="提高哈希算法的效率"><a href="#提高哈希算法的效率" class="headerlink" title="提高哈希算法的效率"></a>提高哈希算法的效率</h2><p>比如要处理的字符串只包含 a～z 这 26 个小写字母，那我们就用二十六进制来表示一个字符串。我们把 a～z 这 26 个字符映射到 0～25 这 26 个数字，a 就表示 0，b 就表示 1，以此类推，z 表示 25</p><p><img src="http://liyong.ac.cn/pic/d5c1cb11d9fc97d0b28513ba7495ab04.jpg" alt="img"></p><p><img src="http://liyong.ac.cn/pic/f99c16f2f899d19935567102c59661f5.jpg" alt="img"></p><p><img src="http://liyong.ac.cn/pic/f298f1e5c93b205345b9cd6d9c53fbee.jpg" alt="img"></p><h1 id="BM-算法"><a href="#BM-算法" class="headerlink" title="BM 算法"></a>BM 算法</h1><p>BM 算法包含两部分，分别是<strong>坏字符规则</strong>（bad character rule）和<strong>好后缀规则</strong>（good suffix shift）</p><h2 id="坏字符规则"><a href="#坏字符规则" class="headerlink" title="坏字符规则"></a>坏字符规则</h2><p>BM 算法的匹配顺序比较特别，它是按照模式串下标从大到小的顺序，倒着匹配的</p><p><img src="http://liyong.ac.cn/pic/540809418354024206d9989cb6cdd89e.jpg" alt="img"></p><p>从模式串的末尾往前倒着匹配，当我们发现某个字符没法匹配的时候。我们把这个没有匹配的字符叫作<strong>坏字符</strong>（主串中的字符）</p><p>拿坏字符 c 在模式串中查找，发现模式串中并不存在这个字符，也就是说，字符 c 与模式串中的任何字符都不可能匹配。这个时候，我们可以将模式串直接往后滑动三位，将模式串滑动到 c 后面的位置，再从模式串的末尾字符开始比较。</p><p><img src="https://static001.geekbang.org/resource/image/4e/64/4e36c4d48d1b6c3b499fb021f03c7f64.jpg" alt="img"></p><p>模式串中最后一个字符 d，还是无法跟主串中的 a 匹配，这个时候，还能将模式串往后滑动三位吗？答案是不行的。因为这个时候，坏字符 a 在模式串中是存在的，模式串中下标是 0 的位置也是字符 a。这种情况下，我们可以将模式串往后滑动两位，让两个 a 上下对齐，然后再从模式串的末尾字符开始，重新匹配</p><p><img src="http://liyong.ac.cn/pic/a8d229aa217a67051fbb31b8aeb2edca.jpg" alt="img"></p><p>当发生不匹配的时候，我们把坏字符对应的模式串中的字符下标记作 si。如果坏字符在模式串中存在，我们把这个坏字符在模式串中的下标记作 xi。如果不存在，我们把 xi 记作 -1。那模式串往后移动的位数就等于 si-xi</p><p><img src="http://liyong.ac.cn/pic/8f520fb9d9cec0f6ea641d4181eb432e.jpg" alt="img"></p><h2 id="好后缀规则"><a href="#好后缀规则" class="headerlink" title="好后缀规则"></a>好后缀规则</h2><p>已经匹配的 bc 叫作好后缀，记作{u}。我们拿它在模式串中查找，如果找到了另一个跟{u}相匹配的子串{u<em>}，那我们就将模式串滑动到子串{u</em>}与主串中{u}对齐的位置</p><p><img src="http://liyong.ac.cn/pic/b9785be3e91e34bbc23961f67c234b63.jpg" alt="img"></p><p>如果在模式串中找不到另一个等于{u}的子串，就直接将模式串，滑动到主串中{u}的后面，因为之前的任何一次往后滑动，都没有匹配主串中{u}的情况</p><p><img src="http://liyong.ac.cn/pic/de97c461b9b9dbc42d35768db59908cd.jpg" alt="img"></p><p>当模式串中不存在等于{u}的子串时，我们直接将模式串滑动到主串{u}的后面。这样做是否有点太过头呢?</p><p><img src="http://liyong.ac.cn/pic/9b3fa3d1cd9c0d0f914a9b1f518ad070.jpg" alt="img"></p><p>如果好后缀在模式串中不存在可匹配的子串，那在我们一步一步往后滑动模式串的过程中，只要主串中的{u}与模式串有重合，那肯定就无法完全匹配。但是当模式串滑动到前缀与主串中{u}的后缀有部分重合的时候，并且重合的部分相等的时候，就有可能会存在完全匹配的情况</p><p><img src="http://liyong.ac.cn/pic/0544d2997d8bb57c10e13ccac4015e23.jpg" alt="img"></p><p>要考察好后缀的后缀子串，是否存在跟模式串的前缀子串匹配的。所谓某个字符串 s 的后缀子串，就是最后一个字符跟 s 对齐的子串，比如 abc 的后缀子串就包括 c, bc</p><p><img src="http://liyong.ac.cn/pic/6caa0f61387fd2b3109fe03d803192f9.jpg" alt="img"></p><p>当模式串和主串中的某个字符不匹配的时候，如何选择用好后缀规则还是坏字符规则</p><h2 id="BM-算法代码实现"><a href="#BM-算法代码实现" class="headerlink" title="BM 算法代码实现"></a>BM 算法代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateBC</span><span class="params">(<span class="keyword">char</span>[] b, <span class="keyword">int</span> m, <span class="keyword">int</span>[] bc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">    bc[i] = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    bc[(<span class="keyword">int</span>) b[i]] = i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bm</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] bc = <span class="keyword">new</span> <span class="keyword">int</span>[SIZE];</span><br><span class="line">  generateBC(b, m, bc);</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= n - m) &#123;</span><br><span class="line">    <span class="keyword">int</span> j ;</span><br><span class="line">    <span class="keyword">for</span> ( j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[i + j] != b[j]) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    i = i+(j-bc[(<span class="keyword">int</span>)a[i+j]]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  a,b 表示主串和模式串；n，m 表示主串和模式串的长度。</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bm2</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] bc = <span class="keyword">new</span> <span class="keyword">int</span>[SIZE]; <span class="comment">// 记录模式串中每个字符最后出现的位置</span></span><br><span class="line">    generateBC(b, m, bc); <span class="comment">// 构建坏字符哈希表</span></span><br><span class="line">    <span class="keyword">int</span>[] suffix = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">    <span class="keyword">boolean</span>[] prefix = <span class="keyword">new</span> <span class="keyword">boolean</span>[m];</span><br><span class="line">    generateGS(b, m, suffix, prefix);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// j 表示主串与模式串匹配的第一个字符</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n - m) &#123;</span><br><span class="line">      <span class="keyword">int</span> j;</span><br><span class="line">      <span class="keyword">for</span> (j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123; <span class="comment">// 模式串从后往前匹配</span></span><br><span class="line">        <span class="keyword">if</span> (a[i+j] != b[j]) <span class="keyword">break</span>; <span class="comment">// 坏字符对应模式串中的下标是 j</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> i; <span class="comment">// 匹配成功，返回主串与模式串第一个匹配的字符的位置</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> x = j - bc[(<span class="keyword">int</span>)a[i+j]];</span><br><span class="line">      <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (j &lt; m-<span class="number">1</span>) &#123; <span class="comment">// 如果有好后缀的话</span></span><br><span class="line">        y = moveByGS(j, m, suffix, prefix);</span><br><span class="line">      &#125;</span><br><span class="line">      i = i + Math.max(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// j 表示坏字符对应的模式串中的字符下标 ; m 表示模式串长度</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">moveByGS</span><span class="params">(<span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span>[] suffix, <span class="keyword">boolean</span>[] prefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = m - <span class="number">1</span> - j; <span class="comment">// 好后缀长度</span></span><br><span class="line">    <span class="keyword">if</span> (suffix[k] != -<span class="number">1</span>) <span class="keyword">return</span> j - suffix[k] +<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = j+<span class="number">2</span>; r &lt;= m-<span class="number">1</span>; ++r) &#123;</span><br><span class="line">      <span class="keyword">if</span> (prefix[m-r] == <span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p>KMP 算法也可以提前构建一个数组，用来存储模式串中每个前缀的最长可匹配前缀子串的结尾字符下标</p><p><a href="https://www.zhihu.com/question/21923021" target="_blank" rel="noopener">https://www.zhihu.com/question/21923021</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习指导手册</title>
      <link href="/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/35Trie%E6%A0%91/"/>
      <url>/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/35Trie%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是“Trie-树"><a href="#什么是“Trie-树" class="headerlink" title="什么是“Trie 树"></a>什么是“Trie 树</h1><ul><li>Trie 树，也叫“字典树”。它是一种专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题</li><li>Trie 树比较适合的是查找前缀匹配的字符串</li></ul><a id="more"></a><p>how，hi，her，hello，so，see</p><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p><img src="http://liyong.ac.cn/pic/f848a7d8bda3d4f8bb4a7cbfaabab66c.jpg" alt="img"></p><p><img src="http://liyong.ac.cn/pic/06b45fde2ca8077465e0c557bc749ab6.jpg" alt="img"></p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>查找字符串“her”，那我们将要查找的字符串分割成单个的字符 h，e，r，然后从 Trie 树的根节点开始匹配。如图所示，绿色的路径就是在 Trie 树中匹配的路径。</p><p><img src="http://liyong.ac.cn/pic/6dbed0579a60c6d170bd8fde5990bfb9.jpg" alt="img"></p><h1 id="如何实现一棵-Trie-树"><a href="#如何实现一棵-Trie-树" class="headerlink" title="如何实现一棵 Trie 树"></a>如何实现一棵 Trie 树</h1><p><img src="http://liyong.ac.cn/pic/f5a4a9cb7f0fe9dcfbf29eb1e5da6d35.jpg" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TrieTree tree = <span class="keyword">new</span> TrieTree();</span><br><span class="line"><span class="comment">//    hello、her、hi、how、so、see</span></span><br><span class="line">    tree.insert(<span class="string">"hello"</span>.toCharArray());</span><br><span class="line">    tree.insert(<span class="string">"hello"</span>.toCharArray());</span><br><span class="line">    tree.insert(<span class="string">"her"</span>.toCharArray());</span><br><span class="line">    tree.insert(<span class="string">"hi"</span>.toCharArray());</span><br><span class="line">    tree.insert(<span class="string">"how"</span>.toCharArray());</span><br><span class="line">    tree.insert(<span class="string">"so"</span>.toCharArray());</span><br><span class="line">    tree.insert(<span class="string">"see"</span>.toCharArray());</span><br><span class="line">    System.out.println(tree.find(<span class="string">"se"</span>.toCharArray()));</span><br><span class="line">    System.out.println(tree.find(<span class="string">"see"</span>.toCharArray()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> TrieNode root = <span class="keyword">new</span> TrieNode(<span class="string">'/'</span>); <span class="comment">// 存储无意义字符</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span>[] text)</span> </span>&#123;</span><br><span class="line">    TrieNode p= root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : text) &#123;</span><br><span class="line">      <span class="keyword">int</span> index = c - <span class="string">'a'</span>;</span><br><span class="line">      <span class="keyword">if</span> (p.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        TrieNode trieNode = <span class="keyword">new</span> TrieNode(c);</span><br><span class="line">        p.children[index]= trieNode;</span><br><span class="line">      &#125;</span><br><span class="line">      p = p.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    p.isEndingChar = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在 Trie 树中查找一个字符串</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span>[] pattern)</span> </span>&#123;</span><br><span class="line">    TrieNode p  = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : pattern) &#123;</span><br><span class="line">      <span class="keyword">int</span> index = c - <span class="string">'a'</span>;</span><br><span class="line">      <span class="keyword">if</span> (p.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      p = p.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p.isEndingChar) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span> data;</span><br><span class="line">    <span class="keyword">public</span> TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isEndingChar = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建好 Trie 树后，在其中查找字符串的时间复杂度是 O(k)，k 表示要查找的字符串的长度</p><h1 id="Trie-树真的很耗内存吗"><a href="#Trie-树真的很耗内存吗" class="headerlink" title="Trie 树真的很耗内存吗"></a>Trie 树真的很耗内存吗</h1><p>字符串中包含从 a 到 z 这 26 个字符，那每个节点都要存储一个长度为 26 的数组，并且每个数组存储一个 8 字节指针（。而且，即便一个节点只有很少的子节点，远小于 26 个，比如 3、4 个，我们也要维护一个长度为 26 的数组</p><h1 id="Trie-树与散列表、红黑树的比较"><a href="#Trie-树与散列表、红黑树的比较" class="headerlink" title="Trie 树与散列表、红黑树的比较"></a>Trie 树与散列表、红黑树的比较</h1><ul><li>字符串中包含的字符集不能太大</li><li>要求字符串的前缀重合比较多，不然空间消耗会变大很多</li><li>通过指针串起来的数据块是不连续的，而 Trie 树中用到了指针</li></ul>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>37贪心算法</title>
      <link href="/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/37%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
      <url>/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/37%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="如何理解“贪心算法”"><a href="#如何理解“贪心算法”" class="headerlink" title="如何理解“贪心算法”"></a>如何理解“贪心算法”</h1><p>贪心算法（英语：greedy algorithm），又称贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法</p><p>A greedy algorithm is an algorithmic paradigm that follows the problem solving heuristic of making the locally optimal choice at each stage[1] with the intent of finding a global optimum</p><p>用贪心算法解决问题的思路，并不总能给出最优解</p> <a id="more"></a><h1 id="贪心算法实战分析"><a href="#贪心算法实战分析" class="headerlink" title="贪心算法实战分析"></a>贪心算法实战分析</h1><h2 id="分糖果"><a href="#分糖果" class="headerlink" title="分糖果"></a>分糖果</h2><p>我们有 m 个糖果和 n 个孩子。我们现在要把糖果分给这些孩子吃，但是糖果少，孩子多（m&lt;n），所以糖果只能分配给一部分孩子</p><h2 id="钱币找零"><a href="#钱币找零" class="headerlink" title="钱币找零"></a>钱币找零</h2><p>假设我们有 1 元、2 元、5 元、10 元、20 元、50 元、100 元这些面额的纸币，它们的张数分别是 c1、c2、c5、c10、c20、c50、c100。我们现在要用这些钱来支付 K 元，最少要用多少张纸币呢</p><h2 id="区间覆盖"><a href="#区间覆盖" class="headerlink" title="区间覆盖"></a>区间覆盖</h2><p><img src="http://liyong.ac.cn/pic/f0a1b7978711651d9f084d19a70805cd.jpg" alt="img"></p><p> n 个区间中最左端点是 lmin，最右端点是 rmax。这个问题就相当于，我们选择几个不相交的区间，从左到右将 [lmin, rmax] 覆盖上</p><p>每次选择的时候，左端点跟前面的已经覆盖的区间不重合的，右端点又尽量小的</p><p><img src="http://liyong.ac.cn/pic/ef2d0bd8284cb6e69294566a45b0e2b5.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03-04如何分析、统计算法的执行效率和资源消耗</title>
      <link href="/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/03-04%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E3%80%81%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E5%92%8C%E8%B5%84%E6%BA%90%E6%B6%88%E8%80%97/"/>
      <url>/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/03-04%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E3%80%81%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E5%92%8C%E8%B5%84%E6%BA%90%E6%B6%88%E8%80%97/</url>
      
        <content type="html"><![CDATA[<h1 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h1><ul><li>只关注循环执行次数最多的一段代码</li><li>加法法则：总复杂度等于量级最大的那段代码的复杂度</li><li>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</li></ul><a id="more"></a><h1 id="几种常见时间复杂度实例分析"><a href="#几种常见时间复杂度实例分析" class="headerlink" title="几种常见时间复杂度实例分析"></a>几种常见时间复杂度实例分析</h1><h2 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h2><p>只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)</p><h2 id="O-logn-、O-nlogn"><a href="#O-logn-、O-nlogn" class="headerlink" title="O(logn)、O(nlogn)"></a>O(logn)、O(nlogn)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n)  &#123;</span><br><span class="line">  i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。为什么呢？</p><p>对数之间是可以互相转换的，log<sub>3</sub>n 就等于 log<sub>3</sub>2 * log<sub>2</sub>n，所以 O(log<sub>3</sub>n) = O(C *  log<sub>2</sub>n)，其中 C=log<sub>3</sub>2 是一个常量。基于我们前面的一个理论：<strong>在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))</strong>。所以，O(log<sub>2</sub>n) 就等于 O(log<sub>3</sub>n)。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。</p><h2 id="O-m-n-、O-m-n"><a href="#O-m-n-、O-m-n" class="headerlink" title="O(m+n)、O(m*n)"></a>O(m+n)、O(m*n)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; m; ++i) &#123;</span><br><span class="line">    sum_1 = sum_1 + i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; j &lt; n; ++j) &#123;</span><br><span class="line">    sum_2 = sum_2 + j;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum_1 + sum_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  <span class="keyword">for</span> (i; i &lt;n; ++i) &#123;</span><br><span class="line">    a[i] = i * i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    print out a[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 2 行代码中，我们申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。</p><ul><li><p>最好情况时间复杂度（best case time complexity）</p></li><li><p>最坏情况时间复杂度（worst case time complexity）</p></li><li><p>平均情况时间复杂度（average case time complexity）</p></li><li><p>均摊时间复杂度（amortized time complexity）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// array 表示一个长度为 n 的数组</span></span><br><span class="line"> <span class="comment">// 代码中的 array.length 就等于 n</span></span><br><span class="line"> <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == array.length) &#123;</span><br><span class="line">       <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; ++i) &#123;</span><br><span class="line">          sum = sum + array[i];</span><br><span class="line">       &#125;</span><br><span class="line">       array[<span class="number">0</span>] = sum;</span><br><span class="line">       count = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">array[count] = val;</span><br><span class="line">++count;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02如何抓住重点，系统高效地学习数据结构与算法</title>
      <link href="/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/02%E5%A6%82%E4%BD%95%E6%8A%93%E4%BD%8F%E9%87%8D%E7%82%B9%EF%BC%8C%E7%B3%BB%E7%BB%9F%E9%AB%98%E6%95%88%E5%9C%B0%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/02%E5%A6%82%E4%BD%95%E6%8A%93%E4%BD%8F%E9%87%8D%E7%82%B9%EF%BC%8C%E7%B3%BB%E7%BB%9F%E9%AB%98%E6%95%88%E5%9C%B0%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="学习的重点在什么地方？"><a href="#学习的重点在什么地方？" class="headerlink" title="学习的重点在什么地方？"></a>学习的重点在什么地方？</h1><p><img src="http://liyong.ac.cn/pic/913e0ababe43a2d57267df5c5f0832a7.jpg" alt></p><a id="more"></a><h1 id="一些可以让你事半功倍的学习技巧"><a href="#一些可以让你事半功倍的学习技巧" class="headerlink" title="一些可以让你事半功倍的学习技巧"></a>一些可以让你事半功倍的学习技巧</h1><ul><li>边学边练，适度刷题</li><li>多问、多思考、多互动</li><li>打怪升级学习法</li><li>知识需要沉淀，不要想试图一下子掌握所有</li></ul>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06-07链表</title>
      <link href="/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/06-07%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/06-07%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="理解指针或引用的含义"><a href="#理解指针或引用的含义" class="headerlink" title="理解指针或引用的含义"></a>理解指针或引用的含义</h1><p>不管是“指针”还是“引用”，实际上，它们的意思都是一样的，都是存储所指对象的内存地址。</p><a id="more"></a><h1 id="警惕指针丢失和内存泄漏"><a href="#警惕指针丢失和内存泄漏" class="headerlink" title="警惕指针丢失和内存泄漏"></a>警惕指针丢失和内存泄漏</h1><h1 id="利用哨兵简化实现难度"><a href="#利用哨兵简化实现难度" class="headerlink" title="利用哨兵简化实现难度"></a>利用哨兵简化实现难度</h1><h1 id="重点留意边界条件处理"><a href="#重点留意边界条件处理" class="headerlink" title="重点留意边界条件处理"></a>重点留意边界条件处理</h1><ul><li>如果链表为空时，代码是否能正常工作？</li><li>如果链表只包含一个结点时，代码是否能正常工作？</li><li>如果链表只包含两个结点时，代码是否能正常工作？</li><li>代码逻辑在处理头结点和尾结点的时候，是否能正常工作？</li></ul><h1 id="举例画图，辅助思考"><a href="#举例画图，辅助思考" class="headerlink" title="举例画图，辅助思考"></a>举例画图，辅助思考</h1><h1 id="多写多练，没有捷径"><a href="#多写多练，没有捷径" class="headerlink" title="多写多练，没有捷径"></a>多写多练，没有捷径</h1>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>08栈：如何实现浏览器的前进和后退功能</title>
      <link href="/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/08%E6%A0%88%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%89%8D%E8%BF%9B%E5%92%8C%E5%90%8E%E9%80%80%E5%8A%9F%E8%83%BD/"/>
      <url>/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/08%E6%A0%88%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%89%8D%E8%BF%9B%E5%92%8C%E5%90%8E%E9%80%80%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="如何理解“栈”？"><a href="#如何理解“栈”？" class="headerlink" title="如何理解“栈”？"></a>如何理解“栈”？</h2><p>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构</p><a id="more"></a><h1 id="如何实现一个“栈”"><a href="#如何实现一个“栈”" class="headerlink" title="如何实现一个“栈”"></a>如何实现一个“栈”</h1><p>栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作<strong>顺序栈</strong>，用链表实现的栈，我们叫作<strong>链式栈</strong></p><h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><ul><li>时间复杂度都是 O(1)</li><li>空间复杂度是 O(1)</li></ul><h1 id="支持动态扩容的顺序栈"><a href="#支持动态扩容的顺序栈" class="headerlink" title="支持动态扩容的顺序栈"></a>支持动态扩容的顺序栈</h1><h1 id="栈在函数调用中的应用"><a href="#栈在函数调用中的应用" class="headerlink" title="栈在函数调用中的应用"></a>栈在函数调用中的应用</h1><h1 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="headerlink" title="栈在表达式求值中的应用"></a>栈在表达式求值中的应用</h1><p> 编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈.从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较</p><p>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</p><p>3+5*8-6</p><p><img src="http://liyong.ac.cn/pic/bc77c8d33375750f1700eb7778551600.jpg" alt></p><h1 id="栈在括号匹配中的应用"><a href="#栈在括号匹配中的应用" class="headerlink" title="栈在括号匹配中的应用"></a>栈在括号匹配中的应用</h1><p>用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>40-41-42动态规划</title>
      <link href="/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/40-41-42%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/40-41-42%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11排序：为什么插入排序比冒泡排序更受欢迎</title>
      <link href="/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/11%E6%8E%92%E5%BA%8F%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%AF%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%9B%B4%E5%8F%97%E6%AC%A2%E8%BF%8E/"/>
      <url>/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/11%E6%8E%92%E5%BA%8F%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%AF%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%9B%B4%E5%8F%97%E6%AC%A2%E8%BF%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="如何分析一个“排序算法”？"><a href="#如何分析一个“排序算法”？" class="headerlink" title="如何分析一个“排序算法”？"></a>如何分析一个“排序算法”？</h1><h2 id="排序算法的执行效率"><a href="#排序算法的执行效率" class="headerlink" title="排序算法的执行效率"></a>排序算法的执行效率</h2><ul><li>最好情况、最坏情况、平均情况时间复杂度</li><li>时间复杂度的系数、常数 、低阶</li><li>比较次数和交换（或移动）次数</li></ul><a id="more"></a><h2 id="排序算法的内存消耗"><a href="#排序算法的内存消耗" class="headerlink" title="排序算法的内存消耗"></a>排序算法的内存消耗</h2><p>原地排序算法，就是特指空间复杂度是 O(1) 的排序算法</p><h2 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h2><p>稳定性:如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p><h1 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h1><ul><li><p>冒泡排序只会操作相邻的两个数据</p></li><li><p>每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。</p></li><li><p>一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; a.length - i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &lt; a[j - <span class="number">1</span>]) &#123;</span><br><span class="line">        SortUtil.swap(a, j, j - <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://liyong.ac.cn/pic/4038f64f47975ab9f519e4f739e464e9.jpg" alt></p><p><img src="http://liyong.ac.cn/pic/9246f12cca22e5d872cbfce302ef4d09.jpg" alt></p><p>刚讲的冒泡过程还可以优化。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。我这里还有另外一个例子，这里面给 6 个元素排序，只需要 4 次冒泡操作就可以了。</p><p><img src="http://liyong.ac.cn/pic/a9783a3b13c11a5e064c5306c261e8e6.jpg" alt></p><h2 id="冒泡排序的时间复杂度是多少"><a href="#冒泡排序的时间复杂度是多少" class="headerlink" title="冒泡排序的时间复杂度是多少"></a>冒泡排序的时间复杂度是多少</h2><p>最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 O(n)。而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 O(n2)    </p><p><img src="http://liyong.ac.cn/pic/fe107c06da8b290fb78fcce4f6774c0f.jpg" alt></p><p><strong>有序度</strong>是数组中具有有序关系的元素对的个数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有序元素对：a[i] &lt;= a[j], 如果 i &lt; j。</span><br></pre></td></tr></table></figure><p><img src="http://liyong.ac.cn/pic/a1ef4cc1999d6bd0af08d8417ee55220.jpg" alt></p><p>对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是<strong>n*(n-1)/2</strong>，也就是 15。我们把这种完全有序的数组的有序度叫作<strong>满有序度</strong>。</p><p>逆序度 = 满有序度 - 有序度</p><p>冒泡排序包含两个操作原子，<strong>比较</strong>和<strong>交换</strong>。每交换一次，有序度就加 1。不管算法怎么改进，交换次数总是确定的，即为<strong>逆序度，也就是n*(n-1)/2–初始有序度</strong>。</p><h1 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h1><p>一个有序的数组，我们往里面添加一个新的数据后，如何继续保持数据有序呢？很简单，我们只要遍历数组，找到数据应该插入的位置将其插入即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> j = i;</span><br><span class="line">    <span class="keyword">int</span> insertValue = a[i];</span><br><span class="line">    <span class="keyword">for</span> (; j &gt;= <span class="number">1</span> &amp;&amp; (a[j] &lt; a[j - <span class="number">1</span>]); j--) &#123;</span><br><span class="line">      a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    a[j] = insertValue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <img src="http://liyong.ac.cn/pic/7b257e179787c633d2bd171a764171a6.jpg" alt="7b257e179787c633d2bd171a764171a6"></p><p>首先，我们将数组中的数据分为两个区间，<strong>已排序区间</strong>和<strong>未排序区间</strong>。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。</p><p>如图所示，要排序的数据是 4，5，6，1，3，2，其中左侧为已排序区间，右侧是未排序区间。</p><p><img src="http://liyong.ac.cn/pic/b60f61ec487358ac037bf2b6974d2de1.jpg" alt></p><p>对于不同的查找插入点方法（从头到尾、从尾到头），元素的比较次数是有区别的。但对于一个给定的初始序列，移动操作的次数总是固定的，就等于逆序度</p><h1 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h1><p>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> minIndex= i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; a.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[minIndex] &gt; a[j]) &#123;</span><br><span class="line">        minIndex = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i != minIndex) &#123;</span><br><span class="line">      SortUtil.swap(a, i, minIndex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://liyong.ac.cn/pic/32371475a0b08f0db9861d102474181d.jpg" alt></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><img src="http://liyong.ac.cn/pic/348604caaf0a1b1d7fee0512822f0e50.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>09队列：队列在线程池等有限资源池中的应用</title>
      <link href="/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/09%E9%98%9F%E5%88%97%EF%BC%9A%E9%98%9F%E5%88%97%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AD%89%E6%9C%89%E9%99%90%E8%B5%84%E6%BA%90%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/09%E9%98%9F%E5%88%97%EF%BC%9A%E9%98%9F%E5%88%97%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AD%89%E6%9C%89%E9%99%90%E8%B5%84%E6%BA%90%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="如何理解“队列”？"><a href="#如何理解“队列”？" class="headerlink" title="如何理解“队列”？"></a>如何理解“队列”？</h1><ul><li><p>先进者先出，这就是典型的“队列”</p></li><li><p>入队 enqueue()，放一个数据到队列尾部；出队 dequeue()，从队列头部取一个元素。</p></li></ul><a id="more"></a><h1 id="顺序队列和链式队列"><a href="#顺序队列和链式队列" class="headerlink" title="顺序队列和链式队列"></a>顺序队列和链式队列</h1><ul><li>用数组实现的队列叫作<strong>顺序队列</strong></li><li>用链表实现的队列叫作<strong>链式队列</strong></li></ul><h1 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h1><p><img src="http://liyong.ac.cn/pic/71a41effb54ccea9dd463bde1b6abe80.jpg" alt></p><ul><li>队列为空的判断条件仍然是 head == tail</li><li>当队满时，<strong>(tail+1)%n=head</strong></li></ul><h1 id="阻塞队列和并发队列"><a href="#阻塞队列和并发队列" class="headerlink" title="阻塞队列和并发队列"></a>阻塞队列和并发队列</h1><ul><li>队列为空的时候，从队头取数据会被阻塞</li><li>队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回</li></ul>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习指导手册</title>
      <link href="/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%AF%BC%E6%89%8B%E5%86%8C/"/>
      <url>/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%AF%BC%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h1><p><img src="http://liyong.ac.cn/pic/54163f16e152f71b8f91d3fba652cf48.jpg" alt="img"></p> <a id="more"></a><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><p> 能自行分析专栏中大部分数据结构和算法的时间、空间复杂度</p><h1 id="数组、栈、队列"><a href="#数组、栈、队列" class="headerlink" title="数组、栈、队列"></a>数组、栈、队列</h1><p>这一部分内容非常简单，初学者学起来也不会很难。但是，作为基础的数据结构，数组、栈、队列，是后续很多复杂数据结构和算法的基础，所以，这些内容你一定要掌握。</p><p>掌握程度：能自己实现动态数组、栈、队列</p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表非常重要！虽然理论内容不多，但链表上的操作却很复杂。所以，面试中经常会考察，你一定要掌握。而且，我这里说“掌握”不只是能看懂专栏中的内容，还能将专栏中提到的经典链表题目，比如链表反转、求中间结点等，轻松无 bug 地实现出来</p><p>掌握程度：能轻松写出经典链表题目代码</p><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>对于初学者来说，递归代码非常难掌握，不管是读起来，还是写起来。但是，这道坎你必须要跨过，跨不过就不能算是入门数据结构和算法。</p><p>先在网上找些简单的题目练手，比如斐波那契数列、求阶乘等，然后再慢慢过渡到更加有难度的，比如归并排序、快速排序、二叉树的遍历、求高度，最后是回溯八皇后、背包问题等</p><p>掌握程度：轻松写出二叉树遍历、八皇后、背包问题、DFS 的递归代码</p><h1 id="排序、二分查找"><a href="#排序、二分查找" class="headerlink" title="排序、二分查找"></a>排序、二分查找</h1><p>掌握程度：能自己把各种排序算法、二分查找及其变体代码写一遍就可以了</p><h1 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h1><p>掌握程度：初学者可以先跳过。如果感兴趣，看懂专栏内容即可，不需要掌握代码实现</p><h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><p>这块内容理解起来并不难。但是，作为一种应用非常广泛的数据结构，你还是要掌握牢固散列表</p><p>掌握程度：对于初学者来说，自己能代码实现一个拉链法解决冲突的散列表即可</p><h1 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h1><p>这部分纯粹是为了开拓思路，初学者可以略过</p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>这一部分非常重要！二叉树在面试中经常会被考到，所以要重点掌握。 </p><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>对于初学者来说，这一节课完全可以不看</p><h1 id="B-树"><a href="#B-树" class="headerlink" title="B+ 树"></a>B+ 树</h1><p>虽然 B+ 树也算是比较高级的一种数据结构了，但是对初学者来说，也不是重点。有时候面试的时候还是会问的</p><h1 id="堆与堆排序"><a href="#堆与堆排序" class="headerlink" title="堆与堆排序"></a>堆与堆排序</h1><p>这一部分内容不是很难，初学者也是要掌握的</p><p>掌握程度：能代码实现堆、堆排序，并且掌握堆的三种应用（优先级队列、Top k、中位数）</p><h1 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h1><p>图的内容很多，但是初学者不需要掌握那么多。一般 BAT 等大厂面试，不怎么会面试有关图的内容，因为面试官可能也对这块不会很熟悉哈：）。但是，最基本图的概念、表示方法还是要掌握的</p><p>掌握程度：理解图的三种表示方法（邻接矩阵、邻接表、逆邻接表），能自己代码实现</p><h1 id="深度广度优先搜索"><a href="#深度广度优先搜索" class="headerlink" title="深度广度优先搜索"></a>深度广度优先搜索</h1><p>这算是图上最基础的遍历或者说是搜索算法了，所以还是要掌握一下</p><p>掌握程度：能代码实现广度优先、深度优先搜索算法</p><h1 id="拓扑排序、最短路径、A-算法"><a href="#拓扑排序、最短路径、A-算法" class="headerlink" title="拓扑排序、最短路径、A* 算法"></a>拓扑排序、最短路径、A* 算法</h1><p>这几个算法稍微高级点。如果你能轻松实现深度、广度优先搜索，那看懂这三个算法不成问题</p><p>掌握程度：有时间再看，暂时可以不看</p><h1 id="字符串匹配（BF、RK）"><a href="#字符串匹配（BF、RK）" class="headerlink" title="字符串匹配（BF、RK）"></a>字符串匹配（BF、RK）</h1><p>BF 非常简单，RK 稍微复杂点，但都不难。这个最好还是掌握下</p><p>掌握程度：能实践 BF 算法，能看懂 RK 算法</p><h1 id="字符串匹配（BM、KMP、AC-自动机）"><a href="#字符串匹配（BM、KMP、AC-自动机）" class="headerlink" title="字符串匹配（BM、KMP、AC 自动机）"></a>字符串匹配（BM、KMP、AC 自动机）</h1><p>这三个算法都挺难的，对于算法有一定基础的人来说，看懂也不容易。所以，对于初学者来说，千万别浪费时间在这上面。即便有余力，看懂就好了，不用非得能自己实现</p><p>掌握程度：初学者不用把时间浪费在上面</p><h1 id="字符串匹配（Trie）"><a href="#字符串匹配（Trie）" class="headerlink" title="字符串匹配（Trie）"></a>字符串匹配（Trie）</h1><p>这个还是要能看懂，不过不需要能代码实现。有些面试官喜欢考这个东西，主要是结合应用场景来考察，只是看你知不知道要用 Trie 树这个东西。</p><p>掌握程度：能看懂，知道特点、应用场景即可，不要求代码实现</p><h1 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h1><p>位图不是重点，如果有余力最好掌握一下</p><p>掌握程度：看懂即可，能自己实现一个位图结构最好</p><h1 id="四种算法思想"><a href="#四种算法思想" class="headerlink" title="四种算法思想"></a>四种算法思想</h1><p>这个是重点，也是难点。贪心、分治、回溯、动态规划，每一个都不简单，其中动态规划又是最难、最烧脑的。要应付 FLAG 这样公司的面试，必须拿下这块内容。但是呢，学习要循序渐进，这块能内容的学习可以放到最后，做个长时间的学习计划来攻克</p><p>掌握程度：可以放到最后，但是一定要掌握！做到能实现 Leetcode 上 Medium 难度的题目</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>39回溯算法</title>
      <link href="/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/39%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/39%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="如何理解“回溯算法“"><a href="#如何理解“回溯算法“" class="headerlink" title="如何理解“回溯算法“"></a>如何理解“回溯算法“</h1><p>回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案</p><ul><li><p>用来解决广义的搜索问题，也就是，从一组可能的解中，选择出一个满足要求的解</p></li><li><p>回溯算法非常适合用递归来实现，在实现的过程中，剪枝操作是提高回溯效率的一种技巧</p></li><li><p>利用剪枝，我们并不需要穷举搜索所有的情况，从而提高搜索效率。</p><a id="more"></a></li></ul><h1 id="八皇后"><a href="#八皇后" class="headerlink" title="八皇后"></a>八皇后</h1><p><img src="http://liyong.ac.cn/pic/e835cab502bec3ebebab92381c667532.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>38分治算法</title>
      <link href="/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/38%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
      <url>/2019/01/24/aa_category/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/38%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="如何理解“贪心算法”"><a href="#如何理解“贪心算法”" class="headerlink" title="如何理解“贪心算法”"></a>如何理解“贪心算法”</h1><p>分治法，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并</p><p>分治算法的递归实现中，每一层递归都会涉及这样三个操作：</p><ul><li><p>分解：将原问题分解成一系列子问题；</p></li><li><p>解决：递归地求解各个子问题，若子问题足够小，则直接求解；</p></li><li><p>合并：将子问题的结果合并成原问题。</p><a id="more"></a></li></ul><p>分治算法能解决的问题，一般需要满足下面这几个条件：</p><ul><li>原问题与分解成的小问题具有相同的模式；</li><li>原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别，等我们讲到动态规划的时候，会详细对比这两种算法；</li><li>具有分解终止条件，也就是说，当问题足够小时，可以直接求解；</li><li>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了</li></ul><h1 id="求逆序对个数"><a href="#求逆序对个数" class="headerlink" title="求逆序对个数"></a>求逆序对个数</h1><p><img src="http://liyong.ac.cn/pic/e835cab502bec3ebebab92381c667532.jpg" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DivideConquer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">// 全局变量或者成员变量</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] a = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> DivideConquer().count(a, a.length));</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">    mergeSortCounting(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSortCounting</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; r) &#123;</span><br><span class="line">      <span class="keyword">int</span> q = p + ((r - p) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      mergeSortCounting(a, p, q);</span><br><span class="line">      mergeSortCounting(a, q + <span class="number">1</span>, r);</span><br><span class="line">      merge(a, p, q, r);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[r - p + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = p;</span><br><span class="line">    <span class="keyword">int</span> j = q + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= q &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[i] &lt;= a[j]) &#123;</span><br><span class="line">        tmp[k++] = a[i++];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//      统计 p-q 之间，比 a[j] 大的元素个数</span></span><br><span class="line">        num += (q - i + <span class="number">1</span>);</span><br><span class="line">        tmp[k++] = a[j++];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">while</span> (i &lt;= q) &#123;</span><br><span class="line">        tmp[k++] = a[i++];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (j &lt;= r) &#123;</span><br><span class="line">        tmp[k++] = a[j++];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; tmp.length; m++) &#123;</span><br><span class="line">        a[p + m] = tmp[m];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编码规范</title>
      <link href="/2019/01/01/aa_category/methodology/standard/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
      <url>/2019/01/01/aa_category/methodology/standard/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h1><ol><li>不能以下划线和美元符号作为开始结束符号</li><li>禁止中英文形式</li><li>类名使用UpperCamelCase</li><li>方法名、参数名、成员变量、局部变量统一使用LowerCamelCase</li><li>常量大写，单词间下划线隔开，力求语义完成</li><li>抽象类用Abstract或者Base开头，异常类以Exception结尾，测试类以要测试类的名称开始，以Test结尾</li><li>中括号是数组定义的一部分</li><li>布尔类型的变量的命名不要添加is</li><li>包名使用小写，点分隔符之间只有一个英语单词。包名必须是单数形式，类名可以有复数形式(  MessageUtils)。</li><li>避免不规范的缩写</li><li>为了达到代码自解释的目的，使用尽量完整的单词组合来命名</li><li>如果使用了设计模式，命名时体现具体模式</li></ol><a id="more"></a><h1 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h1><ol><li>不允许任何魔法值</li><li>long、Long初始化赋值，使用大写L</li><li>不要使用一个常量维护所有的常量</li><li>常量的复用有5层，跨应用共享，应用内共享，子工程内共享，包内共享，类内共享（private static final）</li><li>如果变量值仅在一个范围内变化，且带有名称之外的延伸属性，定义为枚举</li></ol><h1 id="oop规约"><a href="#oop规约" class="headerlink" title="oop规约"></a>oop规约</h1><ol><li><p>避免通过类的对象引用静态属性和静态方法</p></li><li><p>重写方法添加@Override</p></li><li><p>相同参数类型，相同业务含义，才可以使用可变参数</p></li><li><p>外部正在调用，或者二方库依赖的接口，不允许修改方法签名。接口过时添加@Deprecated,并说明新接口</p></li><li><p>equals方法应该先写常量，避免空指针</p></li><li><p>对象之间值的比较使用equals</p></li><li><p>基本数据类型和包装类型</p><ul><li><p>pojo类属性使用包装类型</p></li><li><p>RPC方法的出入参使用包装类型</p></li><li><p>局部变量使用基本数据类型</p></li></ul></li><li><p>POJO类，不要设定任何属性默认值</p></li><li><p>构造愤怒规范禁止加入任何业务逻辑，如果有初始化逻辑，放置到init方法</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> standard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> standard </tag>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git规范</title>
      <link href="/2019/01/01/aa_category/methodology/standard/git_standard/"/>
      <url>/2019/01/01/aa_category/methodology/standard/git_standard/</url>
      
        <content type="html"><![CDATA[<h1 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h1><ul><li><p>学习gitflow思想，参考网址</p><p><a href="https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/git-flow" target="_blank" rel="noopener">https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/git-flow</a></p><p><a href="https://blog.csdn.net/xingbaozhen1210/article/details/81386269" target="_blank" rel="noopener">https://blog.csdn.net/xingbaozhen1210/article/details/81386269</a></p></li><li><p>push之前一定要先拉取</p></li><li><p>push之前确定分支是否正确</p></li><li><p>本地分支和远程分支不要做merge</p></li><li><p>feature-分支对应的代码上线以后需要删除</p></li><li><p>两天必须提交push一次代码到远程，push之前确保代码没有编译错误，程序可以正常启动</p></li></ul><h3 id="上线篇"><a href="#上线篇" class="headerlink" title="上线篇"></a>上线篇</h3><ul><li>上线完成以后需要记录线上的git  version  </li><li>如果发生线上bug ,从线上指定的git  version 拉取</li></ul><h1 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h1><h3 id="先往不重要的分支merge"><a href="#先往不重要的分支merge" class="headerlink" title="先往不重要的分支merge"></a>先往不重要的分支merge</h3><ul><li>有 feature-card   master 两个分支，需要feature-card   合并到 master</li><li>首先确保两个分支都commit了</li><li>方法1，先把master合并到feature-card，解决冲突，然后再把feature-card合并到master</li><li>方法2 ，直接把feature-card合并到master解决冲突，如果发现合并后有问题  reset  –hard(确保合并之前代码commit了) 到合并前的版本</li><li>本地解决了冲突了在push</li></ul>]]></content>
      
      
      <categories>
          
          <category> standard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> standard </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习的正确姿势</title>
      <link href="/2019/01/01/aa_category/methodology/%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/"/>
      <url>/2019/01/01/aa_category/methodology/%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/</url>
      
        <content type="html"><![CDATA[<p>目标</p><ul><li>linux</li><li>jvm</li><li>线程池</li><li>juc</li><li>nio、io</li><li>网络</li><li>缓存  redis  </li><li>消息</li><li>搜索</li><li>javaee规范</li><li>设计模式</li><li>spring </li><li>规范</li></ul><a id="more"></a><p>通过百度、谷歌查看被人的博客梳理知识脉络</p><p>通过官网验证知识自己的理解的正确性</p><h2 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h2><p>有助于理解知识</p>]]></content>
      
      
      <categories>
          
          <category> methodology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> methodology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis数据类型</title>
      <link href="/2019/01/01/aa_category/middleware/redis/redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/01/01/aa_category/middleware/redis/redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>string、hash、list、set、sorted set</p><a id="more"></a><h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><p>这是最简单的类型，就是普通的 set 和 get，做简单的 KV 缓存</p><h1 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h1><p>这个是类似 map 的一种结构，这个一般就是可以将结构化的数据，比如一个对象（前提是这个对象没嵌套其他的对象）给缓存在 redis 里，然后每次读写缓存的时候，可以就操作 hash 里的某个字段</p><h1 id="list"><a href="#list" class="headerlink" title="list"></a>list</h1><ul><li>存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的东西</li><li>通过 lrange 命令实现分页查询，基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西</li></ul><h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p>基于 set 玩儿交集、并集、差集的操作，比如交集吧，可以把两个人的粉丝列表整一个交集，看看俩人的共同好友是谁</p>]]></content>
      
      
      <categories>
          
          <category> middleware </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> middleware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis数据类型</title>
      <link href="/2019/01/01/aa_category/middleware/redis/index/"/>
      <url>/2019/01/01/aa_category/middleware/redis/index/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis是单线程的，但Redis为什么这么快"><a href="#Redis是单线程的，但Redis为什么这么快" class="headerlink" title="Redis是单线程的，但Redis为什么这么快"></a>Redis是单线程的，但Redis为什么这么快</h2><p> Redis采用的是基于内存的采用的是单进程单线程模型的 KV 数据库，由C语言编写，官方提供的数据是可以达到100000+的QPS</p><ul><li>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速</li><li>数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的</li><li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗</li><li>使用多路I/O复用模型，非阻塞IO</li><li>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求</li></ul><h2 id="redisObject"><a href="#redisObject" class="headerlink" title="redisObject"></a>redisObject</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line"> <span class="comment">/* Object types */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_STRING 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_LIST 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_SET 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ZSET 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_HASH 4</span></span><br><span class="line"><span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_LINKEDLIST 4 <span class="comment">/* Encoded as regular linked list */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line"><span class="meta">#lru字段表示当内存超限时采用LRU算法清除内存中的对象</span></span><br><span class="line">unsigned lru:REDIS_LRU_BITS; */\* lru time (relative to server.lruclock) \*/*</span><br><span class="line"><span class="meta"># refcount表示对象的引用计数</span></span><br><span class="line"><span class="keyword">int</span> refcount;</span><br><span class="line"><span class="meta"># ptr指针指向真正的存储结构</span></span><br><span class="line"><span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>string:raw int</p><p>Hash:ziplist hash_table</p><p>list: linkedlist  ziplist</p>]]></content>
      
      
      <categories>
          
          <category> middleware </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> middleware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计一个高并发系统</title>
      <link href="/2019/01/01/aa_category/methodology/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/01/01/aa_category/methodology/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<ul><li>系统拆分</li><li>缓存</li><li>MQ</li><li>分库分表</li><li>读写分离</li><li>ElasticSearch</li></ul><p><img src="D:%5Cgithub%5Chexo%5Csource%5Cpic%5Cmethodology%5Chigh-concurrency-system-design.png" alt></p><a id="more"></a><h1 id="系统拆分"><a href="#系统拆分" class="headerlink" title="系统拆分"></a>系统拆分</h1><p>将一个系统拆分为多个子系统，用 dubbo 来搞。然后每个系统连一个数据库，这样本来就一个库，现在多个数据库，不也可以扛高并发么</p><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>缓存，必须得用缓存。大部分的高并发场景，都是<strong>读多写少</strong>，那你完全可以在数据库和缓存里都写一份，然后读的时候大量走缓存不就得了。毕竟人家 redis 轻轻松松单机几万的并发。所以你可以考虑考虑你的项目里，那些承载主要请求的<strong>读场景，怎么用缓存来抗高并发</strong></p><h1 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h1><p>MQ，必须得用 MQ。可能你还是会出现高并发写的场景，比如说一个业务操作里要频繁搞数据库几十次，增删改增删改，疯了。那高并发绝对搞挂你的系统，你要是用 redis 来承载写那肯定不行，人家是缓存，数据随时就被 LRU 了，数据格式还无比简单，没有事务支持。用 MQ 吧，大量的写请求灌入 MQ 里，排队慢慢玩儿，<strong>后边系统消费后慢慢写</strong>，控制在 mysql 承载范围之内</p><h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><p>可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就将一个数据库拆分为多个库，多个库来扛更高的并发；然后将一个表<strong>拆分为多个表</strong>，每个表的数据量保持少一点，提高 sql 跑的性能。</p><h1 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h1><p>这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都集中在一个库上吧，可以搞个主从架构，<strong>主库写</strong>入，<strong>从库读</strong>取，搞一个读写分离。<strong>读流量太多</strong>的时候，还可以<strong>加更多的从库</strong></p><h1 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h1>]]></content>
      
      
      <categories>
          
          <category> methodology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> methodology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库设计</title>
      <link href="/2019/01/01/aa_category/methodology/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
      <url>/2019/01/01/aa_category/methodology/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h1><h2 id="version"><a href="#version" class="headerlink" title="version"></a>version</h2><p>用于乐观锁</p><h2 id="status"><a href="#status" class="headerlink" title="status"></a>status</h2><p>逻辑删除 0删除，1正常</p><a id="more"></a><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>服务端数据量比较大的添加索引</p><h2 id="规则元数据-rule-metadata"><a href="#规则元数据-rule-metadata" class="headerlink" title="规则元数据-rule_metadata"></a>规则元数据-rule_metadata</h2><ul><li>compent_type  组件类型，单选框，复选框，输入框，下拉框</li><li>value_type 值的类型  int boolean string date</li><li>value relation  值之间的关系，|| &amp;&amp;</li></ul><h2 id="规则项-ai-active-rule-item"><a href="#规则项-ai-active-rule-item" class="headerlink" title="规则项-ai_active_rule_item"></a>规则项-ai_active_rule_item</h2><ul><li>code 编码</li><li>name 标签名称</li><li>weight 权重</li><li>compare_way  比较方式 &gt; &lt; &gt;= &lt;= </li></ul>]]></content>
      
      
      <categories>
          
          <category> methodology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> methodology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码阅读</title>
      <link href="/2019/01/01/aa_category/methodology/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
      <url>/2019/01/01/aa_category/methodology/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="spring源码阅读"><a href="#spring源码阅读" class="headerlink" title="spring源码阅读"></a>spring源码阅读</h1><h2 id="知道有哪些功能"><a href="#知道有哪些功能" class="headerlink" title="知道有哪些功能"></a>知道有哪些功能</h2><p>只有知道有哪些功能才明白为什么那样写</p><a id="more"></a><h3 id="看官方文档"><a href="#看官方文档" class="headerlink" title="看官方文档"></a>看官方文档</h3><p>看完以后需要总结说明什么意思</p><h2 id="猜怎么实现的"><a href="#猜怎么实现的" class="headerlink" title="猜怎么实现的"></a>猜怎么实现的</h2><p>带着问题看源码</p><h2 id="验证自己的猜想"><a href="#验证自己的猜想" class="headerlink" title="验证自己的猜想"></a>验证自己的猜想</h2>]]></content>
      
      
      <categories>
          
          <category> standard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> standard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统设计</title>
      <link href="/2019/01/01/aa_category/methodology/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2019/01/01/aa_category/methodology/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h1><h2 id="幂等一致性"><a href="#幂等一致性" class="headerlink" title="幂等一致性"></a>幂等一致性</h2><p>token  加缓存的解决方案</p><h2 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h2><a id="more"></a><h2 id="日志跟踪"><a href="#日志跟踪" class="headerlink" title="日志跟踪"></a>日志跟踪</h2><p>traceId</p><h3 id="异步保存"><a href="#异步保存" class="headerlink" title="异步保存"></a>异步保存</h3><p>保存到数据库</p><p>保存到es中</p><h2 id="部分失败"><a href="#部分失败" class="headerlink" title="部分失败"></a>部分失败</h2><ul><li>错误码分为两部分</li><li>一部分说明成功/失败/部分失败</li><li>一部分说明每条数据的成功/失败</li></ul><h2 id="错误码"><a href="#错误码" class="headerlink" title="错误码"></a>错误码</h2><table><thead><tr><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>200</td><td>成功</td></tr><tr><td>201</td><td>部分领取成功</td></tr><tr><td>5000</td><td>第三方服务异常</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h1 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h1>]]></content>
      
      
      <categories>
          
          <category> standard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> standard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis过期策略</title>
      <link href="/2019/01/01/aa_category/middleware/redis/redis%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5/"/>
      <url>/2019/01/01/aa_category/middleware/redis/redis%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<p>定期删除+惰性删除</p><a id="more"></a><h1 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h1><p> redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除</p><h1 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h1><p>获取 key 的时候，如果此时 key 已经过期，就删除，不会返回任何东西</p><h1 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h1><h2 id="allkeys-lru"><a href="#allkeys-lru" class="headerlink" title="allkeys-lru"></a>allkeys-lru</h2><p>当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</p><h2 id="volatile-lru"><a href="#volatile-lru" class="headerlink" title="volatile-lru"></a>volatile-lru</h2><p>当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key（这个一般不太合适）</p><h2 id="volatile-ttl"><a href="#volatile-ttl" class="headerlink" title="volatile-ttl"></a>volatile-ttl</h2><p>当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间</strong>中，有<strong>更早过期时间</strong>的 key 优先移除</p>]]></content>
      
      
      <categories>
          
          <category> middleware </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> middleware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用</title>
      <link href="/2018/10/12/aa_category/tool/maven/%E5%B8%B8%E7%94%A8jar/"/>
      <url>/2018/10/12/aa_category/tool/maven/%E5%B8%B8%E7%94%A8jar/</url>
      
        <content type="html"><![CDATA[<h2 id="Commons-Codec"><a href="#Commons-Codec" class="headerlink" title="Commons Codec"></a>Commons Codec</h2><p>编码解码</p><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="JCL"><a href="#JCL" class="headerlink" title="JCL"></a>JCL</h2><p>全称为”Jakarta Commons Logging”，也可称为”Apache Commons Logging”</p><h2 id="log4j-taglib"><a href="#log4j-taglib" class="headerlink" title="log4j-taglib"></a>log4j-taglib</h2><p>jsp打印日志需要</p><h2 id="jcl-over-slf4j"><a href="#jcl-over-slf4j" class="headerlink" title="jcl-over-slf4j"></a>jcl-over-slf4j</h2><p>common-logging 实际调用slf4j</p><h2 id="slf4j-simple"><a href="#slf4j-simple" class="headerlink" title="slf4j-simple"></a>slf4j-simple</h2><p>slf4j的简单实现</p>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> plugin </tag>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>log4j2入门</title>
      <link href="/2018/10/12/aa_category/log/log4j2/log4j2%E5%85%A5%E9%97%A8/"/>
      <url>/2018/10/12/aa_category/log/log4j2/log4j2%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="最终配置"><a href="#最终配置" class="headerlink" title="最终配置"></a>最终配置</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--slf4j的配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--适配器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-slf4j-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--log4j 实现--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p><a href="http://logging.apache.org/log4j/2.x/maven-artifacts.html#Using_Log4j_in_your_Apache_Maven_build" target="_blank" rel="noopener">http://logging.apache.org/log4j/2.x/maven-artifacts.html#Using_Log4j_in_your_Apache_Maven_build</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="绑定SLF4J"><a href="#绑定SLF4J" class="headerlink" title="绑定SLF4J"></a>绑定SLF4J</h1><p><a href="http://logging.apache.org/log4j/2.x/log4j-slf4j-impl/index.html" target="_blank" rel="noopener">http://logging.apache.org/log4j/2.x/log4j-slf4j-impl/index.html</a></p><p>Due to a break in compatibility in the SLF4J binding, as of release 2.11.1 two SLF4J to Log4j Adapters are provided.</p><ol><li>log4j-slf4j-impl should be used with SLF4J 1.7.x releases or older.</li><li>log4j-slf4j18-impl should be used with SLF4J 1.8.x releases or newer.</li></ol><h1 id="配置文件加载顺序"><a href="#配置文件加载顺序" class="headerlink" title="配置文件加载顺序"></a>配置文件加载顺序</h1><p>Log4j has the ability to automatically configure itself during initialization. When Log4j starts it will locate all the ConfigurationFactory plugins and arrange them in weighted order from highest to lowest. As delivered, Log4j contains four ConfigurationFactory implementations: one for JSON, one for YAML, one for properties, and one for XML.</p><ol><li>Log4j will inspect the <code>&quot;log4j.configurationFile&quot;</code> system property and, if set, will attempt to load the configuration using the <code>ConfigurationFactory</code> that matches the file extension.</li><li>If no system property is set the properties ConfigurationFactory will look for <code>log4j2-test.properties</code> in the classpath.</li><li>If no such file is found the YAML ConfigurationFactory will look for <code>log4j2-test.yaml</code> or <code>log4j2-test.yml</code> in the classpath.</li><li>If no such file is found the JSON ConfigurationFactory will look for <code>log4j2-test.json</code> or <code>log4j2-test.jsn</code> in the classpath.</li><li>If no such file is found the XML ConfigurationFactory will look for <code>log4j2-test.xml</code> in the classpath.</li><li>If a test file cannot be located the properties ConfigurationFactory will look for <code>log4j2.properties</code> on the classpath.</li><li>If a properties file cannot be located the YAML ConfigurationFactory will look for <code>log4j2.yaml</code> or <code>log4j2.yml</code> on the classpath.</li><li>If a YAML file cannot be located the JSON ConfigurationFactory will look for <code>log4j2.json</code> or <code>log4j2.jsn</code> on the classpath.</li><li>If a JSON file cannot be located the XML ConfigurationFactory will try to locate <code>log4j2.xml</code> on the classpath.</li><li>If no configuration file could be located the <code>DefaultConfiguration</code> will be used. This will cause logging output to go to the console.</li></ol><h1 id="Pattern-Layout"><a href="#Pattern-Layout" class="headerlink" title="Pattern Layout"></a>Pattern Layout</h1><p><a href="http://logging.apache.org/log4j/2.x/manual/layouts.html#PatternLayout" target="_blank" rel="noopener">http://logging.apache.org/log4j/2.x/manual/layouts.html#PatternLayout</a></p><h1 id="Filters"><a href="#Filters" class="headerlink" title="Filters"></a>Filters</h1><h2 id="MarkerFilter"><a href="#MarkerFilter" class="headerlink" title="MarkerFilter"></a>MarkerFilter</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;MarkerFilter marker=<span class="string">"FLOW"</span> onMatch=<span class="string">"ACCEPT"</span> onMismatch=<span class="string">"DENY"</span>/&gt;</span><br><span class="line"><span class="keyword">private</span> static final Marker FLOW = <span class="module-access"><span class="module"><span class="identifier">MarkerFactory</span>.</span></span>get<span class="constructor">Marker(<span class="string">"FLOW"</span>)</span>;</span><br></pre></td></tr></table></figure><h2 id="ThresholdFilter"><a href="#ThresholdFilter" class="headerlink" title="ThresholdFilter"></a>ThresholdFilter</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ThresholdFilter <span class="attribute">level</span>=<span class="string">"INFO"</span> <span class="attribute">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attribute">onMismatch</span>=<span class="string">"NEUTRAL"</span>/&gt;</span><br></pre></td></tr></table></figure><h2 id="RegexFilter"><a href="#RegexFilter" class="headerlink" title="RegexFilter"></a>RegexFilter</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;RegexFilter <span class="attribute">regex</span>=<span class="string">".*LEE.*"</span> <span class="attribute">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attribute">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span><br></pre></td></tr></table></figure><ul><li>regex匹配%msg中的文本</li><li>.*  中的点</li></ul>]]></content>
      
      
      <categories>
          
          <category> log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> log4j2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven概念</title>
      <link href="/2018/10/12/aa_category/tool/maven/maven%E6%A6%82%E5%BF%B5/"/>
      <url>/2018/10/12/aa_category/tool/maven/maven%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p><a href="http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html" target="_blank" rel="noopener">http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html</a></p><a id="more"></a><h2 id="依赖传递性"><a href="#依赖传递性" class="headerlink" title="依赖传递性"></a>依赖传递性</h2><h3 id="nearest-definition"><a href="#nearest-definition" class="headerlink" title="nearest definition"></a>nearest definition</h3><ul><li>A -&gt; B -&gt; C -&gt; D 2.0 and A -&gt; E -&gt; D 1.0, then D 1.0 </li><li>层次同样深,使用先出现的</li></ul><h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><h3 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h3><ul><li>默认的作用域</li><li>具有传递性</li></ul><h3 id="provided"><a href="#provided" class="headerlink" title="provided"></a>provided</h3><ul><li>Servlet API </li><li>作用范围为编译和测试</li><li>不具备传递性</li></ul><h3 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h3><ul><li>作用范围运行时和编译</li></ul><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><ul><li>作用范围测试</li><li>不具备传递性</li></ul><h3 id="system"><a href="#system" class="headerlink" title="system"></a>system</h3><ul><li>支持没有仓库中没有jar的场景</li></ul><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><ul><li>只能在dependencyManagement标签中,且type为pom依赖总使用</li><li>替换依赖文件中的内容</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.sql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jdbc-stdext<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;java.home&#125;/lib/rt.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Importing-Dependencies"><a href="#Importing-Dependencies" class="headerlink" title="Importing Dependencies"></a>Importing Dependencies</h2><ul><li>解决多继承</li><li>具有递归</li></ul><h2 id="依赖的逻辑主键"><a href="#依赖的逻辑主键" class="headerlink" title="依赖的逻辑主键"></a>依赖的逻辑主键</h2><ul><li>groupId, artifactId, type, classifier</li></ul><p><a href="http://maven.apache.org/pom.html" target="_blank" rel="noopener">http://maven.apache.org/pom.html</a></p><h1 id="Distribution-Management"><a href="#Distribution-Management" class="headerlink" title="Distribution Management"></a>Distribution Management</h1><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><h2 id="默认"><a href="#默认" class="headerlink" title="默认"></a>默认</h2><ul><li><code>validate</code> </li><li>compile</li><li>test</li><li>package</li><li>verify</li><li>verify</li><li>verify</li></ul><h2 id="clean生命周期"><a href="#clean生命周期" class="headerlink" title="clean生命周期"></a>clean生命周期</h2><ul><li>pre-clean</li><li>pre-clean</li><li>post-clean</li></ul><h2 id="site生命周期"><a href="#site生命周期" class="headerlink" title="site生命周期"></a>site生命周期</h2><ul><li>pre-site</li><li>site</li><li>post-site</li><li>post-site</li></ul>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven插件</title>
      <link href="/2018/10/12/aa_category/tool/maven/plugin/"/>
      <url>/2018/10/12/aa_category/tool/maven/plugin/</url>
      
        <content type="html"><![CDATA[<h1 id="maven-resources-plugin"><a href="#maven-resources-plugin" class="headerlink" title="maven-resources-plugin"></a>maven-resources-plugin</h1><p>复制资源到输出目录</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> plugin </tag>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>storm入门</title>
      <link href="/2018/08/31/aa_category/Bigdata&amp;AI/storm/storm%E5%85%A5%E9%97%A8/"/>
      <url>/2018/08/31/aa_category/Bigdata&amp;AI/storm/storm%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="并行度"><a href="#并行度" class="headerlink" title="并行度"></a>并行度</h1><h2 id="Workers"><a href="#Workers" class="headerlink" title="Workers"></a>Workers</h2><p>在一个节点上可以运行一个或多个独立的JVM 进程</p><a id="more"></a><h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>在一个worker JVM进程中运行着多个Java线程</p><h2 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h2><p>Task就是具体的处理逻辑对象,每一个Spout和Bolt会被当作很多task在整个集群里面执行</p>]]></content>
      
      
      <categories>
          
          <category> storm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> storm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Resource</title>
      <link href="/2018/08/31/aa_category/se/Resource/"/>
      <url>/2018/08/31/aa_category/se/Resource/</url>
      
        <content type="html"><![CDATA[<h1 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h1><p>Uniform Resource Locator<br><a href="http://www.ietf.org/rfc/rfc2396.txt" target="_blank" rel="noopener">http://www.ietf.org/rfc/rfc2396.txt</a></p><p><a href="http://www.example.com/docs/resource1.html" target="_blank" rel="noopener">http://www.example.com/docs/resource1.html</a></p><p>协议：//host:port/information</p><h2 id="relative-URL"><a href="#relative-URL" class="headerlink" title="relative URL"></a>relative URL</h2><p>不需要 协议 host port </p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>不支持编码和解码</p><h1 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h1><p>Uniform Resource Identifier</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>[scheme:]scheme-specific-part[#fragment]<br>Scheme </p><h3 id="Opaque"><a href="#Opaque" class="headerlink" title="Opaque"></a>Opaque</h3><p>mailto:<a href="mailto:java-net@java.sun.com" target="_blank" rel="noopener">java-net@java.sun.com</a></p><h3 id="hierarchical-URI"><a href="#hierarchical-URI" class="headerlink" title="hierarchical URI"></a>hierarchical URI</h3><p>[scheme:][//authority][path][?query][#fragment]</p><h4 id="authority-server-based"><a href="#authority-server-based" class="headerlink" title="authority(server-based)"></a>authority(server-based)</h4><p>[user-info@]host[:port]</p><h2 id="和URL区别"><a href="#和URL区别" class="headerlink" title="和URL区别"></a>和URL区别</h2><p>A URI is a uniform resource  identifier  while a URL is a uniform<br>  resource locator.<br> Hence every URL is a URI, but not every URI is a URL. </p>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> url </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Log</title>
      <link href="/2018/08/24/aa_category/framework/netty/Log/"/>
      <url>/2018/08/24/aa_category/framework/netty/Log/</url>
      
        <content type="html"><![CDATA[<h1 id="SLF4J"><a href="#SLF4J" class="headerlink" title="SLF4J"></a>SLF4J</h1><p><img src="concrete-bindings.png" alt="1"></p><a id="more"></a><h1 id="java-util-logging"><a href="#java-util-logging" class="headerlink" title="java.util.logging"></a>java.util.logging</h1><h1 id="logback"><a href="#logback" class="headerlink" title="logback"></a>logback</h1><h1 id="log4j2"><a href="#log4j2" class="headerlink" title="log4j2"></a>log4j2</h1><h2 id="Which-JAR-files-do-I-need"><a href="#Which-JAR-files-do-I-need" class="headerlink" title="Which JAR files do I need"></a>Which JAR files do I need</h2><p>You need at least the log4j-api-2.x and the log4j-core-2.x jar files.<br><img src="whichjar-2.x.png" alt="1"></p><h2 id="DefaultConfiguration"><a href="#DefaultConfiguration" class="headerlink" title="DefaultConfiguration"></a>DefaultConfiguration</h2><p>Log4j will provide a default configuration if it cannot locate a configuration file. The default configuration, provided in the DefaultConfiguration class, will set up:</p>]]></content>
      
      
      <categories>
          
          <category> log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> log </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring_MVC</title>
      <link href="/2018/05/16/aa_category/framework/spring/Spring-MVC-0/"/>
      <url>/2018/05/16/aa_category/framework/spring/Spring-MVC-0/</url>
      
        <content type="html"><![CDATA[<p>InternalResourceViewResolver</p><p>RequestContextUtils </p><h1 id="Special-Bean-Types"><a href="#Special-Bean-Types" class="headerlink" title="Special Bean Types"></a>Special Bean Types</h1><h2 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h2><h3 id="RequestMappingHandlerMapping"><a href="#RequestMappingHandlerMapping" class="headerlink" title="RequestMappingHandlerMapping"></a>RequestMappingHandlerMapping</h3><h2 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h2><h2 id="HandlerExceptionResolver"><a href="#HandlerExceptionResolver" class="headerlink" title="HandlerExceptionResolver"></a>HandlerExceptionResolver</h2><h2 id="ViewResolver"><a href="#ViewResolver" class="headerlink" title="ViewResolver"></a>ViewResolver</h2><h2 id="LocaleResolver-LocaleContextResolver"><a href="#LocaleResolver-LocaleContextResolver" class="headerlink" title="LocaleResolver, LocaleContextResolver"></a>LocaleResolver, LocaleContextResolver</h2><h2 id="ThemeResolver"><a href="#ThemeResolver" class="headerlink" title="ThemeResolver"></a>ThemeResolver</h2><h2 id="MultipartResolver"><a href="#MultipartResolver" class="headerlink" title="MultipartResolver"></a>MultipartResolver</h2><h2 id="FlashMapManager"><a href="#FlashMapManager" class="headerlink" title="FlashMapManager"></a>FlashMapManager</h2><h1 id="mvc-annotation-driven"><a href="#mvc-annotation-driven" class="headerlink" title="mvc:annotation-driven"></a><a href="mvc:annotation-driven" target="_blank" rel="noopener">mvc:annotation-driven</a></h1><p>@EnableWebMvc<br>The above registers a number of Spring MVC infrastructure beans also adapting to dependencies available on the classpath: e.g. payload converters for JSON, XML, etc.</p><h1 id="HttpRequestHandler"><a href="#HttpRequestHandler" class="headerlink" title="HttpRequestHandler"></a>HttpRequestHandler</h1><p>相当于一个servlet</p><h1 id="SimpleUrlHandlerMapping"><a href="#SimpleUrlHandlerMapping" class="headerlink" title="SimpleUrlHandlerMapping"></a>SimpleUrlHandlerMapping</h1><p>根据url找到对应的bean  /welcome.html=ticketController</p><h1 id="BeanNameUrlHandlerMapping"><a href="#BeanNameUrlHandlerMapping" class="headerlink" title="BeanNameUrlHandlerMapping"></a>BeanNameUrlHandlerMapping</h1><p>根据url找到对应的beand的名称有映射关系</p><h1 id="SimpleControllerHandlerAdapter"><a href="#SimpleControllerHandlerAdapter" class="headerlink" title="SimpleControllerHandlerAdapter"></a>SimpleControllerHandlerAdapter</h1>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> mvc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读写</title>
      <link href="/2018/05/12/aa_category/other/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
      <url>/2018/05/12/aa_category/other/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="基本常识"><a href="#基本常识" class="headerlink" title="基本常识"></a>基本常识</h1><ul><li>Connection代表一个连接，所有对数据库的操作最终都要通过Connection进行</li><li>DataSource是池子，里面包含许多connection</li><li>Transaction事务，通过持有的DataSource获取连接，然后通过连接的comit，rollback实现事务的概念</li></ul><a id="more"></a><h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><h2 id="有事务"><a href="#有事务" class="headerlink" title="有事务"></a>有事务</h2><ul><li>在一个事务里面获取一个连接</li><li>通过ThreadLocal实现上下文信息传输</li><li>在创建事务的时候通过判断事务的读写特性，如果是readonly则在ThreadLocal中标记为read,否则writer</li><li>获取数据源的时候根据read/writer标记，获取对应的数据源，从而获取相应的连接</li></ul><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">TransactionAspectSupport#invokeWithinTransaction</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeWithinTransaction</span><span class="params">(Method method, Class&lt;?&gt; targetClass, <span class="keyword">final</span> InvocationCallback invocation)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">   <span class="comment">// 创建事务</span></span><br><span class="line">TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line">Object retVal = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用方法</span></span><br><span class="line">retVal = invocation.proceedWithInvocation();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="comment">// 抛出异常回滚（看具体情况）</span></span><br><span class="line">completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//清除事务上下文信息，事务信息本身没有清楚</span></span><br><span class="line">cleanupTransactionInfo(txInfo);</span><br><span class="line">&#125;</span><br><span class="line">         <span class="comment">//提交</span></span><br><span class="line">commitTransactionAfterReturning(txInfo);</span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建事务"><a href="#创建事务" class="headerlink" title="创建事务"></a>创建事务</h4><ul><li>TransactionAspectSupport#invokeWithinTransaction</li><li>org.springframework.transaction.PlatformTransactionManager#getTransaction</li><li>org.springframework.transaction.support.AbstractPlatformTransactionManager#doBegin</li><li>DynamicDataSourceTransactionManager#doBegin（继承），给ThreadLocal中打上相应的标记</li><li>DataSourceTransactionManager#doBegin</li><li>AbstractRoutingDataSource#getConnection()</li><li>DynamicDataSource#determineCurrentLookupKey 根据上下文的标记获取相应的数据源，然后给出相应的连接</li></ul><h2 id="无事务"><a href="#无事务" class="headerlink" title="无事务"></a>无事务</h2><p>通过方法注解</p><h3 id="通过方法注解"><a href="#通过方法注解" class="headerlink" title="通过方法注解"></a>通过方法注解</h3><ul><li>通过aop的前置通知解析注解，给ThreadLocal中设置相应的read/writer标记</li><li>获取数据源的时候根据read/writer标记，获取对应的数据源，从而获取相应的连接</li></ul><h3 id="单条sql"><a href="#单条sql" class="headerlink" title="单条sql"></a>单条sql</h3><ul><li>通过mybatis的插件，给ThreadLocal中设置相应的read/writer标记</li><li>获取数据源的时候根据read/writer标记，获取对应的数据源，从而获取相应的连接</li></ul><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><h2 id="有事务-1"><a href="#有事务-1" class="headerlink" title="有事务"></a>有事务</h2><ul><li>@Transactional(readOnly = true) 走从库</li><li>@Transactional() 走主库</li></ul><h2 id="无事务-1"><a href="#无事务-1" class="headerlink" title="无事务"></a>无事务</h2><p>通过方法注解</p><h2 id="通过方法注解-1"><a href="#通过方法注解-1" class="headerlink" title="通过方法注解"></a>通过方法注解</h2><ul><li><p>@MethodDataSource(DynamicDataSourceType.READ) 走从库</p></li><li><p>@MethodDataSource(DynamicDataSourceType.WRITE) 走主库</p><h2 id="单条sql-1"><a href="#单条sql-1" class="headerlink" title="单条sql"></a>单条sql</h2></li><li><p>select走从库</p></li><li><p>insert/update/delete 走主库</p></li></ul><h1 id="涉及的类"><a href="#涉及的类" class="headerlink" title="涉及的类"></a>涉及的类</h1><h2 id="TransactionSynchronizationManager"><a href="#TransactionSynchronizationManager" class="headerlink" title="TransactionSynchronizationManager"></a>TransactionSynchronizationManager</h2><p>  通过ThreadLocal事务上下文信息</p><h2 id="DataSourceTransactionManager"><a href="#DataSourceTransactionManager" class="headerlink" title="DataSourceTransactionManager"></a>DataSourceTransactionManager</h2><p>   spring事务管理器，包含提交回滚</p><h2 id="SqlSessionFactoryBean"><a href="#SqlSessionFactoryBean" class="headerlink" title="SqlSessionFactoryBean"></a>SqlSessionFactoryBean</h2><ul><li>解决非springbean转换成springbean</li></ul><ul><li>mybatis的所有配置都在这个里面完成</li></ul><h2 id="MapperScannerConfigurer"><a href="#MapperScannerConfigurer" class="headerlink" title="MapperScannerConfigurer"></a>MapperScannerConfigurer</h2><ul><li>接口的实现类可以是proxy</li><li>扫描配置路径下的dao接口</li><li>通过接口找到对应的proxy</li><li>把代理注册成springbean</li></ul><h2 id="PlatformTransactionManager"><a href="#PlatformTransactionManager" class="headerlink" title="PlatformTransactionManager"></a>PlatformTransactionManager</h2><p>   spring事务管理器，包含提交回滚</p><h2 id="DynamicDataSource"><a href="#DynamicDataSource" class="headerlink" title="DynamicDataSource"></a>DynamicDataSource</h2><p>  代理数据源，根据上下文找到被代理的数据源</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> determineTargetDataSource().getConnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>什么场景使用</li><li>使用以后带来的好处</li><li>使用以后带来的坏处</li><li>使用需要注意什么-（只有对读实时性要求不高的场景适合读写分离）</li></ul><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统设计</title>
      <link href="/2018/05/04/aa_category/se/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2018/05/04/aa_category/se/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="确认需求"><a href="#确认需求" class="headerlink" title="确认需求"></a>确认需求</h1><p>用自己的术语和产品经理确认一次，由于每个人的语文水平不同，同样的话术，会有不同的理解</p><a id="more"></a><h1 id="分析需求"><a href="#分析需求" class="headerlink" title="分析需求"></a>分析需求</h1><h2 id="表面需求"><a href="#表面需求" class="headerlink" title="表面需求"></a>表面需求</h2><h2 id="内在需求"><a href="#内在需求" class="headerlink" title="内在需求"></a>内在需求</h2><h1 id="分析资源"><a href="#分析资源" class="headerlink" title="分析资源"></a>分析资源</h1><ul><li>人</li><li>时间点</li><li>依赖资源</li></ul><h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><h2 id="功能性需求"><a href="#功能性需求" class="headerlink" title="功能性需求"></a>功能性需求</h2><h2 id="非功能性需求"><a href="#非功能性需求" class="headerlink" title="非功能性需求"></a>非功能性需求</h2><ul><li>易用性</li><li>侵入型</li><li>可用性</li><li>性能</li></ul><h1 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h1><h2 id="已有轮子"><a href="#已有轮子" class="headerlink" title="已有轮子"></a>已有轮子</h2><h2 id="发明轮子"><a href="#发明轮子" class="headerlink" title="发明轮子"></a>发明轮子</h2><h1 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h1><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h2>]]></content>
      
      
      <categories>
          
          <category> 方法论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tree</title>
      <link href="/2018/04/21/aa_category/db/mysql/Tree/"/>
      <url>/2018/04/21/aa_category/db/mysql/Tree/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉查（Binary-Tree）"><a href="#二叉查（Binary-Tree）" class="headerlink" title="二叉查（Binary Tree）"></a>二叉查（Binary Tree）</h1><p>A Binary Tree is one of the most typical tree structure. As the name suggests, a binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child</p><a id="more"></a><h1 id="B树-B-tree"><a href="#B树-B-tree" class="headerlink" title="B树(B-tree)"></a>B树(B-tree)</h1><p>B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树</p><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><ul><li>树种的每个节点最多拥有m个子节点且m&gt;=2,空树除外（注：m阶代表一个树节点最多有多少个查找路径，m阶=m路,当m=2则是2叉树,m=3则是3叉）</li><li>除根节点外每个节点的关键字数量大于等于ceil(m/2)-1个小于等于m-1个，非根节点关键字数必须&gt;=2;（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2)<h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1>B+跟B树不同B+树的非叶子节点不保存关键字记录的指针，这样使得B+树每个节点所能保存的关键字大大增加</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL优化原理</title>
      <link href="/2018/04/21/aa_category/db/mysql/MySQL%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86/"/>
      <url>/2018/04/21/aa_category/db/mysql/MySQL%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="逻辑架构图"><a href="#逻辑架构图" class="headerlink" title="逻辑架构图"></a>逻辑架构图</h1><p><img src="1.png" alt><br>MySQL逻辑架构整体分为三层</p><a id="more"></a><h2 id="第一层"><a href="#第一层" class="headerlink" title="第一层"></a>第一层</h2><p>并非MYSQL独有，诸如连接处理、授权认证、安全等在这一层</p><h2 id="第二层"><a href="#第二层" class="headerlink" title="第二层"></a>第二层</h2><p>查询解析，分析，优化，缓存，内置函数。跨存储引擎的功能也在这一层：存储过程、触发器</p><h2 id="第三层"><a href="#第三层" class="headerlink" title="第三层"></a>第三层</h2><p>存储引擎，负责MYSQL中数据的存储和提取</p><h1 id="MySQL查询过程"><a href="#MySQL查询过程" class="headerlink" title="MySQL查询过程"></a>MySQL查询过程</h1><p><img src="2.png" alt></p><h1 id="客户端-服务端通信协议"><a href="#客户端-服务端通信协议" class="headerlink" title="客户端/服务端通信协议"></a>客户端/服务端通信协议</h1><ul><li>MySQL客户端/服务端通信协议是“半双工”的：在任一时刻，要么是服务器向客户端发送数据，要么是客户端向服务器发送数据，这两个动作不能同时发生。一旦一端开始发送消息，另一端要接收完整个消息才能响应它，所以我们无法也无须将一个消息切成小块独立发送，也没有办法进行流量控制。</li><li>客户端用一个单独的数据包将查询请求发送给服务器，所以当查询语句很长的时候，需要设置max_allowed_packet参数。但是需要注意的是，如果查询实在是太大，服务端会拒绝接收更多数据并抛出异常</li><li>与之相反的是，服务器响应给用户的数据通常会很多，由多个数据包组成。但是当服务器响应客户端请求时，客户端必须完整的接收整个返回结果，而不能简单的只取前面几条结果，然后让服务器停止发送</li></ul><h1 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h1><ul><li>解析查询语句之前判断缓存是否打开，如果打开，那么判断当前sql是否命中缓存，如果命中在检查一次用户权限以后直接返回查询结果</li><li>MySQL将缓存存放在一个引用表(HashMap)，通过查询语句+数据库+客户端版本号计算出索引，通过索引来定位是否命中，所以两次查询有任何不同（空格、注释）都会导致缓存没有命中</li><li>如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL库中的系统表，其查询结果都不会被缓存。比如函数NOW()或者CURRENT_DATE()会因为不同的查询时间，返回不同的查询结果，</li><li>既然是缓存，就会失效，那查询缓存何时失效呢？MySQL的查询缓存系统会跟踪查询中涉及的每个表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。正因为如此，在任何的写操作时，MySQL必须将对应表的所有缓存都设置为失效。而且查询缓存对系统的额外消耗也不仅仅在写操作，读操作也不例外：<br>任何的查询语句在开始之前都必须经过检查，即使这条SQL语句永远不会命中缓存<br>如果查询结果可以被缓存，那么执行完成后，会将结果存入缓存，也会带来额外的系统消耗</li><li>基于上面的结论，我们要知道并不是什么情况下查询缓存都会提高系统性能，缓存和失效都会带来额外消耗，只有当缓存带来的资源节约大于其本身消耗的资源时，才会给系统带来性能提升。如果系统确实存在一些性能问题，可以尝试打开查询缓存，并在数据库设计上做一些优化，比如：</li></ul><ol><li>用多个小表代替一个大表，注意不要过度设计</li><li>批量插入代替循环单条插入</li><li>合理控制缓存空间大小，一般来说其大小设置为几十兆比较合适</li><li>可以通过SQL_CACHE和SQL_NO_CACHE来控制某个查询语句是否需要进行缓存<br>最后的忠告是不要轻易打开查询缓存，特别是写密集型应用。如果你实在是忍不住，可以将query_cache_type设置为DEMAND，这时只有加入SQL_CACHE的查询才会走缓存，其他查询则不会，这样可以非常自由地控制哪些查询需要被缓存。</li></ol><h1 id="语法解析和预处理"><a href="#语法解析和预处理" class="headerlink" title="语法解析和预处理"></a>语法解析和预处理</h1><p>MySQL通过关键字将SQL语句进行解析，并生成一颗对应的解析树。这个过程解析器主要通过语法规则来验证和解析。比如SQL中是否使用了错误的关键字或者关键字的顺序是否正确等等</p><h1 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h1><p>MySQL使用基于成本的优化器，它尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。在MySQL可以通过查询当前会话的last_query_cost的值来得到其计算当前查询的成本。<br>有非常多的原因会导致MySQL选择错误的执行计划，比如统计信息不准确、不会考虑不受其控制的操作成本（用户自定义函数、存储过程）、MySQL认为的最优跟我们想的不一样（我们希望执行时间尽可能短，但MySQL值选择它认为成本小的，但成本小并不意味着执行时间短）等等</p><h1 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h1><p>查询执行引擎根据执行计划给出的指令逐步执行得出结果。整个执行过程的大部分操作均是通过调用存储引擎实现的接口来完成，这些接口被称为handler API。<br>查询过程中的每一张表由一个handler实例表示。实际上，MySQL在查询优化阶段就为每一张表创建了一个handler实例，优化器可以根据这些实例的接口来获取表的相关信息，包括表的所有列名、索引统计信息等</p><h1 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h1><p>查询执行的最后一个阶段就是将结果返回给客户端。即使查询不到数据，MySQL仍然会返回这个查询的相关信息，比如该查询影响到的行数以及执行时间等<br>结果集返回客户端是一个增量且逐步返回的过程。有可能MySQL在生成第一条结果时，就开始向客户端逐步返回结果集了。这样服务端就无须存储太多结果而消耗过多内存，也可以让客户端第一时间获得返回结果</p><h1 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h1><h2 id="Scheme设计与数据类型优化"><a href="#Scheme设计与数据类型优化" class="headerlink" title="Scheme设计与数据类型优化"></a>Scheme设计与数据类型优化</h2><p>选择数据类型只要遵循小而简单的原则就好，越小的数据类型通常会更快，占用更少的磁盘、内存，处理时需要的CPU周期也更少。越简单的数据类型在计算时需要更少的CPU周期<br>比如，整型就比字符操作代价低，因而会使用整型来存储ip地址，使用DATETIME来存储时间，而不是使用字符串</p><h2 id="这里总结几个可能容易理解错误的技巧"><a href="#这里总结几个可能容易理解错误的技巧" class="headerlink" title="这里总结几个可能容易理解错误的技巧"></a>这里总结几个可能容易理解错误的技巧</h2><ul><li>通常来说把可为NULL的列改为NOT NULL不会对性能提升有多少帮助，只是如果计划在列上创建索引，就应该将该列设置为NOT NULL</li><li>对整数类型指定宽度，比如INT(11)，没有任何卵用。INT使用32位（4个字节）存储空间，那么它的表示范围已经确定，所以INT(1)和INT(20)对于存储和计算是相同的</li><li>UNSIGNED表示不允许负值，大致可以使正数的上限提高一倍。比如TINYINT存储范围是-128 ~ 127，而UNSIGNED TINYINT存储的范围却是0 - 255</li><li>TIMESTAMP使用4个字节存储空间，DATETIME使用8个字节存储空间。因而，TIMESTAMP只能表示1970 - 2038年，比DATETIME表示的范围小得多，而且TIMESTAMP的值因时区不同而不同。</li><li>schema的列不要太多。原因是存储引擎的API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列，这个转换过程的代价是非常高的。</li><li>大表ALTER TABLE非常耗时，MySQL执行大部分修改表结果操作的方法是用新的结构创建一个张空表，从旧表中查出所有的数据插入新表，然后再删除旧表。尤其当内存不足而表又很大</li></ul><h1 id="高性能策略"><a href="#高性能策略" class="headerlink" title="高性能策略"></a>高性能策略</h1><h2 id="非独立的列"><a href="#非独立的列" class="headerlink" title="非独立的列"></a>非独立的列</h2><p>MySQL不会使用索引的情况：非独立的列 ，“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">where</span> <span class="keyword">id</span> + <span class="number">1</span> = <span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h2><p>前缀索引仅仅是选择该列的部分字符作为索引，减少索引的字符可以节约索引空间，从而提高索引效率，但这样也会降低索引的选择性 </p><h2 id="多列索引和索引顺序"><a href="#多列索引和索引顺序" class="headerlink" title="多列索引和索引顺序"></a>多列索引和索引顺序</h2><p>在多数情况下，在多个列上建立独立的索引并不能提高查询性能。。理由非常简单，MySQL不知道选择哪个索引的查询效率更好，所以在老版本，比如MySQL5.0之前就会随便选择一个列的索引，而新的版本会采用合并索引的策略。举个简单的例子，在一张电影演员表中，在actor_id和film_id两个列上都建立了独立的索引，然后有如下查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> film_id,actor_id <span class="keyword">from</span> film_actor <span class="keyword">where</span> actor_id = <span class="number">1</span> <span class="keyword">or</span> film_id = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>老版本的MySQL会随机选择一个索引，但新版本做如下的优化：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> film_id,actor_id <span class="keyword">from</span> film_actor <span class="keyword">where</span> actor_id = <span class="number">1</span> </span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> film_id,actor_id <span class="keyword">from</span> film_actor <span class="keyword">where</span> film_id = <span class="number">1</span> <span class="keyword">and</span> actor_id &lt;&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>当出现多个索引做相交操作时（多个AND条件），通常来说一个包含所有相关列的索引要优于多个独立索引</li><li>当出现多个索引做联合操作时（多个OR条件），对结果集的合并、排序等操作需要耗费大量的CPU和内存资源，特别是当其中的某些索引的选择性不高，需要返回合并大量数据时，查询成本更高。所以这种情况下还不如走全表扫描</li><li>索引的顺序对于查询是至关重要的，很明显应该把选择性更高的字段放到索引的前面，这样通过第一个字段就可以过滤掉大多数不符合条件的数据。</li><li>索引选择性是指不重复的索引值和数据表的总记录数的比值，选择性越高查询效率越高，因为选择性越高的索引可以让MySQL在查询时过滤掉更多的行。唯一索引的选择性是1，这时最好的索引选择性，性能也是最好的。</li><li>避免多个范围条件</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> film_id,actor_id <span class="keyword">from</span> film_actor <span class="keyword">where</span> actor_id = <span class="number">1</span> <span class="keyword">or</span> film_id = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这个查询有一个问题：它有两个范围条件，login_time列和age列，MySQL可以使用login_time列的索引或者age列的索引，但无法同时使用它们。</p><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><ul><li>索引条目远小于数据行大小，如果只读取索引，极大减少数据访问</li><li>索引是有按照列值顺序存储的，对于I/O密集型的范围查询要比随机从磁盘读取每一行数据的IO要少的多</li></ul><h2 id="使用索引扫描来排序"><a href="#使用索引扫描来排序" class="headerlink" title="使用索引扫描来排序"></a>使用索引扫描来排序</h2><p>只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向也一样时，才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有ORDER BY子句引用的字段全部为第一张表时，才能使用索引做排序。ORDER BY子句和查询的限制是一样的，都要满足最左前缀的要求（有一种情况例外，就是最左的列被指定为常数，下面是一个简单的示例），其它情况下都需要执行排序操作，而无法利用索引排序。</p><h2 id="冗余和重复索引"><a href="#冗余和重复索引" class="headerlink" title="冗余和重复索引"></a>冗余和重复索引</h2><p>冗余索引是指在相同的列上按照相同的顺序创建的相同类型的索引，应当尽量避免这种索引，发现后立即删除。比如有一个索引(A,B)，再创建索引(A)就是冗余索引。</p><ul><li>删除长期未使用的索引</li></ul><h1 id="特定类型查询优化"><a href="#特定类型查询优化" class="headerlink" title="特定类型查询优化"></a>特定类型查询优化</h1><h2 id="优化COUNT-查询"><a href="#优化COUNT-查询" class="headerlink" title="优化COUNT()查询"></a>优化COUNT()查询</h2><p>COUNT()可能是被大家误解最多的函数了，它有两种不同的作用，其一是统计某个列值的数量，其二是统计行数。统计列值时，要求列值是非空的，它不会统计NULL。如果确认括号中的表达式不可能为空时,实际上就是在统计行数。最简单的就是当使用COUNT(*)时，并不是我们所想象的那样扩展成所有的列，实际上，它会忽略所有的列而直接统计所有的行数</p><h2 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h2><ul><li>确保ON和USING字句中的列上有索引。在创建索引的时候就要考虑到关联的顺序。当表A和表B用列c关联的时候，如果优化器关联的顺序是A、B，那么就不需要在A表的对应列上创建索引。没有用到的索引会带来额外的负担，一般来说，除非有其他理由，只需要在关联顺序中的第二张表的相应列上创建索引</li><li>确保任何的GROUP BY和ORDER BY中的表达式只涉及到一个表中的列，这样MySQL才有可能使用索引来优化</li></ul><p>要理解优化关联查询的第一个技巧，就需要理解MySQL是如何执行关联查询的。当前MySQL关联执行的策略非常简单，它对任何的关联都执行嵌套循环关联操作，即先在一个表中循环取出单条数据，然后在嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为为止。然后根据各个表匹配的行，返回查询中需要的各个列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.xx,B.yy</span><br><span class="line"><span class="keyword">FROM</span> A <span class="keyword">INNER</span> <span class="keyword">JOIN</span> B <span class="keyword">USING</span>(c)</span><br><span class="line"><span class="keyword">WHERE</span> A.xx <span class="keyword">IN</span> (<span class="number">5</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>假设MySQL按照查询中的关联顺序A、B来进行关联操作，那么可以用下面的伪代码表示MySQL如何完成这个查询</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">outer_iterator = <span class="keyword">SELECT</span> A.xx,A.c <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> A.xx <span class="keyword">IN</span> (<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">outer_row = outer_iterator.next;</span><br><span class="line"></span><br><span class="line">while(outer_row) &#123;</span><br><span class="line"></span><br><span class="line">    inner_iterator = <span class="keyword">SELECT</span> B.yy <span class="keyword">FROM</span> B <span class="keyword">WHERE</span> B.c = outer_row.c;</span><br><span class="line"></span><br><span class="line">    inner_row = inner_iterator.next;</span><br><span class="line"></span><br><span class="line">    while(inner_row) &#123;</span><br><span class="line"></span><br><span class="line">        output[inner_row.yy,outer_row.xx];</span><br><span class="line"></span><br><span class="line">        inner_row = inner_iterator.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outer_row = outer_iterator.next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　可以看到，最外层的查询是根据A.xx列来查询的，A.c上如果有索引的话，整个关联查询也不会使用。再看内层的查询，很明显B.c上如果有索引的话，能够加速查询，因此只需要在关联顺序中的第二张表的相应列上创建索引即可。</p><h2 id="优化LIMIT分页"><a href="#优化LIMIT分页" class="headerlink" title="优化LIMIT分页"></a>优化LIMIT分页</h2><p>一个常见的问题是当偏移量非常大的时候，比如：LIMIT 10000 20这样的查询，MySQL需要查询10020条记录然后只返回20条记录，前面的10000条都将被抛弃，这样的代价非常高<br>优化这种查询一个最简单的办法就是尽可能的使用覆盖索引扫描，而不是查询所有的列<br>如果这张表非常大，那么这个查询最好改成下面的样子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film.film_id,film.description</span><br><span class="line"><span class="keyword">FROM</span> film <span class="keyword">INNER</span> <span class="keyword">JOIN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> film_id <span class="keyword">FROM</span> film <span class="keyword">ORDER</span> <span class="keyword">BY</span> title <span class="keyword">LIMIT</span> <span class="number">50</span>,<span class="number">5</span></span><br><span class="line">) <span class="keyword">AS</span> tmp <span class="keyword">USING</span>(film_id);</span><br></pre></td></tr></table></figure><h2 id="优化UNION"><a href="#优化UNION" class="headerlink" title="优化UNION"></a>优化UNION</h2><p>MySQL处理UNION的策略是先创建临时表，然后再把各个查询结果插入到临时表中，最后再来做查询。因此很多优化策略在UNION查询中都没有办法很好的时候,经常需要手动将WHERE、LIMIT、ORDER BY等字句“下推”到各个子查询中，以便优化器可以充分利用这些条件先优化。<br>除非确实需要服务器去重，否则就一定要使用UNION ALL，如果没有ALL关键字，MySQL会给临时表加上DISTINCT选项，这会导致整个临时表的数据做唯一性检查，这样做的代价非常高</p>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> db </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm-options</title>
      <link href="/2018/04/02/aa_category/se/gc&amp;mem/jvm-options/"/>
      <url>/2018/04/02/aa_category/se/gc&amp;mem/jvm-options/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>javap-指令集</title>
      <link href="/2018/04/02/aa_category/se/gc&amp;mem/javap-%E6%8C%87%E4%BB%A4%E9%9B%86/"/>
      <url>/2018/04/02/aa_category/se/gc&amp;mem/javap-%E6%8C%87%E4%BB%A4%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="栈和局部变量操作"><a href="#栈和局部变量操作" class="headerlink" title="栈和局部变量操作"></a>栈和局部变量操作</h1><h2 id="将常量压入栈的指令"><a href="#将常量压入栈的指令" class="headerlink" title="将常量压入栈的指令"></a>将常量压入栈的指令</h2><p>aconst_null 将null对象引用压入栈<br>iconst_m1 将int类型常量-1压入栈<br>iconst_0 将int类型常量0压入栈<br>iconst_1 将int类型常量1压入栈<br>iconst_2 将int类型常量2压入栈<br>iconst_3 将int类型常量3压入栈<br>iconst_4 将int类型常量4压入栈<br>iconst_5 将int类型常量5压入栈<br>lconst_0 将long类型常量0压入栈<br>lconst_1 将long类型常量1压入栈<br>fconst_0 将float类型常量0压入栈<br>fconst_1 将float类型常量1压入栈<br>dconst_0 将double类型常量0压入栈<br>dconst_1 将double类型常量1压入栈<br>bipush 将一个8位带符号整数压入栈<br>sipush 将16位带符号整数压入栈<br>ldc 把常量池中的项压入栈<br>ldc_w 把常量池中的项压入栈（使用宽索引）<br>ldc2_w 把常量池中long类型或者double类型的项压入栈（使用宽索引）</p><a id="more"></a><h2 id="从栈中的局部变量中装载值的指令"><a href="#从栈中的局部变量中装载值的指令" class="headerlink" title="从栈中的局部变量中装载值的指令"></a>从栈中的局部变量中装载值的指令</h2><p>iload 从局部变量中装载int类型值<br>lload 从局部变量中装载long类型值<br>fload 从局部变量中装载float类型值<br>dload 从局部变量中装载double类型值<br>aload 从局部变量中装载引用类型值（refernce）<br>iload_0 从局部变量0中装载int类型值<br>iload_1 从局部变量1中装载int类型值<br>iload_2 从局部变量2中装载int类型值<br>iload_3 从局部变量3中装载int类型值<br>lload_0 从局部变量0中装载long类型值<br>lload_1 从局部变量1中装载long类型值<br>lload_2 从局部变量2中装载long类型值<br>lload_3 从局部变量3中装载long类型值<br>fload_0 从局部变量0中装载float类型值<br>fload_1 从局部变量1中装载float类型值<br>fload_2 从局部变量2中装载float类型值<br>fload_3 从局部变量3中装载float类型值<br>dload_0 从局部变量0中装载double类型值<br>dload_1 从局部变量1中装载double类型值<br>dload_2 从局部变量2中装载double类型值<br>dload_3 从局部变量3中装载double类型值<br>aload_0 从局部变量0中装载引用类型值<br>aload_1 从局部变量1中装载引用类型值<br>aload_2 从局部变量2中装载引用类型值<br>aload_3 从局部变量3中装载引用类型值<br>iaload 从数组中装载int类型值<br>laload 从数组中装载long类型值<br>faload 从数组中装载float类型值<br>daload 从数组中装载double类型值<br>aaload 从数组中装载引用类型值<br>baload 从数组中装载byte类型或boolean类型值<br>caload 从数组中装载char类型值<br>saload 从数组中装载short类型值</p><h2 id="将栈中的值存入局部变量的指令"><a href="#将栈中的值存入局部变量的指令" class="headerlink" title="将栈中的值存入局部变量的指令"></a>将栈中的值存入局部变量的指令</h2><p>istore 将int类型值存入局部变量<br>lstore 将long类型值存入局部变量<br>fstore 将float类型值存入局部变量<br>dstore 将double类型值存入局部变量<br>astore 将将引用类型或returnAddress类型值存入局部变量<br>istore_0 将int类型值存入局部变量0<br>istore_1 将int类型值存入局部变量1<br>istore_2 将int类型值存入局部变量2<br>istore_3 将int类型值存入局部变量3<br>lstore_0 将long类型值存入局部变量0<br>lstore_1 将long类型值存入局部变量1<br>lstore_2 将long类型值存入局部变量2<br>lstore_3 将long类型值存入局部变量3<br>fstore_0 将float类型值存入局部变量0<br>fstore_1 将float类型值存入局部变量1<br>fstore_2 将float类型值存入局部变量2<br>fstore_3 将float类型值存入局部变量3<br>dstore_0 将double类型值存入局部变量0<br>dstore_1 将double类型值存入局部变量1<br>dstore_2 将double类型值存入局部变量2<br>dstore_3 将double类型值存入局部变量3<br>astore_0 将引用类型或returnAddress类型值存入局部变量0<br>astore_1 将引用类型或returnAddress类型值存入局部变量1<br>astore_2 将引用类型或returnAddress类型值存入局部变量2<br>astore_3 将引用类型或returnAddress类型值存入局部变量3<br>iastore 将int类型值存入数组中<br>lastore 将long类型值存入数组中<br>fastore 将float类型值存入数组中<br>dastore 将double类型值存入数组中<br>aastore 将引用类型值存入数组中<br>bastore 将byte类型或者boolean类型值存入数组中<br>castore 将char类型值存入数组中<br>sastore 将short类型值存入数组中</p><h1 id="wide指令"><a href="#wide指令" class="headerlink" title="wide指令"></a>wide指令</h1><p>wide 使用附加字节扩展局部变量索引</p><h1 id="通用-无类型）栈操作"><a href="#通用-无类型）栈操作" class="headerlink" title="通用(无类型）栈操作"></a>通用(无类型）栈操作</h1><p>nop 不做任何操作<br>pop 弹出栈顶端一个字长的内容<br>pop2 弹出栈顶端两个字长的内容<br>dup 复制栈顶部一个字长内容<br>dup_x1 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的两个字长的内容压入栈<br>dup_x2 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈<br>dup2 复制栈顶部两个字长内容<br>dup2_x1 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈<br>dup2_x2 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的四个字长的内容压入栈<br>swap 交换栈顶部两个字长内容</p><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>i2l 把int类型的数据转化为long类型<br>i2f 把int类型的数据转化为float类型<br>i2d 把int类型的数据转化为double类型<br>l2i 把long类型的数据转化为int类型<br>l2f 把long类型的数据转化为float类型<br>l2d 把long类型的数据转化为double类型<br>f2i 把float类型的数据转化为int类型<br>f2l 把float类型的数据转化为long类型<br>f2d 把float类型的数据转化为double类型<br>d2i 把double类型的数据转化为int类型<br>d2l 把double类型的数据转化为long类型<br>d2f 把double类型的数据转化为float类型<br>i2b 把int类型的数据转化为byte类型<br>i2c 把int类型的数据转化为char类型<br>i2s 把int类型的数据转化为short类型</p><h1 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h1><p>iadd 执行int类型的加法<br>ladd 执行long类型的加法<br>isub 执行int类型的减法<br>lsub 执行long类型的减法<br>imul 执行int类型的乘法<br>lmul 执行long类型的乘法<br>idiv 执行int类型的除法<br>ldiv 执行long类型的除法<br>irem 计算int类型除法的余数<br>lrem 计算long类型除法的余数<br>ineg 对一个int类型值进行取反操作<br>lneg 对一个long类型值进行取反操作<br>iinc 把一个常量值加到一个int类型的局部变量上</p><h1 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h1><p>移位操作<br>ishl 执行int类型的向左移位操作<br>lshl 执行long类型的向左移位操作<br>ishr 执行int类型的向右移位操作<br>lshr 执行long类型的向右移位操作<br>iushr 执行int类型的向右逻辑移位操作<br>lushr 执行long类型的向右逻辑移位操作</p><h1 id="按位布尔运算"><a href="#按位布尔运算" class="headerlink" title="按位布尔运算"></a>按位布尔运算</h1><p>iand 对int类型值进行“逻辑与”操作<br>land 对long类型值进行“逻辑与”操作<br>ior 对int类型值进行“逻辑或”操作<br>lor 对long类型值进行“逻辑或”操作<br>ixor 对int类型值进行“逻辑异或”操作<br>lxor 对long类型值进行“逻辑异或”操作</p><h1 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h1><p>fadd 执行float类型的加法<br>dadd 执行double类型的加法<br>fsub 执行float类型的减法<br>dsub 执行double类型的减法<br>fmul 执行float类型的乘法<br>dmul 执行double类型的乘法<br>fdiv 执行float类型的除法<br>ddiv 执行double类型的除法<br>frem 计算float类型除法的余数<br>drem 计算double类型除法的余数<br>fneg 将一个float类型的数值取反<br>dneg 将一个double类型的数值取反</p><h1 id="对象和数组"><a href="#对象和数组" class="headerlink" title="对象和数组"></a>对象和数组</h1><h2 id="对象操作指令"><a href="#对象操作指令" class="headerlink" title="对象操作指令"></a>对象操作指令</h2><p>new 创建一个新对象<br>checkcast 确定对象为所给定的类型<br>getfield 从对象中获取字段<br>putfield 设置对象中字段的值<br>getstatic 从类中获取静态字段<br>putstatic 设置类中静态字段的值<br>instanceof 判断对象是否为给定的类型</p><h2 id="数组操作指令"><a href="#数组操作指令" class="headerlink" title="数组操作指令"></a>数组操作指令</h2><p>newarray 分配数据成员类型为基本上数据类型的新数组<br>anewarray 分配数据成员类型为引用类型的新数组<br>arraylength 获取数组长度<br>multianewarray 分配新的多维数组</p><h1 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h1><h2 id="条件分支指令"><a href="#条件分支指令" class="headerlink" title="条件分支指令"></a>条件分支指令</h2><p>ifeq 如果等于0，则跳转<br>ifne 如果不等于0，则跳转<br>iflt 如果小于0，则跳转<br>ifge 如果大于等于0，则跳转<br>ifgt 如果大于0，则跳转<br>ifle 如果小于等于0，则跳转<br>if_icmpcq 如果两个int值相等，则跳转<br>if_icmpne 如果两个int类型值不相等，则跳转<br>if_icmplt 如果一个int类型值小于另外一个int类型值，则跳转<br>if_icmpge 如果一个int类型值大于或者等于另外一个int类型值，则跳转<br>if_icmpgt 如果一个int类型值大于另外一个int类型值，则跳转<br>if_icmple 如果一个int类型值小于或者等于另外一个int类型值，则跳转<br>ifnull 如果等于null，则跳转<br>ifnonnull 如果不等于null，则跳转<br>if_acmpeq 如果两个对象引用相等，则跳转<br>if_acmpnc 如果两个对象引用不相等，则跳转</p><h2 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h2><p>lcmp 比较long类型值<br>fcmpl 比较float类型值（当遇到NaN时，返回-1）<br>fcmpg 比较float类型值（当遇到NaN时，返回1）<br>dcmpl 比较double类型值（当遇到NaN时，返回-1）<br>dcmpg 比较double类型值（当遇到NaN时，返回1）</p><h2 id="无条件转移指令"><a href="#无条件转移指令" class="headerlink" title="无条件转移指令"></a>无条件转移指令</h2><p>goto 无条件跳转<br>goto_w 无条件跳转（宽索引）</p><h2 id="表跳转指令"><a href="#表跳转指令" class="headerlink" title="表跳转指令"></a>表跳转指令</h2><p>tableswitch 通过索引访问跳转表，并跳转<br>lookupswitch 通过键值匹配访问跳转表，并执行跳转操作</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>athrow 抛出异常或错误<br>finally子句<br>jsr 跳转到子例程<br>jsr_w 跳转到子例程（宽索引）<br>rct 从子例程返回</p><h1 id="方法调用与返回"><a href="#方法调用与返回" class="headerlink" title="方法调用与返回"></a>方法调用与返回</h1><h2 id="方法调用指令"><a href="#方法调用指令" class="headerlink" title="方法调用指令"></a>方法调用指令</h2><p>invokcvirtual 运行时按照对象的类来调用实例方法<br>invokespecial 根据编译时类型来调用实例方法<br>invokestatic 调用类（静态）方法<br>invokcinterface 调用接口方法</p><h2 id="方法返回指令"><a href="#方法返回指令" class="headerlink" title="方法返回指令"></a>方法返回指令</h2><p>ireturn 从方法中返回int类型的数据<br>lreturn 从方法中返回long类型的数据<br>freturn 从方法中返回float类型的数据<br>dreturn 从方法中返回double类型的数据<br>areturn 从方法中返回引用类型的数据<br>return 从方法中返回，返回值为void</p><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>montiorenter 进入并获取对象监视器<br>monitorexit 释放并退出对象监视器</p><h1 id="JVM指令助记符"><a href="#JVM指令助记符" class="headerlink" title="JVM指令助记符"></a>JVM指令助记符</h1><ul><li>变量到操作数栈：iload,iload_,lload,lload_,fload,fload_,dload,dload_,aload,aload_</li><li>操作数栈到变量：istore,istore_,lstore,lstore_,fstore,fstore_,dstore,dstor_,astore,astore_</li><li>常数到操作数栈：bipush,sipush,ldc,ldc_w,ldc2_w,aconst_null,iconst_ml,iconst_,lconst_,fconst_,dconst_</li><li>加：iadd,ladd,fadd,dadd</li><li>减：isub,lsub,fsub,dsub</li><li>乘：imul,lmul,fmul,dmul</li><li>除：idiv,ldiv,fdiv,ddiv</li><li>余数：irem,lrem,frem,drem</li><li>取负：ineg,lneg,fneg,dneg</li><li>移位：ishl,lshr,iushr,lshl,lshr,lushr</li><li>按位或：ior,lor</li><li>按位与：iand,land</li><li>按位异或：ixor,lxor</li><li>类型转换：i2l,i2f,i2d,l2f,l2d,f2d(放宽数值转换)<br>i2b,i2c,i2s,l2i,f2i,f2l,d2i,d2l,d2f(缩窄数值转换)</li><li>创建类实便：new</li><li>创建新数组：newarray,anewarray,multianwarray</li><li>访问类的域和类实例域：getfield,putfield,getstatic,putstatic</li><li>把数据装载到操作数栈：baload,caload,saload,iaload,laload,faload,daload,aaload</li><li>从操作数栈存存储到数组：bastore,castore,sastore,iastore,lastore,fastore,dastore,aastore</li><li>获取数组长度：arraylength<br>检相类实例或数组属性：instanceof,checkcast</li><li>操作数栈管理：pop,pop2,dup,dup2,dup_xl,dup2_xl,dup_x2,dup2_x2,swap</li><li>有条件转移：ifeq,iflt,ifle,ifne,ifgt,ifge,ifnull,ifnonnull,if_icmpeq,if_icmpene,<br>if_icmplt,if_icmpgt,if_icmple,if_icmpge,if_acmpeq,if_acmpne,lcmp,fcmpl<br>fcmpg,dcmpl,dcmpg</li><li>复合条件转移：tableswitch,lookupswitch</li><li>无条件转移：goto,goto_w,jsr,jsr_w,ret</li><li>调度对象的实便方法：invokevirtual</li><li>调用由接口实现的方法：invokeinterface</li><li>调用需要特殊处理的实例方法：invokespecial</li><li>调用命名类中的静态方法：invokestatic</li><li>方法返回：ireturn,lreturn,freturn,dreturn,areturn,return</li><li>异常：athrow<br>finally关键字的实现使用：jsr,jsr_w,ret</li></ul>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟机 </tag>
            
            <tag> 指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql-explain</title>
      <link href="/2018/03/30/aa_category/db/mysql/mysql-explain%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
      <url>/2018/03/30/aa_category/db/mysql/mysql-explain%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PPT</title>
      <link href="/2018/03/30/aa_category/tool/PPT/"/>
      <url>/2018/03/30/aa_category/tool/PPT/</url>
      
        <content type="html"><![CDATA[<h1 id="ECharts"><a href="#ECharts" class="headerlink" title="ECharts"></a>ECharts</h1><h1 id="百度识图"><a href="#百度识图" class="headerlink" title="百度识图"></a>百度识图</h1><p>如果有一张模糊的图片找到清晰的图片 </p><h1 id="袋鼠输入-百度"><a href="#袋鼠输入-百度" class="headerlink" title="袋鼠输入(百度)"></a>袋鼠输入(百度)</h1><p>手机遥控电脑工具</p><h1 id="腾讯智图"><a href="#腾讯智图" class="headerlink" title="腾讯智图"></a>腾讯智图</h1><p>无损压缩图片</p><h1 id="canvas图片设计平台"><a href="#canvas图片设计平台" class="headerlink" title="canvas图片设计平台"></a>canvas图片设计平台</h1><p><a href="http://canvas.qq.com/index" target="_blank" rel="noopener">http://canvas.qq.com/index</a></p><h1 id="iconfont"><a href="#iconfont" class="headerlink" title="iconfont"></a>iconfont</h1><p>阿里巴巴出品的矢量图标库<br><a href="http://iconfont.cn/home/index" target="_blank" rel="noopener">http://iconfont.cn/home/index</a></p><h1 id="百度图说"><a href="#百度图说" class="headerlink" title="百度图说"></a>百度图说</h1><p><a href="http://tushuo.baidu.com/" target="_blank" rel="noopener">http://tushuo.baidu.com/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Object</title>
      <link href="/2018/03/23/aa_category/se/Object-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2018/03/23/aa_category/se/Object-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="registerNatives"><a href="#registerNatives" class="headerlink" title="registerNatives"></a>registerNatives</h1><p>Here’s the associated C code (from OpenJDK 6):</p><p>static JNINativeMethod methods[] = {<br>    {“hashCode”,    “()I”,                    (void *)&amp;JVM_IHashCode},<br>    {“wait”,        “(J)V”,                   (void *)&amp;JVM_MonitorWait},<br>    {“notify”,      “()V”,                    (void *)&amp;JVM_MonitorNotify},<br>    {“notifyAll”,   “()V”,                    (void *)&amp;JVM_MonitorNotifyAll},<br>    {“clone”,       “()Ljava/lang/Object;”,   (void *)&amp;JVM_Clone},<br>};</p><a id="more"></a><p>JNIEXPORT void JNICALL<br>Java_java_lang_Object_registerNatives(JNIEnv <em>env, jclass cls)<br>{<br>    (</em>env)-&gt;RegisterNatives(env, cls,<br>                            methods, sizeof(methods)/sizeof(methods[0]));<br>}</p><h1 id="getClass"><a href="#getClass" class="headerlink" title="getClass"></a>getClass</h1><h1 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h1><p>consistent<br>equals相同hashcode必须相同<br>unequal，则hashcode可以相同，但是最好不同</p><h1 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h1><p>reflexive<br>symmetric<br>transitive<br>consistent</p><h1 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h1><p>文本的形式，表达这个对象，应该简单但是I信息丰富，且易于人类阅读</p><h1 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h1><p>唤醒等待对象监控的一个线程，随意选择一个线程唤醒。<br>唤醒的线程竞争对象的监控，直到当前线程丢弃对象的监控<br>唤醒的线程和其他线程竞争对象的锁，唤醒的线程没有任何特权或者低权限<br>这个方法只能被获取对象监控的线程调用，获取线程监控的方式有三，1 调用同步代码块，调用同步对象方法，调用同步类方法</p><h1 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll"></a>notifyAll</h1><p>唤醒所有等待对象监控的线程</p><h1 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h1><p>当前线程必须拥有对象的monitor<br>把当前线程放置到对象的等待队列，<br>唤醒线程的方式，notify，notifyAll，Thread#interrupt，real time has elapsed,</p><h1 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h1><p>x.clone() != x<br>x.clone().getClass() == x.getClass()<br>x.clone().equals(x)</p>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> source </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>log4j2配置详解</title>
      <link href="/2018/03/07/aa_category/framework/netty/log4j2%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/03/07/aa_category/framework/netty/log4j2%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>slf4j-log4j12 适配</p>]]></content>
      
      
      <categories>
          
          <category> log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> log4j2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis入门</title>
      <link href="/2018/03/05/aa_category/middleware/redis/Redis%E5%85%A5%E9%97%A8/"/>
      <url>/2018/03/05/aa_category/middleware/redis/Redis%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h1><p>Redis 是一个使用 C 语言写成的，开源的 key-value 数据库。。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave</p><a id="more"></a><h1 id="Redis与Memcached的区别与比较"><a href="#Redis与Memcached的区别与比较" class="headerlink" title="Redis与Memcached的区别与比较"></a>Redis与Memcached的区别与比较</h1><ol><li>Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String</li><li>Redis支持数据的备份，即master-slave模式的数据备份</li><li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中</li><li>redis的速度比memcached快很多</li><li>Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的IO复用模型</li></ol><h1 id="Redis常见数据结构使用场景"><a href="#Redis常见数据结构使用场景" class="headerlink" title="Redis常见数据结构使用场景"></a>Redis常见数据结构使用场景</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><blockquote><p>常用命令: set,get,decr,incr,mget 等</p></blockquote><p>String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 常规key-value缓存应用； 常规计数：微博数，粉丝数等</p><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><blockquote><p>常用命令： hget,hset,hgetall 等</p></blockquote><p>Hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。 比如我们可以Hash数据结构来存储用户信息，商品信息等等。</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><blockquote><p>常用命令: lpush,rpush,lpop,rpop,lrange等</p></blockquote><p>list就是链表，Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表，最新消息排行等功能都可以用Redis的list结构来实现。<br>Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><blockquote><p>常用命令： sadd,spop,smembers,sunion 等</p></blockquote><p>set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的。 当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的<br>在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如共同关注、共同喜好、二度好友等功能。</p><h2 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h2><blockquote><p>常用命令： zadd,zrange,zrem,zcard等</p></blockquote><p>和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列<br>举例： 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用Redis中的SortedSet结构进行存储。</p><h1 id="Redis有哪些数据淘汰策略"><a href="#Redis有哪些数据淘汰策略" class="headerlink" title="Redis有哪些数据淘汰策略"></a>Redis有哪些数据淘汰策略</h1><ol><li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>no-enviction（驱逐）：禁止驱逐数据</li></ol>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> db </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIO:Socket</title>
      <link href="/2018/02/04/aa_category/framework/netty/NIO-Socket/"/>
      <url>/2018/02/04/aa_category/framework/netty/NIO-Socket/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NIO:Channel</title>
      <link href="/2018/02/03/aa_category/framework/netty/NIO-Channel/"/>
      <url>/2018/02/03/aa_category/framework/netty/NIO-Channel/</url>
      
        <content type="html"><![CDATA[<p>所有的 NIO 的 I/O 操作都是从 Channel 开始的. 一个 channel 类似于一个 stream.<br>java Stream 和 NIO Channel 对比</p><ul><li>channel可以进行读写，而stream只能进行读或者写</li><li>channel可以同步和异步，而stream只能是同步</li><li>channel是从buffer中读取数据，把数据写入buffer中</li></ul><a id="more"></a><h1 id="Channel-类型有"><a href="#Channel-类型有" class="headerlink" title="Channel 类型有:"></a>Channel 类型有:</h1><p>FileChannel, 文件操作<br>DatagramChannel, UDP 操作<br>SocketChannel, TCP 操作<br>ServerSocketChannel, TCP 操作, 使用在服务器端.<br>这些通道涵盖了 UDP 和 TCP网络 IO以及文件 IO</p><h2 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String path = ChannelDemo1.class.getResource(<span class="string">""</span>).getPath();</span><br><span class="line">        System.out.println(path);</span><br><span class="line">        RandomAccessFile r = <span class="keyword">new</span> RandomAccessFile( <span class="string">"ChannelDemo1"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        read(r);</span><br><span class="line">        write(r);</span><br><span class="line">        r.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(RandomAccessFile r)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileChannel channel = r.getChannel();</span><br><span class="line">        String addStr = <span class="string">"hello writer\r\n"</span>;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1044</span>);</span><br><span class="line">        buffer.clear();</span><br><span class="line"></span><br><span class="line">         buffer.put(addStr.getBytes());</span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">            channel.write(buffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(RandomAccessFile r)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileChannel fileChannel = r.getChannel();</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">int</span> read = fileChannel.read(byteBuffer);</span><br><span class="line">        <span class="keyword">while</span> (read!=-<span class="number">1</span>)&#123;</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            <span class="keyword">while</span> (byteBuffer.hasRemaining())&#123;</span><br><span class="line">                <span class="keyword">byte</span> b = byteBuffer.get();</span><br><span class="line">                System.out.print((<span class="keyword">char</span>)b);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">            read = fileChannel.read(byteBuffer);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="FileChannel-read-ByteBuffer"><a href="#FileChannel-read-ByteBuffer" class="headerlink" title="FileChannel.read(ByteBuffer)"></a>FileChannel.read(ByteBuffer)</h3><p>1、申请一块和缓存同大小的DirectByteBuffer bb。<br>2、读取数据到缓存bb，底层由NativeDispatcher的read实现。<br>3、把bb的数据读取到dst（用户定义的缓存，在jvm中分配内存）。</p><h3 id="FileChannel-write-ByteBuffer"><a href="#FileChannel-write-ByteBuffer" class="headerlink" title="FileChannel.write(ByteBuffer)"></a>FileChannel.write(ByteBuffer)</h3><p>1、申请一块DirectByteBuffer，bb大小为byteBuffer中的limit - position。<br>2、复制byteBuffer中的数据到bb中。<br>3、把数据从bb中写入到文件，底层由NativeDispatcher的write实现</p><h2 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">            <span class="keyword">int</span> recvMsgSize = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] recvBuf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                Socket clntSocket = serverSocket.accept();</span><br><span class="line">                SocketAddress clientAddress = clntSocket.getRemoteSocketAddress();</span><br><span class="line">                System.out.println(<span class="string">"Handling client at "</span>+clientAddress);</span><br><span class="line">                in = clntSocket.getInputStream();</span><br><span class="line">                <span class="keyword">while</span>((recvMsgSize=in.read(recvBuf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] temp = <span class="keyword">new</span> <span class="keyword">byte</span>[recvMsgSize];</span><br><span class="line">                    System.arraycopy(recvBuf, <span class="number">0</span>, temp, <span class="number">0</span>, recvMsgSize);</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(temp));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;  <span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(serverSocket!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(in!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        SocketChannel socketChannel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            socketChannel = SocketChannel.open();</span><br><span class="line">            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>,<span class="number">8080</span>));</span><br><span class="line">            <span class="keyword">while</span> (!socketChannel.finishConnect())&#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    String info = <span class="string">"I'm "</span>+i+++<span class="string">"-th information from client"</span>;</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                    buffer.put(info.getBytes());</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    <span class="keyword">while</span>(buffer.hasRemaining())&#123;</span><br><span class="line">                        System.out.println(buffer);</span><br><span class="line">                        socketChannel.write(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException | InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(socketChannel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    socketChannel.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h2><p>打开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DatagramChannel channel = DatagramChannel.open();</span><br><span class="line">channel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br></pre></td></tr></table></figure><p>读取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">channel.receive(buf);</span><br></pre></td></tr></table></figure><p>读取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String newData = <span class="string">"New String to write to file..."</span></span><br><span class="line">                    + System.currentTimeMillis();</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bytesSent = channel.send(buf, <span class="keyword">new</span> InetSocketAddress(<span class="string">"example.com"</span>, <span class="number">80</span>));</span><br></pre></td></tr></table></figure><p>连接到指定地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"example.com"</span>, <span class="number">80</span>));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> nio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIO:Buffer</title>
      <link href="/2018/02/03/aa_category/framework/netty/NIO-Buffer/"/>
      <url>/2018/02/03/aa_category/framework/netty/NIO-Buffer/</url>
      
        <content type="html"><![CDATA[<p>channle和数据的交互都是使用buffer进行的，buffer其实就是一块内存区域，我们可以在这块内存区域中进行数据的读写，NIO Buffer 其实是这样的内存块的一个封装, 并提供了一些操作方法让我们能够方便地进行数据的读写.<br>Buffer 类型有:</p><p>ByteBuffer<br>CharBuffer<br>DoubleBuffer<br>FloatBuffer<br>IntBuffer<br>LongBuffer<br>ShortBuffer<br>这些 Buffer 覆盖了能从 IO 中传输的所有的 Java 基本数据类型.</p><a id="more"></a><h1 id="NIO-Buffer-的基本使用"><a href="#NIO-Buffer-的基本使用" class="headerlink" title="NIO Buffer 的基本使用"></a>NIO Buffer 的基本使用</h1><ul><li>将数据写入到 Buffer 中</li><li>调用 Buffer.flip()方法, 将 NIO Buffer 转换为读模式</li><li>从 Buffer 中读取数据</li><li>调用 Buffer.clear() 或 Buffer.compact()方法, 将 Buffer 转换为写模式.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntBuffer intBuffer = IntBuffer.allocate(<span class="number">2</span>);</span><br><span class="line">        intBuffer.put(<span class="number">12345678</span>);</span><br><span class="line">        intBuffer.put(<span class="number">2</span>);</span><br><span class="line">        intBuffer.flip();</span><br><span class="line">        System.err.println(intBuffer.get());</span><br><span class="line">        System.err.println(intBuffer.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Buffer-属性"><a href="#Buffer-属性" class="headerlink" title="Buffer 属性"></a>Buffer 属性</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mark = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1.png" alt></p><h2 id="mark"><a href="#mark" class="headerlink" title="mark"></a>mark</h2><p>mark 用于备份当前的position，以便后续的重置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">mark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mark = position;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = mark;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidMarkException();</span><br><span class="line">    position = m;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="capacity"><a href="#capacity" class="headerlink" title="capacity"></a>capacity</h2><p>缓存数组大小</p><h2 id="position"><a href="#position" class="headerlink" title="position"></a>position</h2><ul><li>写模式下position++</li><li>flip方法会重置position=0</li><li>读模式下position++</li></ul><h2 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h2><ul><li>写模式，代表最多能写多少单位数据和容量是一样的</li><li>读模式，代表最多能读多少单位数据，和之前写入的单位数据量一致</li></ul><h1 id="分配-Buffer"><a href="#分配-Buffer" class="headerlink" title="分配 Buffer"></a>分配 Buffer</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">CharBuffer buf = CharBuffer.allocate(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure><h1 id="Direct-Buffer-和-Non-Direct-Buffer-的区别"><a href="#Direct-Buffer-和-Non-Direct-Buffer-的区别" class="headerlink" title="Direct Buffer 和 Non-Direct Buffer 的区别"></a>Direct Buffer 和 Non-Direct Buffer 的区别</h1><h2 id="Direct-Buffer"><a href="#Direct-Buffer" class="headerlink" title="Direct Buffer"></a>Direct Buffer</h2><ul><li>所分配的内存不在 JVM 堆上, 不受 GC 的管理.(但是 Direct Buffer 的 Java 对象是由 GC 管理的, 因此当发生 GC, 对象被回收时, Direct Buffer 也会被释放)</li><li>因为 Direct Buffer 不在 JVM 堆上分配, 因此 Direct Buffer 对应用程序的内存占用的影响就不那么明显(实际上还是占用了这么多内存, 但是 JVM 不好统计到非 JVM 管理的内存.)</li><li>申请和释放 Direct Buffer 的开销比较大. 因此正确的使用 Direct Buffer 的方式是在初始化时申请一个 Buffer, 然后不断复用此 buffer, 在程序结束后才释放此 buffer.</li><li>使用 Direct Buffer 时, 当进行一些底层的系统 IO 操作时, 效率会比较高, 因为此时 JVM 不需要拷贝 buffer 中的内存到中间临时缓冲区中.</li></ul><h2 id="Non-Direct-Buffer"><a href="#Non-Direct-Buffer" class="headerlink" title="Non-Direct Buffer"></a>Non-Direct Buffer</h2><ul><li>直接在 JVM 堆上进行内存的分配, 本质上是 byte[] 数组的封装.</li><li>因为 Non-Direct Buffer 在 JVM 堆中, 因此当进行操作系统底层 IO 操作中时, 会将此 buffer 的内存复制到中间临时缓冲区中. 因此 Non-Direct Buffer 的效率就较低</li></ul>]]></content>
      
      
      <categories>
          
          <category> nio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty:ChannelPipeline</title>
      <link href="/2018/02/03/aa_category/framework/netty/Netty-ChannelPipeline/"/>
      <url>/2018/02/03/aa_category/framework/netty/Netty-ChannelPipeline/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>每个channel维护一个ChannelPipeline,ChannelPipeline中维护了一个由ChannelContext组成的双向链表，表头是HeadContext,表尾是TailContext,而每个ChannelContext又维护一个ChannelHandler</p><a id="more"></a><p><img src="cpl01.png" alt="cpl01"></p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.parent = parent;</span><br><span class="line">      id = newId();</span><br><span class="line">      unsafe = newUnsafe();</span><br><span class="line">      pipeline = newChannelPipeline(); <span class="comment">//DefaultChannelPipeline</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>从上面的构造方法可以看出channel持有一个pipeline对象的引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">"channel"</span>);</span><br><span class="line">       succeededFuture = <span class="keyword">new</span> SucceededChannelFuture(channel, <span class="keyword">null</span>);</span><br><span class="line">       voidPromise =  <span class="keyword">new</span> VoidChannelPromise(channel, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">       tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>);</span><br><span class="line">       head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">       head.next = tail;</span><br><span class="line">       tail.prev = head;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> HeadContext 和 TailContext 继承于 AbstractChannelHandlerContext 的同时也实现了 ChannelHandler 接口了, 因此它们有 Context 和 Handler 的双重属性</p><h1 id="head-和-tail的类层次结构"><a href="#head-和-tail的类层次结构" class="headerlink" title="head 和 tail的类层次结构"></a>head 和 tail的类层次结构</h1><p><img src="HeadContext.png" alt="HeadContext"><br><img src="TailContext.png" alt="TailContext"></p><h2 id="ChannelInitializer"><a href="#ChannelInitializer" class="headerlink" title="ChannelInitializer"></a>ChannelInitializer</h2><p>ChannelInitializer 继承了ChannelInboundHandlerAdapter，说明其实际就是一个channel，ChannelInitializer是在Bootstrap.init 方法中添加到 ChannelPipeline </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">b.group(group)</span><br><span class="line"> .channel(NioSocketChannel.class)</span><br><span class="line"> .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line"> .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         ChannelPipeline p = ch.pipeline();</span><br><span class="line">         p.addLast(<span class="keyword">new</span> EchoClientHandler());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line">    p.addLast(handler());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="cpl02.png" alt="2"><br>有朋友可能就有疑惑了, 我明明插入的是一个 ChannelInitializer 实例, 为什么在 ChannelPipeline 中的双向链表中的元素却是一个 ChannelHandlerContext? 为了解答这个问题, 我们继续在代码中寻找答案吧.上面的代码会调用到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            checkMultiplicity(handler);</span><br><span class="line"><span class="comment">// 关键，通过handler生成一个context</span></span><br><span class="line">            newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line">            addLast0(newCtx);</span><br><span class="line">        &#125;</span><br><span class="line">        callHandlerAdded0(newCtx);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">newContext</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelHandlerContext(<span class="keyword">this</span>, childExecutor(group), name, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">DefaultChannelHandlerContext(</span><br><span class="line">            DefaultChannelPipeline pipeline, EventExecutor executor, String name, ChannelHandler handler) &#123;</span><br><span class="line">        <span class="keyword">super</span>(pipeline, executor, name, isInbound(handler), isOutbound(handler));</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"handler"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addLast0</span><span class="params">(AbstractChannelHandlerContext newCtx)</span> </span>&#123;</span><br><span class="line">        AbstractChannelHandlerContext prev = tail.prev;</span><br><span class="line">        newCtx.prev = prev;</span><br><span class="line">        newCtx.next = tail;</span><br><span class="line">        prev.next = newCtx;</span><br><span class="line">        tail.prev = newCtx;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h1><ul><li>AbstractBootstrap.initAndRegister通过 group().register(channel), 调用 MultithreadEventLoopGroup.register 方法</li><li>MultithreadEventLoopGroup.register 中, 通过 next() 获取一个可用的 SingleThreadEventLoop, 然后调用它的 register</li><li>SingleThreadEventLoop.register 中, 通过 channel.unsafe().register(this, promise) 来获取 channel 的 unsafe() 底层操作对象, 然后调用它的 register</li><li>unsafe.register 方法中, 调用 AbstractUnsafe.register0 方法注册 Channel</li><li>在 AbstractUnsafe.register0 中, 调用 AbstractNioChannel.doRegister 方法</li><li>AbstractNioChannel.doRegister 方法通过 javaChannel().register(eventLoop().selector, 0, this) 将 Channel 对应的 Java NIO SockerChannel 注册到一个 eventLoop 的 Selector 中, 并且将当前 Channel 作为 attachment.</li></ul><p>ChannelHandler 的添加过程, 发生在 AbstractUnsafe.register0 中,<br>io.netty.channel.AbstractChannel.AbstractUnsafe#register0<br>io.netty.channel.DefaultChannelPipeline#fireChannelRegistered<br>io.netty.channel.AbstractChannelHandlerContext#invokeChannelRegistered </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelRegistered</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ((ChannelInboundHandler) handler()).channelRegistered(<span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                notifyHandlerException(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fireChannelRegistered();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// HeadContext</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            invokeHandlerAddedIfNeeded();</span><br><span class="line">            ctx.fireChannelRegistered();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="传播机制"><a href="#传播机制" class="headerlink" title="传播机制"></a>传播机制</h1><h2 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h2><p>inbound 为true代表入事件<br>outbound 为true代表出事件</p><h2 id="Inbound-事件传播方法有"><a href="#Inbound-事件传播方法有" class="headerlink" title="Inbound 事件传播方法有"></a>Inbound 事件传播方法有</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ChannelHandlerContext.fireChannelRegistered()</span><br><span class="line">ChannelHandlerContext.fireChannelActive()</span><br><span class="line">ChannelHandlerContext.fireChannelRead(Object)</span><br><span class="line">ChannelHandlerContext.fireChannelReadComplete()</span><br><span class="line">ChannelHandlerContext.fireExceptionCaught(Throwable)</span><br><span class="line">ChannelHandlerContext.fireUserEventTriggered(Object)</span><br><span class="line">ChannelHandlerContext.fireChannelWritabilityChanged()</span><br><span class="line">ChannelHandlerContext.fireChannelInactive()</span><br><span class="line">ChannelHandlerContext.fireChannelUnregistered()</span><br></pre></td></tr></table></figure><h2 id="Oubound-事件传输方法有"><a href="#Oubound-事件传输方法有" class="headerlink" title="Oubound 事件传输方法有"></a>Oubound 事件传输方法有</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ChannelHandlerContext.bind(SocketAddress, ChannelPromise)</span><br><span class="line">ChannelHandlerContext.connect(SocketAddress, SocketAddress, ChannelPromise)</span><br><span class="line">ChannelHandlerContext.write(Object, ChannelPromise)</span><br><span class="line">ChannelHandlerContext.flush()</span><br><span class="line">ChannelHandlerContext.read()</span><br><span class="line">ChannelHandlerContext.disconnect(ChannelPromise)</span><br><span class="line">ChannelHandlerContext.close(ChannelPromise)</span><br></pre></td></tr></table></figure><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">                                            I/O Request</span><br><span class="line">                                        via Channel or</span><br><span class="line">                                    ChannelHandlerContext</span><br><span class="line">                                                  |</span><br><span class="line">+---------------------------------------------------+---------------+</span><br><span class="line">|                           ChannelPipeline         |               |</span><br><span class="line">|                                                  \|/              |</span><br><span class="line">|    +---------------------+            +-----------+----------+    |</span><br><span class="line">|    | Inbound Handler  N  |            | Outbound Handler  1  |    |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|              /|\                                  |               |</span><br><span class="line">|               |                                  \|/              |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|    | Inbound Handler N-1 |            | Outbound Handler  2  |    |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|              /|\                                  .               |</span><br><span class="line">|               .                                   .               |</span><br><span class="line">| ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|</span><br><span class="line">|        [ method call]                       [method call]         |</span><br><span class="line">|               .                                   .               |</span><br><span class="line">|               .                                  \|/              |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|    | Inbound Handler  2  |            | Outbound Handler M-1 |    |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|              /|\                                  |               |</span><br><span class="line">|               |                                  \|/              |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|    | Inbound Handler  1  |            | Outbound Handler  M  |    |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|              /|\                                  |               |</span><br><span class="line">+---------------+-----------------------------------+---------------+</span><br><span class="line">              |                                  \|/</span><br><span class="line">+---------------+-----------------------------------+---------------+</span><br><span class="line">|               |                                   |               |</span><br><span class="line">|       [ Socket.read() ]                    [ Socket.write() ]     |</span><br><span class="line">|                                                                   |</span><br><span class="line">|  Netty Internal I/O Threads (Transport Implementation)            |</span><br><span class="line">+-------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>inbound 事件的流行是从下至上, 而 outbound 刚好相反, 是从上到下. 并且 inbound 的传递方式是通过调用相应的 ChannelHandlerContext.fireIN_EVT() 方法, 而 outbound 方法的的传递方式是通过调用 ChannelHandlerContext.OUT_EVT() 方法. 例如 ChannelHandlerContext.fireChannelRegistered() 调用会发送一个 ChannelRegistered 的 inbound 给下一个ChannelHandlerContext, 而 ChannelHandlerContext.bind 调用会发送一个 bind 的 outbound 事件给 下一个 ChannelHandlerContext.<br>例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInboundHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Connected!"</span>);</span><br><span class="line">        ctx.fireChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> clas MyOutboundHandler extends ChannelOutboundHandlerAdapter &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Closing .."</span>);</span><br><span class="line">        ctx.close(promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Outbound-操作"><a href="#Outbound-操作" class="headerlink" title="Outbound 操作"></a>Outbound 操作</h2><p>Outbound 事件都是请求事件(request event), 即请求某件事情的发生, 然后通过 Outbound 事件进行通知.<br>Outbound 事件的传播方向是 tail -&gt; customContext -&gt; head.<br>接下来以 connect 事件为例, 分析一下 Outbound 事件的传播机制.<br>Bootstrap.connect -&gt; Bootstrap.doConnect -&gt; AbstractChannel.connect-&gt;  DefaultChannelPipeline.connect-&gt;tail.connect<br>outbound 事件(这里是 connect 事件)传递到 Pipeline 后, 它其实是以 tail 为起点开始传播的.<br>而 tail.connect 其实调用的是 AbstractChannelHandlerContext.connect 方法,然后事件一直传递，直至到了HeadContext</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HeadContext</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                SocketAddress remoteAddress, SocketAddress localAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">                ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            unsafe.connect(remoteAddress, localAddress, promise);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>当 Connect 这个 Outbound 传播到 unsafe 后, 其实是在 AbstractNioUnsafe.connect 方法中进行处理的,在 AbstractNioUnsafe.connect 中, 首先调用 doConnect 方法进行实际上的 Socket 连接, 当连接上后, 会调用 fulfillConnectPromise 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (doConnect(remoteAddress, localAddress)) &#123;</span><br><span class="line">        fulfillConnectPromise(promise, wasActive);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fulfillConnectPromise</span><span class="params">(ChannelPromise promise, <span class="keyword">boolean</span> wasActive)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Regardless if the connection attempt was cancelled, channelActive() event should be triggered,</span></span><br><span class="line">    <span class="comment">// because what happened is what happened.</span></span><br><span class="line">    <span class="keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;</span><br><span class="line">        pipeline().fireChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到, 在 fulfillConnectPromise 中, 会通过调用 pipeline().fireChannelActive() 将通道激活的消息(即 Socket 连接成功)发送出去.<br>而这里, 当调用 pipeline.fireXXX 后, 就是 Inbound 事件的起点</p><h2 id="Inbound-事件"><a href="#Inbound-事件" class="headerlink" title="Inbound 事件"></a>Inbound 事件</h2><p>Inbound 事件是一个通知事件, 即某件事已经发生了, 然后通过 Inbound 事件进行通知. Inbound 通常发生在 Channel 的状态的改变或 IO 事件就绪<br>Inbound 的特点是它传播方向是 head -&gt; customContext -&gt; tail</p><p>在Outbound事件中分析到了pipeline.fireXXX，接着往下分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//  Inbound 事件在 Pipeline 中传输的起点是 head</span></span><br><span class="line">       AbstractChannelHandlerContext.invokeChannelActive(head);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Outbound事件一直传输，直到了TailContext,通过查看代码发现TailContext什么也没有做</p>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty:Future</title>
      <link href="/2018/02/01/aa_category/framework/netty/Netty-Future/"/>
      <url>/2018/02/01/aa_category/framework/netty/Netty-Future/</url>
      
        <content type="html"><![CDATA[<h1 id="jdk-Future"><a href="#jdk-Future" class="headerlink" title="jdk Future"></a>jdk Future</h1><p>异步结果的计算<br>cancel isCancelled  isDone get </p><h1 id="netty-Future"><a href="#netty-Future" class="headerlink" title="netty Future"></a>netty Future</h1><p>isSuccess isCancellable cause addListener removeListener sync await</p><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>继承 netty Future<br>setSuccess  trySuccess  setFailure</p><h1 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h1><p>channel<br>isVoid</p><h1 id="ChannelPromise-extends-ChannelFuture-Promise"><a href="#ChannelPromise-extends-ChannelFuture-Promise" class="headerlink" title="ChannelPromise  extends ChannelFuture, Promise"></a>ChannelPromise  extends ChannelFuture, Promise<void></void></h1><p>setSuccess trySuccess unvoid</p><h1 id="DefaultChannelPromise"><a href="#DefaultChannelPromise" class="headerlink" title="DefaultChannelPromise"></a>DefaultChannelPromise</h1>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty源码分析01</title>
      <link href="/2018/01/31/aa_category/framework/netty/Netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9001/"/>
      <url>/2018/01/31/aa_category/framework/netty/Netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9001/</url>
      
        <content type="html"><![CDATA[<p>ConstantPool 常量池，内部持有一个map,    通过子类复写newConstant实现自定义</p><p>ChannelOption  通道的选项</p><p>ChannelPipeline  责任链的链条</p><p>EventLoopGroup  池化思想</p><p>ChannelHandler 处理器</p><p>ChannelOutboundInvoker  通道出栈调用者</p><p>SelectionKey 就是组合了下Selector和channel<br>Selector  持有SelectionKey集合的引用</p><p>io.netty.bootstrap.ServerBootstrap#init<br>初始化 ChannelOption，主要用来存储功能参数，比如系统的设置<br>初始化 AttributeKey，主要用来存储业务属性，目的不同<br>将ServerBootstrap的handle添加到pipline</p><h1 id="io-netty-bootstrap-AbstractBootstrap-doBind0"><a href="#io-netty-bootstrap-AbstractBootstrap-doBind0" class="headerlink" title="io.netty.bootstrap.AbstractBootstrap#doBind0"></a>io.netty.bootstrap.AbstractBootstrap#doBind0</h1><h1 id="io-netty-channel-AbstractChannel-AbstractUnsafe-register0"><a href="#io-netty-channel-AbstractChannel-AbstractUnsafe-register0" class="headerlink" title="io.netty.channel.AbstractChannel.AbstractUnsafe#register0"></a>io.netty.channel.AbstractChannel.AbstractUnsafe#register0</h1><p>io.netty.channel.nio.AbstractNioChannel#doRegister</p><p>java.nio.channels.spi.AbstractSelectableChannel#register</p><p>io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read<br>io.netty.channel.socket.nio.NioServerSocketChannel#doReadMessages</p><p>io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead<br>将启动时传入的 childHandler 加入到客户端 SocketChannel 的ChannelPipeline 中<br>设置客户端 SocketChannel 的 TCP 参数<br>注册 SocketChannel 到多路复用器</p><p>io.netty.channel.AbstractChannel#connect(java.net.SocketAddress, java.net.SocketAddress, io.netty.channel.ChannelPromise)</p><h1 id="DefaultEventExecutorChooserFactory"><a href="#DefaultEventExecutorChooserFactory" class="headerlink" title="DefaultEventExecutorChooserFactory"></a>DefaultEventExecutorChooserFactory</h1><p>工厂模式和单例模式一起出现</p><h1 id="DefaultSelectStrategy"><a href="#DefaultSelectStrategy" class="headerlink" title="DefaultSelectStrategy"></a>DefaultSelectStrategy</h1><p>实现选择的策略   SELECT  阻塞的  CONTINUE  非阻塞的</p><h1 id="DefaultThreadFactory-线程工厂类"><a href="#DefaultThreadFactory-线程工厂类" class="headerlink" title="DefaultThreadFactory 线程工厂类"></a>DefaultThreadFactory 线程工厂类</h1><p>线程优先级  priority<br>是否为守护线程   daemon<br>线程所属组  System.getSecurityManager() == null ?Thread.currentThread().getThreadGroup() : System.getSecurityManager().getThreadGroup()</p><h1 id="ThreadPerTaskExecutor"><a href="#ThreadPerTaskExecutor" class="headerlink" title="ThreadPerTaskExecutor"></a>ThreadPerTaskExecutor</h1><p>实现Executor接口执行execute方法</p><h1 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h1><p>扩展 Executor接口，提供了submit方法和shutdown等相关方法</p><h1 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h1><p>集成ExecutorService，扩展了定时任务</p><h1 id="EventExecutorGroup"><a href="#EventExecutorGroup" class="headerlink" title="EventExecutorGroup"></a>EventExecutorGroup</h1><p>EventExecutorGroup extends ScheduledExecutorService, Iterable<eventexecutor><br>提供了next方法<br>和生命周期的管理</eventexecutor></p><h1 id="EventExecutor"><a href="#EventExecutor" class="headerlink" title="EventExecutor"></a>EventExecutor</h1><p>接口可以多继承<br>继承EventExecutorGroup，提供了写方便的方法，比如判断inEventLoop判断当前线程是否在event loop中执行</p><h1 id="WindowsSelectorProvider"><a href="#WindowsSelectorProvider" class="headerlink" title="WindowsSelectorProvider"></a>WindowsSelectorProvider</h1><h1 id="SelectorProvider"><a href="#SelectorProvider" class="headerlink" title="SelectorProvider"></a>SelectorProvider</h1><p>提供了创建selector、ServerSocketChannel、SocketChanne等的方法</p><h1 id="provider方法"><a href="#provider方法" class="headerlink" title="provider方法"></a>provider方法</h1><p>首先通过java.nio.channels.spi.SelectorProvider加载<br>其次通过 spi(ServiceLoader)加载</p><h1 id="NioEventLoop"><a href="#NioEventLoop" class="headerlink" title="NioEventLoop"></a>NioEventLoop</h1><p>NioEventLoop -&gt; SingleThreadEventLoop -&gt; SingleThreadEventExecutor -&gt; AbstractScheduledEventExecutor<br>CLEANUP_INTERVAL 清除间隔<br>DISABLE_KEYSET_OPTIMIZATION  不可用的key优化</p><h1 id="SingleThreadEventLoop"><a href="#SingleThreadEventLoop" class="headerlink" title="SingleThreadEventLoop"></a>SingleThreadEventLoop</h1><p>tailTasks=LinkedBlockingQueue</p><h1 id="SingleThreadEventExecutor"><a href="#SingleThreadEventExecutor" class="headerlink" title="SingleThreadEventExecutor"></a>SingleThreadEventExecutor</h1><p>addTaskWakesUp=false<br>maxPendingTasks<br>executor=MpscChunkedArrayQueue<br>rejectedExecutionHandler=RejectedExecutionHandlers<br>taskQueue=队列</p><h1 id="AbstractScheduledEventExecutor"><a href="#AbstractScheduledEventExecutor" class="headerlink" title="AbstractScheduledEventExecutor"></a>AbstractScheduledEventExecutor</h1><p>parent =NioEventLoopGroup</p><h1 id="SelectedSelectionKeySet"><a href="#SelectedSelectionKeySet" class="headerlink" title="SelectedSelectionKeySet"></a>SelectedSelectionKeySet</h1><p>持有SelectionKey的集合</p><h1 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h1><p>聚合了Channel和Selector</p><h1 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h1><h1 id="SelectedSelectionKeySetSelector"><a href="#SelectedSelectionKeySetSelector" class="headerlink" title="SelectedSelectionKeySetSelector"></a>SelectedSelectionKeySetSelector</h1><p>委托模式，增强了WindowsSelectorImpl</p><h1 id="jdk-Future"><a href="#jdk-Future" class="headerlink" title="jdk Future"></a>jdk Future</h1><p>异步结果的计算<br>get<br>cancel</p><h1 id="netty-Future"><a href="#netty-Future" class="headerlink" title="netty Future"></a>netty Future</h1><p>添加listener<br>添加同步机制sync</p><h1 id="GenericFutureListener"><a href="#GenericFutureListener" class="headerlink" title="GenericFutureListener"></a>GenericFutureListener</h1><p>回调函数</p><h1 id="FutureListener"><a href="#FutureListener" class="headerlink" title="FutureListener"></a>FutureListener</h1><p>和GenericFutureListener差不多，隐藏了类型参数</p><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>继承 jdk Future<br>添加  设置成功失败的方法</p><p>AbstractBootstrap.initAndRegister -&gt; MultithreadEventLoopGroup.register -&gt; SingleThreadEventLoop.register -&gt; AbstractUnsafe.register</p><h1 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql性能优化</title>
      <link href="/2018/01/28/aa_category/db/mysql/Mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2018/01/28/aa_category/db/mysql/Mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="sakila"><a href="#sakila" class="headerlink" title="sakila"></a>sakila</h1><p><a href="https://dev.mysql.com/doc/sakila/en/sakila-installation.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/sakila/en/sakila-installation.html</a><br><a href="https://dev.mysql.com/doc/index-other.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/index-other.html</a></p><h1 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h1><p>show variables like ‘%query%’;<br>set global slow_query_log=ON;<br>–必须是重新连接或者新打开一个会话<br>set global long_query_time=4;</p><h2 id="分析工具"><a href="#分析工具" class="headerlink" title="分析工具"></a>分析工具</h2><h3 id="mysqldumpslow"><a href="#mysqldumpslow" class="headerlink" title="mysqldumpslow"></a>mysqldumpslow</h3><h3 id="pt-query-digest"><a href="#pt-query-digest" class="headerlink" title="pt-query-digest"></a>pt-query-digest</h3><h1 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h1><p>函数索引</p><h2 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h2><p>优化成join查询，需要注意一对多</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>在 where从句，group by 从句，order by 从句 on从句出现的列<br>索引字段越小越好<br>离散对大的列放到联合<br>索引的前面</p><p>数据库查询，需要分析使用哪个索引，所以不是索引越多越好</p><p>重复，冗余索引</p><h2 id="pt-duplicate-key-checker"><a href="#pt-duplicate-key-checker" class="headerlink" title="pt-duplicate-key-checker"></a>pt-duplicate-key-checker</h2><h2 id="pt-index-usage"><a href="#pt-index-usage" class="headerlink" title="pt-index-usage"></a>pt-index-usage</h2><p>通过慢查询日志配合pt-index-usage工具类进行索引使用情况的分析</p><h1 id="数据库结构优化"><a href="#数据库结构优化" class="headerlink" title="数据库结构优化"></a>数据库结构优化</h1><h2 id="选择合适的数据类型"><a href="#选择合适的数据类型" class="headerlink" title="选择合适的数据类型"></a>选择合适的数据类型</h2><ul><li>可以存放数据的最小数据类型</li><li>使用简单的数据类型。Int要比varchar类型在mysql中处理简单</li><li>尽可能使用not null定义字段</li><li>尽量少用text类型，非用不可，最好考虑分表</li></ul><h3 id="ip地址使用bigint存储"><a href="#ip地址使用bigint存储" class="headerlink" title="ip地址使用bigint存储"></a>ip地址使用bigint存储</h3><p>INET_ACON ip字符串地址转换成bigint<br>INET_NTOA bigint转换成字符串</p><h1 id="结构优化"><a href="#结构优化" class="headerlink" title="结构优化"></a>结构优化</h1><p>数据库表中不存在非关键字段对任意候选字段的传递函数依赖原则</p><p>配置工具<br><a href="https://www.percona.com/" target="_blank" rel="noopener">https://www.percona.com/</a></p><h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><h2 id="行转列"><a href="#行转列" class="headerlink" title="行转列"></a>行转列</h2><ul><li>cross join</li><li>sum case when</li></ul><h2 id="列转行"><a href="#列转行" class="headerlink" title="列转行"></a>列转行</h2>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> db </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存间交互</title>
      <link href="/2018/01/28/aa_category/se/gc&amp;mem/%E5%86%85%E5%AD%98%E9%97%B4%E4%BA%A4%E4%BA%92/"/>
      <url>/2018/01/28/aa_category/se/gc&amp;mem/%E5%86%85%E5%AD%98%E9%97%B4%E4%BA%A4%E4%BA%92/</url>
      
        <content type="html"><![CDATA[<h1 id="主内存和工作内存交互指令"><a href="#主内存和工作内存交互指令" class="headerlink" title="主内存和工作内存交互指令"></a>主内存和工作内存交互指令</h1><p>lock,作用于主线程变量，把变量标志为一条线程独占<br>unlock,作用于主线程变量，去掉线程独占标志<br>read,作用于主线程变量，把变量的值从主内存传输到工作线程，以便后面的load使用<br>load,作用于工作线程变量，把read从主内存获取的变量赋值给工作线程的变量副本<br>use,作用于工作线程变量，把变量传给执行引擎，当虚拟机遇到需要使用变量值的字节码的指令的时候使用<br>assgin,作用于工作内存变量，从执行引擎接受到的值赋值给工作内存<br>store,作用于工作内存变量，把工作内存的值传递给工作内从<br>write,作用于主线程存变量，把store获取的工作线程变量赋值给主内存变量</p><ul><li>read,load 和 store，write必须成对出现</li><li>不允许线程丢弃最近的assgin的操作，即assgin以后必须把改变同步回主内存</li><li>对一个线程执行unlock之前必须把改变同步回主内存</li></ul>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thread </tag>
            
            <tag> jmm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java类加载</title>
      <link href="/2018/01/21/aa_category/se/gc&amp;mem/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
      <url>/2018/01/21/aa_category/se/gc&amp;mem/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><p>加载 验证 准备 解析 初始化 使用 卸载</p><h1 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h1><ul><li>通过类的全限定名获取此类的二进制流</li><li>通过二进制流所代表的静态结构保存为方法区运行时数据结构</li><li>在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区访问的入口</li></ul><p>虚拟机设计团队把加载动作放到JVM外部实现，以便让应用程序决定如何获取所需的类，实现这个动作的代码称为“类加载器”，JVM提供了3种类加载器：</p><ol><li>启动类加载器（BootStrap ClassLoader）:负责加载JAVAHOME\lib目录，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。</li><li>扩展类加载器（Extends ClassLoader）:负责加载 JAVAHOME\ext目录，或通过java.ext.dirs系统变量指定路径中的类库。 </li><li>应用程序类加载器（Application ClassLoader）：负责加载用户路径（classpath）上的类库。</li></ol><p>当一个类收到加载任务的时候，优先交给父类加载器去完成，只有父类加载器无法完成任务的时候自己才会尝试去加载</p><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>格式验证、元数据验证、字节码验证、符号引用验证</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>为类变量在方法区分配内存，并设置初始值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化为 0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">var</span>  = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//初始化为100</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">var</span> =<span class="number">100</span>;</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>解析是将常量池中的符号引用替换为直接引用的过程</p><ol><li>符号引用使用一组符号来描述所引用的目标，可以是任何形式的字面常量，定义在Class文件格式中。</li><li>直接引用可以是直接指向目标的指针、相对偏移量或则能间接定位到目标的句柄</li></ol><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>执行类构造器方法的过程，方法是由类变量和静态代码块在类中定义的顺序组合的，该组合动作是由类编译器完成的</p><ol><li>类构造方法不是必须的，只有当类中有静态变量或者静态代码块，则编译器不会生成</li><li>类构造器与对象构造器不同，不需要显示调用父类的类构造方法，虚拟机保证先执行父类的类构造方法</li><li>为了防止多次执行，在多线程环境会正确加锁</li></ol><h2 id="类初始化场景"><a href="#类初始化场景" class="headerlink" title="类初始化场景"></a>类初始化场景</h2><ol><li>执行 new、getstatic、putstatic和invokestatic</li><li>使用reflect对类镜像反射调用</li><li>优先初始化父类</li><li>启动虚拟机是，需要初始化包含main方法的类</li><li>在JDK1.7中，如果java.lang.invoke.MethodHandler实例最后的解析结果REFgetStatic、REFputStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行初始化</li></ol><h2 id="不会触发初始化的场景"><a href="#不会触发初始化的场景" class="headerlink" title="不会触发初始化的场景"></a>不会触发初始化的场景</h2><ol><li>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。</li><li>定义对象数组，不会触发该类的初始化。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentInit01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"parentInit01  init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChilderInit01</span> <span class="keyword">extends</span> <span class="title">ParentInit01</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"ChilderInit01 init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> b = ChilderInit01.a;</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        ChilderInit01[]  cs  = <span class="keyword">new</span> ChilderInit01[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p>输出<br>parentInit01  init<br>0</p><ol start="3"><li>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> a =<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"const class init is called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Const.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br>100</p><p>通过类名获取Class对象，不会触发类的初始化<br>通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化</p><p>通过ClassLoader默认的loadClass方法，也不会触发初始化动作</p>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal:源码分析</title>
      <link href="/2018/01/21/aa_category/se/thread/ThreadLocal-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2018/01/21/aa_category/se/thread/ThreadLocal-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="ThreadLocal是什么"><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h1><p>它是一个数据结构，有点像HashMap，可以保存”key : value”键值对，但是一个ThreadLocal只能保存一个，并且各个线程的数据互不干扰</p><h1 id="set-amp-set方法"><a href="#set-amp-set方法" class="headerlink" title="set&amp;set方法"></a>set&amp;set方法</h1><h2 id="set-方法"><a href="#set-方法" class="headerlink" title="set 方法"></a>set 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">      Thread t = Thread.currentThread();</span><br><span class="line">      ThreadLocalMap map = getMap(t);</span><br><span class="line">      <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">          map.set(<span class="keyword">this</span>, value);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          createMap(t, value);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="keyword">get</span>() &#123;</span><br><span class="line">      Thread t = Thread.currentThread();</span><br><span class="line">      ThreadLocalMap map = getMap(t);</span><br><span class="line">      <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">          ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">          <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="meta">@SuppressWarnings(<span class="meta-string">"unchecked"</span>)</span></span><br><span class="line">              T result = (T)e.value;</span><br><span class="line">              <span class="keyword">return</span> result;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="comment">//初始化map，且设置值为null </span></span><br><span class="line">      <span class="keyword">return</span> setInitialValue();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><p>可以发现每个线程都有ThreadLocalMap，当执行set的时候保存到当前线程的threadLocals变量中，所以线程之间不会相互影响</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We don't use a fast path as with get() because it is at</span></span><br><span class="line">            <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">            <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">            <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">  <span class="comment">//根据ThreadLocal对象的hash值，定位到table中的位置i</span></span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"><span class="comment">//如果key正好是当前ThreadLoack则替换值</span></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    e.value = value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    replaceStaleEntry(key, value, i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 当前位置为空，初始化Entry放置到位置i</span></span><br><span class="line">            tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">            <span class="keyword">int</span> sz = ++size;</span><br><span class="line">            <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                rehash();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> source </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadPoolExecutor:源码分析</title>
      <link href="/2018/01/19/aa_category/se/thread/ThreadPoolExecutor-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2018/01/19/aa_category/se/thread/ThreadPoolExecutor-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p> private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;<br>    private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;<br>    private static final int STOP       =  1 &lt;&lt; COUNT_BITS;<br>    private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;<br>    private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;</p><p>runState</p><p>RUNNING:接受任务，并处理队列中的任务<br>SHUTDOWN：关闭接收新任务，但是处理已有队列中的任务<br>STOP：不接收新的任务，不处理队列中已有的任务<br>TIDYING：所有任务已经处理完成，触发钩子方法terminated<br>TERMINATED：方法terminated调用完成时候的状态</p><a id="more"></a><p>take poll 都是从去</p><h1 id="execute-方法"><a href="#execute-方法" class="headerlink" title="execute 方法"></a>execute 方法</h1><ul><li>如果池中数量小于核心线程数，新建一个线程执行任务</li><li>如果线程池中任务数量大于核心线程数量，并且状态为运行状态，则把任务添加到任务队列</li><li>非以上两种情况。长沙那个是新建一个线程，并把任务添加到新线程中，如果失败，执行拒绝策略<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// 获取ctl对应的int值。该int值保存了"线程池中任务的数量"和"线程池状态"信息</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"><span class="comment">//  获取线程池中任务的数量</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line"><span class="comment">//            新建一个线程，把任务添加到线程中，启动线程从而执行任务</span></span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        isRunning 判断线程池状态是否为Running,把任务添加到任务队列</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line"><span class="comment">//            再次检查线程池状态，如果不是运行时，删除任务</span></span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line"><span class="comment">//                执行拒绝策略</span></span><br><span class="line">                reject(command);</span><br><span class="line"><span class="comment">//            如果线程池中的任务为0，添加一个空的任务</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        队类满的情况</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="addWorker方法"><a href="#addWorker方法" class="headerlink" title="addWorker方法"></a>addWorker方法</h1><ul><li>将任务添加到线程池中，并启动</li><li>core为true，则以corePoolSize为界限，若”线程池中已有任务数量&gt;=corePoolSize”，则返回false；core为false的话，则以maximumPoolSize为界限，若”线程池中已有任务数量&gt;=maximumPoolSize”，则返回false。</li><li>addWorker会先通过for循环不断尝试更新ctl状态，ctl记录了线程池中任务数量和线程池状态，更新成功之后，再通过try模块来将任务添加到线程池中，并启动任务所在的线程</li><li>从addWorker()中，我们能清晰的发现：线程池在添加任务时，会创建任务对应的Worker对象；而一个Workder对象包含一个Thread对象。(01) 通过将Worker对象添加到”线程的workers集合”中，从而实现将任务添加到线程池中。 (02) 通过启动Worker对应的Thread线程，则执行该任务。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        标签，go的云法</span></span><br><span class="line">        retry:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"><span class="comment">//            运行状态</span></span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 有效性检查</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                    ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                            firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            ! workQueue.isEmpty()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"><span class="comment">//                如果"线程池中任务的数量"超过限制，则返回false。</span></span><br><span class="line">                <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                        wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//                通过cas将线程池中的数量+1，如果添加失败，退出循环，从retry重新开始</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">break</span> retry;</span><br><span class="line">                c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line"><span class="comment">//                检查线程池状态，如果和之前的状态不同，从retry重新开始</span></span><br><span class="line">                <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">        java.util.concurrent.ThreadPoolExecutor.Worker w = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//        添加任务到线程池，并启动线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            w = <span class="keyword">new</span> java.util.concurrent.ThreadPoolExecutor.Worker(firstTask);</span><br><span class="line">            <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">                mainLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                    <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                    <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                    <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                  <span class="comment">// 再次确认线程池状态</span></span><br><span class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                            (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"><span class="comment">//                        把任务添加到任务集合中</span></span><br><span class="line">                        workers.add(w);</span><br><span class="line"><span class="comment">//                        更新largeestPoolSize</span></span><br><span class="line">                        <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                        workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                    t.start();</span><br><span class="line">                    workerStarted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        返回任务是否启动成功</span></span><br><span class="line">        <span class="keyword">return</span> workerStarted;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="submit方法"><a href="#submit方法" class="headerlink" title="submit方法"></a>submit方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="shutdown方法"><a href="#shutdown方法" class="headerlink" title="shutdown方法"></a>shutdown方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//            当前线程是否有终止权限</span></span><br><span class="line">            checkShutdownAccess();</span><br><span class="line"><span class="comment">//设置线程池的状态为关闭状态</span></span><br><span class="line">            advanceRunState(SHUTDOWN);</span><br><span class="line"><span class="comment">//            中断空闲的线程</span></span><br><span class="line">            interruptIdleWorkers();</span><br><span class="line"><span class="comment">//            钩子函数，在ThreadPoolExecutor中没有任何动</span></span><br><span class="line">            onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> source </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LockSupport:源码分析</title>
      <link href="/2018/01/10/aa_category/se/thread/LockSupport-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2018/01/10/aa_category/se/thread/LockSupport-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="代码版本"><a href="#代码版本" class="headerlink" title="代码版本"></a>代码版本</h1><p>1.8.0_131</p><h1 id="sun-misc-Unsafe"><a href="#sun-misc-Unsafe" class="headerlink" title="sun.misc.Unsafe"></a>sun.misc.Unsafe</h1><p>因为LockSupport的核心函数都是基于Unsafe类中定义的park和unpark函数，下面给出两个函数的定义。　　</p><p>public native void park(boolean isAbsolute, long time);<br>public native void unpark(Thread thread);</p><ul><li>park函数，阻塞线程，在以下情况发生之前会一直阻塞<ul><li>调用unpark函数</li><li>线程被中断</li><li>等待时间到了，并且，当time为绝对时间时，isAbsolute为true，否则，isAbsolute为false。当time为0时，表示无限等待，直到unpark发生。</li></ul></li><li>unpark函数，释放线程的许可，即激活调用park后阻塞的线程。这个函数不是安全的，调用这个函数时要确保线程依旧存活。</li></ul>]]></content>
      
      
      <categories>
          
          <category> thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> source </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AbstractQueuedSynchronizer:源码分析</title>
      <link href="/2018/01/09/aa_category/se/thread/AbstractQueuedSynchronizer-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2018/01/09/aa_category/se/thread/AbstractQueuedSynchronizer-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="代码版本"><a href="#代码版本" class="headerlink" title="代码版本"></a>代码版本</h1><p>1.8.0_131</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>AbstractQueuedSynchronizer主要提供了两类功能，共享锁和独占锁，所有的子类，要么使用了共享锁，要么使用了独占锁，没有任何类同时使用的情况。即使ReentrantReadWriteLock，也是通过两个子类实现的。</p><h1 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h1><h2 id="waitStatus"><a href="#waitStatus" class="headerlink" title="waitStatus"></a>waitStatus</h2><ul><li>CANCELLED =  1 This node is cancelled due to timeout or interrupt.</li><li>SIGNAL    = -1 The successor of this node is (or will soon be) blocked (via park), so the current node must unpark its successor when it releases or cancels</li><li>CONDITION = -2 This node is currently on a condition queue. It will not be used as a sync queue node until transferred, at which time the status will be set to 0. </li><li>PROPAGATE = -3 A releaseShared should be propagated to other nodes. This is set (for head node only) in doReleaseShared to ensure propagation continues, even if other operations have since intervened.</li></ul><h1 id="AbstractQueuedSynchronizer-addWaiter-Node"><a href="#AbstractQueuedSynchronizer-addWaiter-Node" class="headerlink" title="AbstractQueuedSynchronizer.addWaiter(Node)"></a>AbstractQueuedSynchronizer.addWaiter(Node)</h1><p>返回新增的节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line"><span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">Node pred = tail;</span><br><span class="line"><span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">node.prev = pred;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">pred.next = node;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">enq(node);</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AbstractQueuedSynchronizer-enq-Node"><a href="#AbstractQueuedSynchronizer-enq-Node" class="headerlink" title="AbstractQueuedSynchronizer.enq(Node)"></a>AbstractQueuedSynchronizer.enq(Node)</h1><p>给队列尾添加节点，并返回之前的尾</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">Node t = tail;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 队列为空创建一个标志结点作为head结点，同时tail结点也指向head</span></span><br><span class="line"><span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">tail = head;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 当前节点的prev指向tail</span></span><br><span class="line">node.prev = t;</span><br><span class="line"><span class="comment">// 设置当前结点为tail节点</span></span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">t.next = node;</span><br><span class="line"><span class="comment">// 返回tail节点</span></span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AbstractQueuedSynchronizer-acquireQueued-Node-int"><a href="#AbstractQueuedSynchronizer-acquireQueued-Node-int" class="headerlink" title="AbstractQueuedSynchronizer.acquireQueued(Node, int)"></a>AbstractQueuedSynchronizer.acquireQueued(Node, int)</h1><p>从队列里面获取资源，只有当前节点的前置节点为head,获取资源以后把当前节点从队列中移除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 标记是否成功获取资源</span></span><br><span class="line"><span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 标记是否被中断</span></span><br><span class="line"><span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 自旋（死循环）</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">// 拿到当前节点的前置节点</span></span><br><span class="line"><span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line"><span class="comment">// 如果前置节点是head，那么当前节点有资格获取资源</span></span><br><span class="line"><span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line"><span class="comment">// 当前节点指向head</span></span><br><span class="line">setHead(node);</span><br><span class="line"><span class="comment">// 当前节点从链中山粗，help GC</span></span><br><span class="line">p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">failed = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> interrupted;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果可以休息了，就到了waiting状态，直到被unpark</span></span><br><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) &#123;</span><br><span class="line"><span class="comment">// 如果等待中被中断了，哪怕一次，也会将 interrupted 标记为true</span></span><br><span class="line">interrupted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (failed) &#123;</span><br><span class="line"><span class="comment">// 取消获取资源</span></span><br><span class="line">cancelAcquire(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AbstractQueuedSynchronizer-shouldParkAfterFailedAcquire-Node-Node"><a href="#AbstractQueuedSynchronizer-shouldParkAfterFailedAcquire-Node-Node" class="headerlink" title="AbstractQueuedSynchronizer.shouldParkAfterFailedAcquire(Node, Node)"></a>AbstractQueuedSynchronizer.shouldParkAfterFailedAcquire(Node, Node)</h1><p>当前线程获取资源失败以后是否需要阻塞</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line"><span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line"><span class="comment">// 前置节点是SIGNAL状态（当前置节点使用完资源以后会通知后续的节点），则当前节点可以安全休息</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Predecessor was cancelled. Skip over predecessors and indicate retry.</span></span><br><span class="line"><span class="comment"> * 如果前置节点废弃了，那就一直往前找，一直找到状态正常的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">node.prev = pred = pred.prev;</span><br><span class="line">&#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">pred.next = node;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * waitStatus must be 0 or PROPAGATE. Indicate that we need a signal, but don't</span></span><br><span class="line"><span class="comment"> * park yet. Caller will need to retry to make sure it cannot acquire before</span></span><br><span class="line"><span class="comment"> * parking.</span></span><br><span class="line"><span class="comment"> * 如果前置节点正常，就把状态设置为SIGNAL，高速它拿完号通知我，有可能失败，人家可能刚刚释放完</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AbstractQueuedSynchronizer-parkAndCheckInterrupt"><a href="#AbstractQueuedSynchronizer-parkAndCheckInterrupt" class="headerlink" title="AbstractQueuedSynchronizer.parkAndCheckInterrupt()"></a>AbstractQueuedSynchronizer.parkAndCheckInterrupt()</h1><p>当前线程处于wating状态，检查是否被中断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 让当前线程处于等待状态</span></span><br><span class="line">LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 如果当前线程被唤醒，查看是否被中断的（park会让当前线程处于waiting状态，唤醒线程的方式有 unpark 或者 interrupt）</span></span><br><span class="line"><span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AbstractQueuedSynchronizer-release-int"><a href="#AbstractQueuedSynchronizer-release-int" class="headerlink" title="AbstractQueuedSynchronizer.release(int)"></a>AbstractQueuedSynchronizer.release(int)</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">Node h = head;</span><br><span class="line"><span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 唤醒等待队列里面下一个线程</span></span><br><span class="line">unparkSuccessor(h);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AbstractQueuedSynchronizer-unparkSuccessor-Node"><a href="#AbstractQueuedSynchronizer-unparkSuccessor-Node" class="headerlink" title="AbstractQueuedSynchronizer.unparkSuccessor(Node)"></a>AbstractQueuedSynchronizer.unparkSuccessor(Node)</h1><p>唤醒等待的线程</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private void unparkSuccessor(Node <span class="type">node</span>) &#123;</span><br><span class="line">/*</span><br><span class="line"> * If status <span class="literal">is</span> negative (i.e., possibly needing signal) <span class="keyword">try</span> <span class="keyword">to</span> clear <span class="keyword">in</span></span><br><span class="line"> * anticipation <span class="keyword">of</span> signalling. It <span class="literal">is</span> OK <span class="keyword">if</span> this fails <span class="keyword">or</span> <span class="keyword">if</span> status <span class="literal">is</span> changed <span class="keyword">by</span></span><br><span class="line"> * waiting thread.</span><br><span class="line"> */</span><br><span class="line">int ws = <span class="type">node</span>.waitStatus;</span><br><span class="line"><span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">compareAndSetWaitStatus(<span class="type">node</span>, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Thread <span class="keyword">to</span> unpark <span class="literal">is</span> held <span class="keyword">in</span> successor, which <span class="literal">is</span> normally just the <span class="keyword">next</span> <span class="type">node</span>.</span><br><span class="line"> * But <span class="keyword">if</span> cancelled <span class="keyword">or</span> apparently null, traverse backwards from<span class="built_in"> tail</span> <span class="keyword">to</span> find the</span><br><span class="line"> * actual non-cancelled successor.</span><br><span class="line"> * 如果当前节点的下个节点为空，或者状态为取消</span><br><span class="line"> */</span><br><span class="line">Node s = <span class="type">node</span>.<span class="keyword">next</span>;</span><br><span class="line"><span class="keyword">if</span> (s == null || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">s = null;</span><br><span class="line"><span class="keyword">for</span> (Node t =<span class="built_in"> tail</span>; t != null &amp;&amp; t != <span class="type">node</span>; t = t.prev)</span><br><span class="line"><span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">s = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s != null)</span><br><span class="line">LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyclicBarrier:源码分析</title>
      <link href="/2018/01/09/aa_category/se/thread/CyclicBarrier-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2018/01/09/aa_category/se/thread/CyclicBarrier-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="代码版本"><a href="#代码版本" class="headerlink" title="代码版本"></a>代码版本</h1><p>1.8.0_131</p><h1 id="域"><a href="#域" class="headerlink" title="域"></a>域</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();<span class="comment">//所有方法都通过这个锁来同步。 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();<span class="comment">//通过lock得到的一个状态变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;<span class="comment">//通过构造器传入的参数，表示总的等待线程的数量。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;<span class="comment">//初始化和parties一致，parties不参与运算，count参与运算</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;<span class="comment">//当屏障正常打开后运行的程序，通过最后一个调用await的线程来执行。</span></span><br><span class="line"><span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();当前的Generation。每当屏障失效或者开闸之后都会自动替换掉。从而实现重置的功能。</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="CyclicBarrier-await"><a href="#CyclicBarrier-await" class="headerlink" title="CyclicBarrier.await()"></a>CyclicBarrier.await()</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Main barrier code, covering the various policies.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">               TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"><span class="comment">//如果当前Generation是处于打破状态则传播这个BrokenBarrierExcption</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> index = --count;</span><br><span class="line"><span class="comment">// tripped//如果当前状态将为0，则Generation处于开闸状态。运行可能存在的command，设置下一个Generation。相当于每次开闸之后都进行了一次reset。</span></span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">                <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                    <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                        command.run();</span><br><span class="line">                    ranAction = <span class="keyword">true</span>;</span><br><span class="line">                    nextGeneration();</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!timed)</span><br><span class="line">                        trip.await();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                        nanos = trip.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                        <span class="keyword">throw</span> ie;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">                        <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                        <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g.broken)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g != generation)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIO:Selector</title>
      <link href="/2018/01/02/aa_category/framework/netty/NIO-Selector/"/>
      <url>/2018/01/02/aa_category/framework/netty/NIO-Selector/</url>
      
        <content type="html"><![CDATA[<p>之前进行socket编程时，accept方法会一直阻塞，直到有客户端请求的到来，并返回socket进行相应的处理。整个过程是流水线的，处理完一个请求，才能去获取并处理后面的请求，当然也可以把获取socket和处理socket的过程分开，一个线程负责accept，一个线程池负责处理请求</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle:awrrpt</title>
      <link href="/2017/12/28/aa_category/db/oracle/Oracle-awrrpt/"/>
      <url>/2017/12/28/aa_category/db/oracle/Oracle-awrrpt/</url>
      
        <content type="html"><![CDATA[<p>把目录切换到生成报告的地址</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlplus / as sysdba;</span><br><span class="line">@?/rdbms/admin/awrrpt.sql</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="AWR-报告分析"><a href="#AWR-报告分析" class="headerlink" title="AWR 报告分析"></a>AWR 报告分析</h1>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用工具</title>
      <link href="/2017/12/28/aa_category/tool/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
      <url>/2017/12/28/aa_category/tool/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h1><ul><li>模拟请求，前后端联调利器</li><li>有APP版和chrome浏览器插件版<h1 id="redis-desktop-manager"><a href="#redis-desktop-manager" class="headerlink" title="redis-desktop-manager"></a>redis-desktop-manager</h1>redis 管理工作<h1 id="SecureCRT"><a href="#SecureCRT" class="headerlink" title="SecureCRT"></a>SecureCRT</h1>Windows下登录UNIX或Linux服务器主机的软件。<h1 id="fiddler"><a href="#fiddler" class="headerlink" title="fiddler"></a>fiddler</h1>抓包利器<h1 id="clcl"><a href="#clcl" class="headerlink" title="clcl"></a>clcl</h1></li><li>复制粘贴</li><li>CLCL is clipboard caching utility<h1 id="Launchy"><a href="#Launchy" class="headerlink" title="Launchy"></a>Launchy</h1>Launchy indexes the programs in your start menu and can launch your documents, project files, folders, and bookmarks with just a few keystrokes!</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle:性能分析及优化</title>
      <link href="/2017/12/28/aa_category/db/oracle/Oracle-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
      <url>/2017/12/28/aa_category/db/oracle/Oracle-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="书写"><a href="#书写" class="headerlink" title="书写"></a>书写</h1><ul><li>SQL语句转换成大写，可缩短些SQL的解析时间。通过统一成大写，可提高SQL的再利用率，缩短SQL解析时间。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--高效的写法</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A_TABLE</span><br><span class="line"><span class="comment">--低效的写法</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> a_table</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>涉及到多表检索时，明确地为每个字段指定表名,通过在A_TABLE、B_TABLE中指定别名｢A｣、｢B｣,就可不再需要调查A_ITEM、B_ITEM、A_KEY、B_KEY是哪儿个表中的项目,从而缩短SQL解析时间</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--高效的写法：</span></span><br><span class="line">  <span class="keyword">SELECT</span> A.A_ITEM, B.B_ITEM </span><br><span class="line">  <span class="keyword">FROM</span> A_TABLE A, B_TABLE B</span><br><span class="line">  <span class="keyword">WHERE</span> A.A_KEY = B.B_KEY;</span><br><span class="line"><span class="comment">--低效的写法：</span></span><br><span class="line">  <span class="keyword">SELECT</span> A_ITEM </span><br><span class="line">  <span class="keyword">FROM</span> A_TABLE, B_TABLE</span><br><span class="line">  <span class="keyword">WHERE</span> A_KEY = B_KEY;</span><br></pre></td></tr></table></figure><ul><li>ORACLE在解析的过程中, 会将’*’ 依次转换成所有的列名, 这个工作是通过查询数据字典完成的, 这意味着将耗费更多的时间</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">高效的写法：</span><br><span class="line">  <span class="keyword">SELECT</span> AAC001,AAC002,AAC003 <span class="keyword">FROM</span> AC01;</span><br><span class="line">低效的写法：</span><br><span class="line">  <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> AC01;</span><br></pre></td></tr></table></figure><h1 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h1><ul><li>ORACLE的解析器按照从右到左的顺序处理FROM子句中的表名,因此FROM子句中写在最后的表(基础表 driving table)将被最先处理. 在FROM子句中包含多个表的情况下,你必须选择记录条数最少的表作为基础表.当ORACLE处理多个表时, 会运用排序及合并的方式连接它们.首先,扫描第一个表(FROM子句中最后的那个表)并对记录进行排序,然后扫描第二个表(FROM子句中最后第二个表),最后将所有从第二个表中检索出的记录与第一个表中合适记录进行合并</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--表 ac01有 16,384 条记录 </span></span><br><span class="line"><span class="comment">--表 ab01 有1 条记录</span></span><br><span class="line"><span class="comment">--高效的写法：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> AC01,AB01 ;</span><br><span class="line"><span class="comment">--执行时间0.96秒</span></span><br><span class="line"><span class="comment">--低效的写法：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> AB01,AC01 ;</span><br><span class="line"><span class="comment">--执行时间26.09秒</span></span><br></pre></td></tr></table></figure><p>只在基于规则的优化器rule中有效。ORACLE建议按此方式书写。<br>减少多表关联:<br>表关联的越多，查询速度就越慢，尽量减少多个表的关联，建议表关联不要超过3个（子查询也属于表关联）。<br>数据转换上会存在大数据量表的关联，关联多了会影响索引的效率，可以采用建立临时表的办法，有时更能提高速度.</p><ul><li>ORACLE采用自下而上的顺序解析WHERE子句,根据这个原理,表之间的连接必须写在其他WHERE条件之前, 那些可以过滤掉最大数量记录的条件必须写在WHERE子句的末尾</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--高效的写法：</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> AC01 <span class="keyword">WHERE</span> AAC004=<span class="string">'1'</span> <span class="keyword">AND</span> AAC003=<span class="string">'周东芝'</span>;</span><br><span class="line"><span class="comment">--低效的写法：</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> AC01 <span class="keyword">WHERE</span> AAC003=<span class="string">'周东芝'</span> <span class="keyword">AND</span> AAC004=<span class="string">'1'</span>;</span><br></pre></td></tr></table></figure><ul><li>ORACLE采用自下而上的顺序解析WHERE子句,根据这个原理,表之间的连接必须写在其他WHERE条件之前。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--高效的写法：</span></span><br><span class="line"><span class="keyword">SELECT</span> ab01.aab001,ab02.aab051 </span><br><span class="line"> <span class="keyword">FROM</span> ab01,ab02 </span><br><span class="line"><span class="keyword">WHERE</span> ab01.aab001=ab02.aab001 </span><br><span class="line">   <span class="keyword">AND</span> ab02.aae140=’<span class="number">31</span>’;</span><br><span class="line"><span class="comment">--低效的写法：</span></span><br><span class="line"><span class="keyword">SELECT</span> ab01.aab001,ab02.aab051 </span><br><span class="line"> <span class="keyword">FROM</span> ab01,ab02 </span><br><span class="line"><span class="keyword">WHERE</span> ab02.aae140=’<span class="number">31</span>’ </span><br><span class="line">   <span class="keyword">AND</span> ab01.aab001=ab02.aab001;</span><br></pre></td></tr></table></figure><ul><li>不要通过LIKE运算来执行中间一致或后方一致的检索</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> AC01 <span class="keyword">WHERE</span> AAC003 <span class="keyword">LIKE</span> <span class="string">'梁海%'</span>;</span><br><span class="line">低效的写法：</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> AC01 <span class="keyword">WHERE</span> AAC003 <span class="keyword">LIKE</span> <span class="string">'%梁海'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> AC01 <span class="keyword">WHERE</span> AAC003 <span class="keyword">LIKE</span> <span class="string">'%梁海%'</span>;</span><br></pre></td></tr></table></figure><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引列，不要使用”NOT”、”!=”、”&lt;&gt;”比较运算</p><p>show parameter memory</p><p>alter system set memory_target=4g scope=spfile;</p><p>shutdown immediate</p><p>show parameter sga</p><p>alter system register;</p>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle:index</title>
      <link href="/2017/12/28/aa_category/db/oracle/Oracle-index/"/>
      <url>/2017/12/28/aa_category/db/oracle/Oracle-index/</url>
      
        <content type="html"><![CDATA[<p>索引建立在排序的基础上<br> 若没有索引，搜索某个记录时（例如查找name=’wish’）需要搜索所有的记录，因为不能保证只有一个wish，必须全部搜索一遍</p><p>一个表能建多少个索引<br>一张表推荐多少个字段，如果多了，会有什么问题</p><a id="more"></a><h1 id="索引类别"><a href="#索引类别" class="headerlink" title="索引类别"></a>索引类别</h1><h2 id="B树索引"><a href="#B树索引" class="headerlink" title="B树索引"></a>B树索引</h2><p>列基数（列不重复值的个数）大时适合使用B数索引</p><h2 id="位图索引"><a href="#位图索引" class="headerlink" title="位图索引"></a>位图索引</h2><p>对于基数小的列适合简历位图索引（例如性别等）</p><h2 id="单列索引和复合索引"><a href="#单列索引和复合索引" class="headerlink" title="单列索引和复合索引"></a>单列索引和复合索引</h2><h2 id="函数索引"><a href="#函数索引" class="headerlink" title="函数索引"></a>函数索引</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> fbi  <span class="keyword">on</span> student (<span class="keyword">upper</span>(<span class="keyword">name</span>));</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">upper</span>(<span class="keyword">name</span>) =<span class="string">'WISH'</span></span><br></pre></td></tr></table></figure><h2 id="索引建立原则总结"><a href="#索引建立原则总结" class="headerlink" title="索引建立原则总结"></a>索引建立原则总结</h2><p>如果有两个或者以上的索引，其中有一个唯一性索引，而其他是非唯一，这种情况下oracle将使用唯一性索引而完全忽略非唯一性索引<br> 至少要包含组合索引的第一列（即如果索引建立在多个列上，只有它的第一个列被where子句引用时，优化器才会使用该索引）<br>小表不要建立索引<br>经常进行连接查询的列应该创建索引<br>使用create index时要将最常查询的列放在最前面<br>限制表中索引的数量（创建索引耗费时间，并且随数据量的增大而增大；索引会占用物理空间；当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度）</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">not</span> (score=<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> score &lt;&gt; <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--替换为</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> score&gt;<span class="number">100</span> <span class="keyword">or</span> score &lt;<span class="number">100</span></span><br></pre></td></tr></table></figure><p>先执行From -&gt;Where -&gt;Group By-&gt;Order By<br>执行From 子句是从右往左进行执行。因此必须选择记录条数最少的表放在右边</p>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring:mvc</title>
      <link href="/2017/12/24/aa_category/framework/spring/spring-mvc/"/>
      <url>/2017/12/24/aa_category/framework/spring/spring-mvc/</url>
      
        <content type="html"><![CDATA[<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><ul><li>外部容器传给springmvc初始化事件</li><li>以分散重写的手段初始化</li><li>初始化spring ioc</li><li>初始化spring mvc 九大对象的初始化<!-- more># spring 九大组件<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> DispatcherServlet.initStrategies(ApplicationContext context) &#123;</span><br><span class="line">initMultipartResolver(context);</span><br><span class="line">initLocaleResolver(context);</span><br><span class="line">initThemeResolver(context);</span><br><span class="line">initHandlerMappings(context);</span><br><span class="line">initHandlerAdapters(context);</span><br><span class="line">initHandlerExceptionResolvers(context);</span><br><span class="line">initRequestToViewNameTranslator(context);</span><br><span class="line">initViewResolvers(context);</span><br><span class="line">initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/root-context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span><span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>web.xml加载顺序<br>context-param &gt;&gt; listener &gt;&gt; filter &gt;&gt; servlet。（web.xml 加载顺序这个很重要的）</p><h1 id="ContextLoaderListener"><a href="#ContextLoaderListener" class="headerlink" title="ContextLoaderListener"></a>ContextLoaderListener</h1><p><img src="mvc.png" alt="mvc"></p><p>![mvc-context-hierarchy(mvc-context-hierarchy.png)</p><h2 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h2>--></li></ul>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> mvc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty:入门</title>
      <link href="/2017/12/24/aa_category/framework/netty/Netty-%E5%85%A5%E9%97%A8/"/>
      <url>/2017/12/24/aa_category/framework/netty/Netty-%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>Netty是一个高性能、异步事件驱动的NIO框架，提供了对TCP、UDP和文件传输的支持，作为一个异步NIO框架，Netty的所有IO操作都是异步非阻塞的，通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果。</p><a id="more"></a><h1 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h1><p>Reator模型主要由多路复用器(Acceptor)、事件分发器（Dispatcher）、事件处理器（Handler）</p><h2 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h2><p>所有I/O操作都在一个线程上，即多路复用、事件分发和处理都是在一个Reactor线程上完成的<br>三层协议<br>协议<br>Pipline<br>Reactor</p><p>传输服务<br>协议支持<br>核心</p><h1 id="架构分析"><a href="#架构分析" class="headerlink" title="架构分析"></a>架构分析</h1><h2 id="Reactor通信调度层-模型-——》"><a href="#Reactor通信调度层-模型-——》" class="headerlink" title="Reactor通信调度层 模型  ——》"></a>Reactor通信调度层 模型  ——》</h2><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>监听网络读写连接<br>调度业务处理<br>NioSockertChannel<br>ByteBuffer池化支持，用用手动切换标志位，零拷贝</p><h3 id="Pipline-职责链条传递"><a href="#Pipline-职责链条传递" class="headerlink" title="Pipline 职责链条传递"></a>Pipline 职责链条传递</h3><p>拦截处理向前向后事件<br>外部传入的消息对象，有POJO信息抽象，上层只需要处理逻辑</p><p>构建逻辑业务处理层</p><p><img src="components.png" alt="components"></p><h1 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h1><p>ChannelFactory<br>NioServerSocketChannelFactory</p><p>Executor bossExecutor<br>Executor workerExecutor<br>org.jboss.netty.channel.Channels.pipeline(ChannelHandler…)</p><p>优点总结</p><p>api使用简单，封装完善，开发门槛低<br>功能强大，预置了多种编码解码功能，多种主流协议支持<br>定制能力强，可以对channelHander对框架的灵活扩展<br>性能高，Reator线程模型调度+ChannelFuture+Listener,通过Listener机制主动推送结果</p><p>典型的网络事件如下：<br>链路注册<br>链路激活<br>链路端口<br>接收到请求消息<br>求求消息接受并处理完毕<br>发送应答消息<br>链路发生异常<br>发生用户自定义事件</p>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql:index</title>
      <link href="/2017/12/22/aa_category/db/mysql/Mysql-index/"/>
      <url>/2017/12/22/aa_category/db/mysql/Mysql-index/</url>
      
        <content type="html"><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><ol><li>索引需要存储，也就需要空间，索引实际就是一张表，字段更行会有性能损耗</li><li>btree</li></ol><a id="more"></a><h1 id="Innodb"><a href="#Innodb" class="headerlink" title="Innodb"></a>Innodb</h1><p>聚集索引<br>有事务<br>适合写多，读少</p><h1 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h1><p>非聚集所以<br>没有事务<br>适合读多，写少</p><h1 id="建索引原则"><a href="#建索引原则" class="headerlink" title="建索引原则"></a>建索引原则</h1><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><ol><li>频繁作为where条件的字段</li><li>关联字段可以建索引，例如外键</li><li>排序字段，例如order by name,group by(先排序，后分组)</li></ol><h2 id="不适合"><a href="#不适合" class="headerlink" title="不适合"></a>不适合</h2><ol><li>where条件用不到的</li><li>频繁更新的字段</li><li>数据值发布比较均匀的不适合建索引，例如男女，这家</li><li>表达数据可以确定行数，二期数据量很少</li></ol><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>##　索引失效</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">user: id,name,age</span><br><span class="line">index(name,age) 复合索引</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">order</span>  <span class="keyword">by</span> age 索引失效</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span>  <span class="keyword">where</span> age=<span class="number">19</span> <span class="keyword">and</span> <span class="keyword">name</span>=<span class="string">'lee'</span> 索引失效</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">index</span>(age,<span class="keyword">name</span>) 复合索引</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">order</span>  <span class="keyword">by</span> age 索引有效</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span>  <span class="keyword">where</span> age=<span class="number">19</span> <span class="keyword">and</span> <span class="keyword">name</span>=<span class="string">'lee'</span> 索引有效</span><br></pre></td></tr></table></figure><h2 id="Btree-hash"><a href="#Btree-hash" class="headerlink" title="Btree hash"></a>Btree hash</h2><h1 id="MySql常用30种SQL查询语句优化方法"><a href="#MySql常用30种SQL查询语句优化方法" class="headerlink" title="MySql常用30种SQL查询语句优化方法"></a>MySql常用30种SQL查询语句优化方法</h1><ol><li>应尽量避免在 where 子句中使用!=或&lt;&gt;</li><li>where 及 order by 涉及的列上建立索引</li><li>where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</li><li>尽量避免在 where 子句中使用 or 来连接条件<br>如：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span> <span class="keyword">or</span> <span class="keyword">num</span>=<span class="number">20</span></span><br></pre></td></tr></table></figure></li></ol><p>可以这样查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">20</span></span><br></pre></td></tr></table></figure><ol><li><p>in 和 not in 也要慎用<br>对于连续的数值，能用 between 就不要用 in 了<br>应尽量避免在 where 子句中对字段进行表达式操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>/<span class="number">2</span>=<span class="number">100</span>  N</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">100</span>*<span class="number">2</span>  Y</span><br></pre></td></tr></table></figure></li><li><p>应尽量避免在where子句中对字段进行函数操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">substring</span>(<span class="keyword">name</span>,<span class="number">1</span>,<span class="number">3</span>)=’abc’–<span class="keyword">name</span>以abc开头的<span class="keyword">id</span>  N</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> ‘abc%’ Y</span><br></pre></td></tr></table></figure></li><li><p>在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使 用，并且应尽可能的让字段顺序与索引顺序相一致</p></li><li><p>当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段 sex，male、female几乎各一半</p></li><li><p>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。</p></li><li><p>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会 逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> db </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生产者消费者</title>
      <link href="/2017/12/12/aa_category/se/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/"/>
      <url>/2017/12/12/aa_category/se/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/</url>
      
        <content type="html"><![CDATA[<p>生产者消费者的事例代码</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo1.resume;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoreHouse</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">static</span> Condition notFull = lock.newCondition();</span><br><span class="line"><span class="keyword">static</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"><span class="keyword">static</span> BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">static</span> AtomicInteger ai = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> capacity = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.lockInterruptibly();</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (queue.size() == capacity) &#123;</span><br><span class="line">notFull.await();</span><br><span class="line">&#125;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">int</span> incrementAndGet = ai.incrementAndGet();</span><br><span class="line">queue.put(incrementAndGet);</span><br><span class="line">System.out.println(<span class="string">"生产面包"</span> + incrementAndGet + <span class="string">" 当前仓库总数"</span> + queue.size());</span><br><span class="line">notEmpty.signal();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (lock.isHeldByCurrentThread()) &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.lockInterruptibly();</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">notEmpty.await();</span><br><span class="line">&#125;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">Integer take = queue.take();</span><br><span class="line">System.out.println(<span class="string">"消费面包"</span> + take + <span class="string">" 当前仓库总数"</span> + queue.size());</span><br><span class="line">notFull.signal();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (lock.isHeldByCurrentThread()) &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">Consumer consumer = <span class="keyword">new</span> Consumer();</span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">50</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">pool.execute(consumer);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pool.execute(producer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pool.shutdown();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> concurrent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring:annotation</title>
      <link href="/2017/12/07/aa_category/framework/spring/spring-annotation/"/>
      <url>/2017/12/07/aa_category/framework/spring/spring-annotation/</url>
      
        <content type="html"><![CDATA[<h1 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MovieCatalog[] movieCatalogs;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Set&lt;MovieCatalog&gt; movieCatalogs;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieCatalogs</span><span class="params">(Set&lt;MovieCatalog&gt; movieCatalogs)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.movieCatalogs = movieCatalogs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Map&lt;String, MovieCatalog&gt; movieCatalogs;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieCatalogs</span><span class="params">(Map&lt;String, MovieCatalog&gt; movieCatalogs)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.movieCatalogs = movieCatalogs;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="自动引入容器中的对象"><a href="#自动引入容器中的对象" class="headerlink" title="自动引入容器中的对象"></a>自动引入容器中的对象</h2><p>You can also use @Autowired for interfaces that are well-known resolvable dependencies: BeanFactory , ApplicationContext , Environment , ResourceLoader ,<br>ApplicationEventPublisher , and MessageSource . These interfaces and their extended interfaces,such as ConfigurableApplicationContext or ResourcePatternResolver , are automatically resolved, with no special setup necessary</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ApplicationContext context;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Primary"><a href="#Primary" class="headerlink" title="@Primary"></a>@Primary</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieConfiguration</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span>   <span class="comment">//如果只需要注入一个bean,这个优先注入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MovieCatalog <span class="title">firstMovieCatalog</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MovieCatalog <span class="title">secondMovieCatalog</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h1>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring:lifecycle</title>
      <link href="/2017/12/07/aa_category/framework/spring/Spring-lifecycle/"/>
      <url>/2017/12/07/aa_category/framework/spring/Spring-lifecycle/</url>
      
        <content type="html"><![CDATA[<h1 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifecycleProcessor</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h1><ol><li>主键</li><li>接口实现</li><li>全局配置的方法名<br>If multiple lifecycle mechanisms are configured for a bean, and each mechanism is configured with a different method name, then each configured method is executed in the order listed below. However, if the same method name is configured - for example,<br>init() for an initialization method - for more than one of these lifecycle mechanisms,<br>that method is executed once, as explained in the preceding section.</li></ol><p>You can also use @Autowired for interfaces that are well-known resolvable dependencies:<br>BeanFactory , ApplicationContext , Environment , ResourceLoader ,<br>ApplicationEventPublisher , and MessageSource . These interfaces and their extended interfaces,<br>such as ConfigurableApplicationContext or ResourcePatternResolver , are automatically<br>resolved, with no special setup necessary</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lifecycle </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis:返回值</title>
      <link href="/2017/11/29/aa_category/framework/mybatis/Mybatis-%E8%BF%94%E5%9B%9E%E5%80%BC/"/>
      <url>/2017/11/29/aa_category/framework/mybatis/Mybatis-%E8%BF%94%E5%9B%9E%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>从源码分析mybatis怎么处理返回值</p><a id="more"></a><h1 id="PreparedStatementHandler-query开始分析调用栈"><a href="#PreparedStatementHandler-query开始分析调用栈" class="headerlink" title="PreparedStatementHandler.query开始分析调用栈"></a>PreparedStatementHandler.query开始分析调用栈</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入的resultHandler为空，没有使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; PreparedStatementHandler.query(Statement statement, ResultHandler resultHandler) <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">   PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">   ps.execute();</span><br><span class="line">   <span class="keyword">return</span> resultSetHandler.&lt;E&gt; handleResultSets(ps);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="DefaultResultSetHandler-handleResultSets分析"><a href="#DefaultResultSetHandler-handleResultSets分析" class="headerlink" title="DefaultResultSetHandler.handleResultSets分析"></a>DefaultResultSetHandler.handleResultSets分析</h1><ul><li>DefaultResultSetHandler.handleResultSets(Statement)</li><li>DefaultResultSetHandler.getFirstResultSet(Statement)，根据Statement-&gt;ResultSet-&gt;ResultSetWrapper,简单来说就是把ResultSet包装成ResultSetWrapper    </li><li>DefaultResultSetHandler.handleResultSet(ResultSetWrapper, ResultMap, List<object>, ResultMapping)</object></li><li>DefaultResultSetHandler.handleRowValues(ResultSetWrapper, ResultMap, ResultHandler&lt;?&gt;, RowBounds, ResultMapping)</li><li>DefaultResultSetHandler.handleRowValuesForSimpleResultMap(ResultSetWrapper, ResultMap, ResultHandler&lt;?&gt;, RowBounds, ResultMapping)</li><li>DefaultResultSetHandler.skipRows(ResultSet, RowBounds)跳过小于Offset的数据</li><li>DefaultResultSetHandler.resolveDiscriminatedResultMap(ResultSet, ResultMap, String)方法处理返回结果包含Discriminated的场景</li><li>DefaultResultSetHandler.getRowValue(ResultSetWrapper, ResultMap)</li><li>DefaultResultSetHandler.applyAutomaticMappings(ResultSetWrapper, ResultMap, MetaObject, String)</li><li>DefaultResultSetHandler.createAutomaticMappings(ResultSetWrapper, ResultMap, MetaObject, String)</li><li>ResultSetWrapper.getUnmappedColumnNames(ResultMap, String)</li><li>ResultSetWrapper.loadMappedAndUnmappedColumnNames(ResultMap, String)加载映射过的列和没有映射过的列</li><li>DefaultResultSetHandler.createResultObject(ResultSetWrapper, ResultMap, ResultLoaderMap, String)</li><li>DefaultResultSetHandler.createResultObject(ResultSetWrapper, ResultMap, List&lt;Class&lt;?&gt;&gt;, List<object>, String)使用objectFactory</object></li></ul><h2 id="DefaultResultSetHandler-handleResultSet分析"><a href="#DefaultResultSetHandler-handleResultSet分析" class="headerlink" title="DefaultResultSetHandler.handleResultSet分析"></a>DefaultResultSetHandler.handleResultSet分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleResultSet</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Object&gt; multipleResults, ResultMapping parentMapping)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parentMapping != <span class="keyword">null</span>) &#123;</span><br><span class="line">      handleRowValues(rsw, resultMap, <span class="keyword">null</span>, RowBounds.DEFAULT, parentMapping);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        DefaultResultHandler defaultResultHandler = <span class="keyword">new</span> DefaultResultHandler(objectFactory);</span><br><span class="line">        handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, <span class="keyword">null</span>);</span><br><span class="line">        multipleResults.add(defaultResultHandler.getResultList());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handleRowValues(rsw, resultMap, resultHandler, rowBounds, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    closeResultSet(rsw.getResultSet());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DefaultResultSetHandler-applyAutomaticMappings分析"><a href="#DefaultResultSetHandler-applyAutomaticMappings分析" class="headerlink" title="DefaultResultSetHandler.applyAutomaticMappings分析"></a>DefaultResultSetHandler.applyAutomaticMappings分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">applyAutomaticMappings</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   <span class="comment">//创建没有映射字段的自动映射</span></span><br><span class="line">  List&lt;UnMappedColumnAutoMapping&gt; autoMapping = createAutomaticMappings(rsw, resultMap, metaObject, columnPrefix);</span><br><span class="line">  <span class="keyword">boolean</span> foundValues = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (autoMapping.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (UnMappedColumnAutoMapping mapping : autoMapping) &#123;</span><br><span class="line">      <span class="comment">//使用typeHandler，根据列名和ResultSet查找对应的值</span></span><br><span class="line">      <span class="keyword">final</span> Object value = mapping.typeHandler.getResult(rsw.getResultSet(), mapping.column);</span><br><span class="line">      <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        foundValues = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (value != <span class="keyword">null</span> || (configuration.isCallSettersOnNulls() &amp;&amp; !mapping.primitive)) &#123;</span><br><span class="line">         <span class="comment">//对象的对应属性赋值</span></span><br><span class="line">        metaObject.setValue(mapping.property, value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> foundValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DefaultResultSetHandler-createAutomaticMappings分析"><a href="#DefaultResultSetHandler-createAutomaticMappings分析" class="headerlink" title="DefaultResultSetHandler.createAutomaticMappings分析"></a>DefaultResultSetHandler.createAutomaticMappings分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;UnMappedColumnAutoMapping&gt; <span class="title">createAutomaticMappings</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String mapKey = resultMap.getId() + <span class="string">":"</span> + columnPrefix;</span><br><span class="line">    List&lt;UnMappedColumnAutoMapping&gt; autoMapping = autoMappingsCache.get(mapKey);</span><br><span class="line">    <span class="keyword">if</span> (autoMapping == <span class="keyword">null</span>) &#123;</span><br><span class="line">      autoMapping = <span class="keyword">new</span> ArrayList&lt;UnMappedColumnAutoMapping&gt;();</span><br><span class="line">      <span class="comment">//查找没有映射的字段</span></span><br><span class="line">      <span class="keyword">final</span> List&lt;String&gt; unmappedColumnNames = rsw.getUnmappedColumnNames(resultMap, columnPrefix);</span><br><span class="line">      <span class="keyword">for</span> (String columnName : unmappedColumnNames) &#123;</span><br><span class="line">        String propertyName = columnName;</span><br><span class="line">        <span class="keyword">final</span> String property = metaObject.findProperty(propertyName, configuration.isMapUnderscoreToCamelCase());</span><br><span class="line">        <span class="keyword">if</span> (property != <span class="keyword">null</span> &amp;&amp; metaObject.hasSetter(property)) &#123;</span><br><span class="line">   <span class="comment">//定位字段的类型</span></span><br><span class="line">          <span class="keyword">final</span> Class&lt;?&gt; propertyType = metaObject.getSetterType(property);</span><br><span class="line">          <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(propertyType, rsw.getJdbcType(columnName))) &#123;</span><br><span class="line">            <span class="comment">//根据JavaType和jdbcType确定TypeHandler</span></span><br><span class="line">            <span class="keyword">final</span> TypeHandler&lt;?&gt; typeHandler = rsw.getTypeHandler(propertyType, columnName);</span><br><span class="line">            <span class="comment">//添加到UnMappedColumnAutoMapping集合中</span></span><br><span class="line">            autoMapping.add(<span class="keyword">new</span> UnMappedColumnAutoMapping(columnName, property, typeHandler, propertyType.isPrimitive()));</span><br><span class="line">          &#125; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 根据配置参数 NONE, WARNING, FAILING 做出相应的测落</span></span><br><span class="line">          configuration.getAutoMappingUnknownColumnBehavior()</span><br><span class="line">              .doAction(mappedStatement, columnName, (property != <span class="keyword">null</span>) ? property : propertyName, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      autoMappingsCache.put(mapKey, autoMapping);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> autoMapping;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="DefaultResultSetHandler-storeObject"><a href="#DefaultResultSetHandler-storeObject" class="headerlink" title="DefaultResultSetHandler.storeObject"></a>DefaultResultSetHandler.storeObject</h2><ul><li>DefaultResultSetHandler.storeObject-&gt;DefaultResultSetHandler.callResultHandler-&gt;ResultHandler.handleResult</li><li>方法实现把查询的对象存放到ResultHandler</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> mybatis </tag>
            
            <tag> return </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis:Plugin</title>
      <link href="/2017/11/29/aa_category/framework/mybatis/Mybatis-Plugin/"/>
      <url>/2017/11/29/aa_category/framework/mybatis/Mybatis-Plugin/</url>
      
        <content type="html"><![CDATA[<ul><li>从源码分析Mybatis的插件</li><li>熟悉Java代理模式的应用场景</li></ul><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li>Configuration持有对象InterceptorChain</li><li>通过Configuration的addInterceptor注入拦截器（插件）</li><li>需要拦截的对象（Executor 、ParameterHandler 、ResultSetHandler 、StatementHandler ）创建完毕以后通过调用interceptorChain.pluginAll（target）对应的代理对象</li><li>进行实际执行的时候触发的就是代理对象</li></ul><h1 id="获取ParameterHandler的代理对象"><a href="#获取ParameterHandler的代理对象" class="headerlink" title="获取ParameterHandler的代理对象"></a>获取ParameterHandler的代理对象</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建target对象parameterHandler</span></span><br><span class="line">ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">   <span class="comment">//获取target对应的proxy对象</span></span><br><span class="line">   parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *进行遍历拦截，从源码上分析，同一个对象如果被多个插件拦截，最后插入的优先级最高</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">     target = interceptor.plugin(target);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> target;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *返回当前对象代理对象</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Object PageInterceptor.plugin(Object target) &#123;</span><br><span class="line">       <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 根据接口返回代理对象</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Object Plugin.wrap(Object target, Interceptor interceptor) &#123;</span><br><span class="line">   <span class="comment">//根据@Intercepts、@Signature获取要代理的接口以及对应的方法</span></span><br><span class="line">   Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">   Class&lt;?&gt; type = target.getClass();</span><br><span class="line">   <span class="comment">//查看当前类型是否有对应的接口</span></span><br><span class="line">   Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">   <span class="comment">//如果有就返回代理对象，否则返回target本身</span></span><br><span class="line">   <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">         type.getClassLoader(),</span><br><span class="line">         interfaces,</span><br><span class="line">         <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> target;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="Plugin分析"><a href="#Plugin分析" class="headerlink" title="Plugin分析"></a>Plugin分析</h1><ul><li>所有target返回的代理对象为Plugin对象</li><li>Plugin只有要拦截的target，已经拦截器interceptor，以及要拦截target的哪些方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plugin</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</span><br><span class="line">      <span class="comment">//判断是否需要拦截目标对象的此方法，如果需要进行拦截，如果没必要直接调用target的对应方法</span></span><br><span class="line">      <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.contains(method)) &#123;</span><br><span class="line">      <span class="comment">//实际处理逻辑留给interceptor的实现类处理</span></span><br><span class="line">        <span class="keyword">return</span> interceptor.intercept(<span class="keyword">new</span> Invocation(target, method, args));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接口Interceptor分析"><a href="#接口Interceptor分析" class="headerlink" title="接口Interceptor分析"></a>接口Interceptor分析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="comment">//拦截用到的方法</span></span><br><span class="line">  <span class="comment">//Invocation对象包含target,method,args</span></span><br><span class="line">  <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">  <span class="comment">//返回target对应的Proxy</span></span><br><span class="line">  <span class="function">Object <span class="title">plugin</span><span class="params">(Object target)</span></span>;</span><br><span class="line">  <span class="comment">//初始化的时候注入一些额外需要的属性</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>俗话说的好学以致用，通过Plugin的分析，对于同事或者领导说的给代码留个口子，有一定的体会</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
            <tag> plugin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis:Select</title>
      <link href="/2017/11/28/aa_category/framework/mybatis/Mybatis-Select/"/>
      <url>/2017/11/28/aa_category/framework/mybatis/Mybatis-Select/</url>
      
        <content type="html"><![CDATA[<ul><li>分析Mapper查询的执行过程</li><li>有关Mapper的构建过程请参考<a href="http://liyong.ac.cn/2017/11/24/Mybatis-Builder/">Mybatis-Builder</a></li></ul><a id="more"></a><h1 id="Mapper接口适配SqlSession接口"><a href="#Mapper接口适配SqlSession接口" class="headerlink" title="Mapper接口适配SqlSession接口"></a>Mapper接口适配SqlSession接口</h1><ul><li>session.getMapper获取到代理类 MapperProxy</li><li>org.apache.ibatis.binding.MapperProxy.invoke(Object, Method, Object[])</li><li>org.apache.ibatis.binding.MapperMethod.execute(SqlSession, Object[])</li><li>解析参数org.apache.ibatis.binding.MapperMethod.MethodSignature.convertArgsToSqlCommandParam(Object[])</li><li>org.apache.ibatis.session.SqlSession.selectOne(String, Object)</li></ul><h1 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h1><h2 id="ParamNameResolver构造函数逻辑"><a href="#ParamNameResolver构造函数逻辑" class="headerlink" title="ParamNameResolver构造函数逻辑"></a>ParamNameResolver构造函数逻辑</h2><ul><li>首先通过@Param解析参数index对应的参数name</li><li>其次通过反射解析参数index对应的参数name</li><li>最后设置name=index</li></ul><h2 id="ParamNameResolver-getNamedParams-Object-逻辑"><a href="#ParamNameResolver-getNamedParams-Object-逻辑" class="headerlink" title="ParamNameResolver.getNamedParams(Object[])逻辑"></a>ParamNameResolver.getNamedParams(Object[])逻辑</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getNamedParams</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> paramCount = names.size();</span><br><span class="line">  <span class="comment">//如果参数为空直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (args == <span class="keyword">null</span> || paramCount == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">//如果没有参数注解且参数个数为1返回第一个参数</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasParamAnnotation &amp;&amp; paramCount == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> args[names.firstKey()];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, Object&gt; param = <span class="keyword">new</span> ParamMap&lt;Object&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">// names=[0=id,1=name] or  names=[0=0,1=0]</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : names.entrySet()) &#123;</span><br><span class="line">   <span class="comment">//entry.getValue()=id,entry.getKey()=0 ,args[entry.getKey()]=idValue</span></span><br><span class="line">      param.put(entry.getValue(), args[entry.getKey()]);</span><br><span class="line">      <span class="keyword">final</span> String genericParamName = GENERIC_NAME_PREFIX + String.valueOf(i + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// ensure not to overwrite parameter named with @Param</span></span><br><span class="line">      <span class="keyword">if</span> (!names.containsValue(genericParamName)) &#123;</span><br><span class="line">        param.put(genericParamName, args[entry.getKey()]);</span><br><span class="line">      &#125;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> param;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SqlSeesion执行过程"><a href="#SqlSeesion执行过程" class="headerlink" title="SqlSeesion执行过程"></a>SqlSeesion执行过程</h2><p>SqlSeesion-&gt;Executor-&gt;StatementHandler-&gt;Statement</p><ul><li>org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(String, Object)</li><li>org.apache.ibatis.executor.CachingExecutor.query(    , Object, RowBounds, ResultHandler)</li><li>根据BoundSql获取BoundSql</li><li>创建CacheKey</li><li>CachingExecutor.query(MappedStatement, Object, RowBounds, ResultHandler, CacheKey, BoundSql)</li><li>BaseExecutor.query(MappedStatement, Object, RowBounds, ResultHandler, CacheKey, BoundSql)</li><li>BaseExecutor.queryFromDatabase(MappedStatement, Object, RowBounds, ResultHandler, CacheKey, BoundSql)</li><li>SimpleExecutor.doQuery(MappedStatement, Object, RowBounds, ResultHandler, BoundSql)</li><li>创建StatementHandler</li><li>准备Statement<ul><li>获取Connection</li><li>初始化Statement</li><li>设置超时</li><li>设置,stmt.setFetchSize</li><li>设置用户传入的参数</li></ul></li><li>org.apache.ibatis.executor.statement.StatementHandler.update(Statement)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     Configuration configuration = ms.getConfiguration();</span><br><span class="line">     StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">     stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">     <span class="keyword">return</span> handler.&lt;E&gt;query(stmt, resultHandler);</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     closeStatement(stmt);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="创建StatementHandler"><a href="#创建StatementHandler" class="headerlink" title="创建StatementHandler"></a>创建StatementHandler</h2><ul><li>创建RoutingStatementHandler</li><li>根据StatementType选择实际的PreparedStatementHandler</li><li>PreparedStatementHandler构造器调用BaseStatementHandler的构造器</li><li>创建parameterHandler</li><li>创建resultSetHandler</li></ul><h2 id="设置用户传入的参数"><a href="#设置用户传入的参数" class="headerlink" title="设置用户传入的参数"></a>设置用户传入的参数</h2><ul><li>org.apache.ibatis.executor.statement.StatementHandler.parameterize(Statement)</li><li>org.apache.ibatis.executor.statement.RoutingStatementHandler.parameterize(Statement)</li><li>org.apache.ibatis.executor.statement.PreparedStatementHandler.parameterize(Statement)</li><li>org.apache.ibatis.scripting.defaults.DefaultParameterHandler.setParameters(PreparedStatement)</li><li>org.apache.ibatis.type.BaseTypeHandler.setParameter(PreparedStatement, int, T, JdbcType)</li><li>org.apache.ibatis.type.UnknownTypeHandler.setNonNullParameter(PreparedStatement, int, Object, JdbcType)</li><li>org.apache.ibatis.type.BaseTypeHandler.setParameter(PreparedStatement, int, T, JdbcType)</li></ul><h2 id="返回结果处理"><a href="#返回结果处理" class="headerlink" title="返回结果处理"></a>返回结果处理</h2><ul><li>org.apache.ibatis.executor.SimpleExecutor.doQuery(MappedStatement, Object, RowBounds, ResultHandler, BoundSql)</li><li>org.apache.ibatis.executor.statement.RoutingStatementHandler.query(Statement, ResultHandler)</li><li>org.apache.ibatis.executor.statement.PreparedStatementHandler.query(Statement, ResultHandler)</li><li>org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleResultSets(Statement)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入的resultHandler为空，没有使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; PreparedStatementHandler.query(Statement statement, ResultHandler resultHandler) <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">   PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">   ps.execute();</span><br><span class="line">   <span class="keyword">return</span> resultSetHandler.&lt;E&gt; handleResultSets(ps);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>详情请参考<a href="http://liyong.ac.cn/2017/11/29/Mybatis-返回值/">Mybatis:返回值</a></p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
            <tag> select </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis:Configuration分析说明</title>
      <link href="/2017/11/28/aa_category/framework/mybatis/Mybatis-Configuration%E5%88%86%E6%9E%90%E8%AF%B4%E6%98%8E/"/>
      <url>/2017/11/28/aa_category/framework/mybatis/Mybatis-Configuration%E5%88%86%E6%9E%90%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p> //namespace为cache-ref所在的mapper的namespace，referencedNamespace是引用的空间<br> cacheRefMap.put(namespace, referencedNamespace);</p><p> useActualParamName：jdk8以后可以使用，使用实际的方法参数名</p><p>//插件链<br>InterceptorChain interceptorChain = new InterceptorChain();</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis:Lifecycle</title>
      <link href="/2017/11/28/aa_category/framework/mybatis/Mybatis-Lifecycle/"/>
      <url>/2017/11/28/aa_category/framework/mybatis/Mybatis-Lifecycle/</url>
      
        <content type="html"><![CDATA[<h1 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h1><h2 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h2><p>构建完SqlSessionFactory生命结束</p><h2 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h2><p>Once created, the SqlSessionFactory should exist for the duration of your application execution. </p><h2 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h2><p>Each thread should have its own instance of SqlSession. Instances of SqlSession are not to be shared and are not thread safe.<br>Therefore the best scope is request or method scope.</p><h2 id="Mapper-Instances"><a href="#Mapper-Instances" class="headerlink" title="Mapper Instances"></a>Mapper Instances</h2><p>和SqlSession一致或者更小</p>]]></content>
      
      
      
        <tags>
            
            <tag> lifecycle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis:spring</title>
      <link href="/2017/11/27/aa_category/framework/mybatis/Mybatis-spring/"/>
      <url>/2017/11/27/aa_category/framework/mybatis/Mybatis-spring/</url>
      
        <content type="html"><![CDATA[<p>sqlSessionFactoryBean创建sqlSessionFactoryB</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis:Cache</title>
      <link href="/2017/11/27/aa_category/framework/mybatis/Mybatis-Cache/"/>
      <url>/2017/11/27/aa_category/framework/mybatis/Mybatis-Cache/</url>
      
        <content type="html"><![CDATA[<p>Mybatis的缓存分为一级缓存和二级缓存<br>Cache 就是 Map</p><a id="more"></a><h1 id="获取会话"><a href="#获取会话" class="headerlink" title="获取会话"></a>获取会话</h1><p>DefaultSqlSessionFactory.openSession()<br>DefaultSqlSessionFactory.openSessionFromDataSource()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">      <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">      <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Configuration.newExecutor(Transaction, ExecutorType)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">  Executor executor;</span><br><span class="line">  <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cacheEnabled) &#123;   </span><br><span class="line">     <span class="comment">// 只有cacheEnabled==true才可以使用二级缓存</span></span><br><span class="line">     <span class="comment">//此种写法使用了设计模式之装饰模式</span></span><br><span class="line">    executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">  &#125;</span><br><span class="line">  executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">  <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h1><p>查询先看二级缓存，再看一级缓存<br><img src="1.png" alt="1">]</p><h1 id="MappedStatement-cache的构建"><a href="#MappedStatement-cache的构建" class="headerlink" title="MappedStatement.cache的构建"></a>MappedStatement.cache的构建</h1><h2 id="CacheNamespace"><a href="#CacheNamespace" class="headerlink" title="CacheNamespace"></a>CacheNamespace</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CacheNamespace &#123;</span><br><span class="line">  Class&lt;? extends org.apache.ibatis.cache.Cache&gt; implementation() <span class="keyword">default</span> PerpetualCache.class;</span><br><span class="line">  Class&lt;? extends org.apache.ibatis.cache.Cache&gt; eviction() <span class="keyword">default</span> LruCache.class;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">flushInterval</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">default</span> 1024</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">readWrite</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">blocking</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 1、这个属性通过反射机制实现了，不同实现类设置不同的属性</span></span><br><span class="line"><span class="comment">   *  </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Property[] properties() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用CacheNamespace构建过程"><a href="#使用CacheNamespace构建过程" class="headerlink" title="使用CacheNamespace构建过程"></a>使用CacheNamespace构建过程</h2><ul><li>MapperAnnotationBuilder.parseCache解析CacheNamespace注解</li><li>MapperBuilderAssistant.useNewCache</li><li>CacheBuilder的构建</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Cache <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  setDefaultImplementations();</span><br><span class="line">  Cache cache = newBaseCacheInstance(implementation, id);</span><br><span class="line">  <span class="comment">// 需要着重关注</span></span><br><span class="line">  setCacheProperties(cache);</span><br><span class="line">  <span class="comment">// issue #352, do not apply decorators to custom caches</span></span><br><span class="line">  <span class="keyword">if</span> (PerpetualCache.class.equals(cache.getClass())) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;? extends Cache&gt; decorator : decorators) &#123;</span><br><span class="line">      cache = newCacheDecoratorInstance(decorator, cache);</span><br><span class="line">      setCacheProperties(cache);</span><br><span class="line">    &#125;</span><br><span class="line">    cache = setStandardDecorators(cache);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!LoggingCache.class.isAssignableFrom(cache.getClass())) &#123;</span><br><span class="line">    cache = <span class="keyword">new</span> LoggingCache(cache);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CacheNamespace.properties的应用场景</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setCacheProperties</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (properties != <span class="keyword">null</span>) &#123;</span><br><span class="line">    MetaObject metaCache = SystemMetaObject.forObject(cache);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">      String name = (String) entry.getKey();</span><br><span class="line">      String value = (String) entry.getValue();</span><br><span class="line">      <span class="keyword">if</span> (metaCache.hasSetter(name)) &#123;</span><br><span class="line">        Class&lt;?&gt; type = metaCache.getSetterType(name);</span><br><span class="line">        <span class="keyword">if</span> (String.class == type) &#123;</span><br><span class="line">          metaCache.setValue(name, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">int</span>.class == type</span><br><span class="line">            || Integer.class == type) &#123;</span><br><span class="line">          metaCache.setValue(name, Integer.valueOf(value));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">"Unsupported property type for cache: '"</span> + name + <span class="string">"' of type "</span> + type);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="CacheNamespaceRef"><a href="#CacheNamespaceRef" class="headerlink" title="@CacheNamespaceRef"></a>@CacheNamespaceRef</h2><p>org.apache.ibatis.builder.annotation.MapperAnnotationBuilder.parseCacheRef()<br>org.apache.ibatis.builder.MapperBuilderAssistant.useCacheRef(String)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Cache <span class="title">useCacheRef</span><span class="params">(String namespace)</span> </span>&#123;</span><br><span class="line">    unresolvedCacheRef = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">// 关键</span></span><br><span class="line">    Cache cache = configuration.getCache(namespace);</span><br><span class="line">    currentCache = cache;</span><br><span class="line">    unresolvedCacheRef = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h1><p>一级缓存称为本地缓存，属于sqlSession级别的缓存，在一个SqlSession内有效<br>SqlSession:Executor:Cache=1:1:1</p><h2 id="BaseExecutor"><a href="#BaseExecutor" class="headerlink" title="BaseExecutor"></a>BaseExecutor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//如果一级缓存中存在则从一级缓存中获取，否则从数据库中获取</span></span><br><span class="line">      list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      queryStack--;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 通过设置LocalCacheScope.STATEMENT可以去掉一级缓存</span></span><br><span class="line">      <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">        <span class="comment">// issue #482</span></span><br><span class="line">        clearLocalCache();</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="清除一级缓存"><a href="#清除一级缓存" class="headerlink" title="清除一级缓存"></a>清除一级缓存</h2><p>session.clearCache()只会清除一级缓存<br>去掉一级缓存 localCacheScope设置成STATEMENT</p><h1 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h1><h3 id="二级缓存的存放路径"><a href="#二级缓存的存放路径" class="headerlink" title="二级缓存的存放路径"></a>二级缓存的存放路径</h3><p>MappedStatement-&gt;SynchronizedCache-&gt;LoggingCache-&gt;SerializedCache-&gt;LruCache-&gt;PerpetualCache-&gt;Map</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol><li>二级缓存是全局缓存</li><li>二级缓存基于namespace或则mapper</li><li>如果会话关闭就好把一级缓存中的数据保存到二级缓存</li></ol><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ol><li>开启二级缓存配置cacheEnabled</li><li>mapper中配置cache </li><li>POJO需要实现序列化接口</li><li>select.useCache设置二级缓存</li><li>sql.flushCache会清理一级缓存和二级缓存都清空</li><li>select.flushCache则不会使用缓存</li></ol><h2 id="一级缓存转化二级缓存"><a href="#一级缓存转化二级缓存" class="headerlink" title="一级缓存转化二级缓存"></a>一级缓存转化二级缓存</h2><ol><li>SqlSession的commit或者close方法触发CachingExecutor对应的commit和close方法</li><li>CachingExecutor的commit或者close方法触发TransactionalCacheManager.commit方法</li><li>触发TransactionalCache.commit方法</li><li>触发TransactionalCache.flushPendingEntries</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushPendingEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : entriesToAddOnCommit.entrySet()) &#123;</span><br><span class="line">    <span class="comment">//delegate==MappedStatement.SynchronizedCache</span></span><br><span class="line">    <span class="comment">//每每看到这，感叹设计之巧妙，牛</span></span><br><span class="line">    delegate.putObject(entry.getKey(), entry.getValue());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (Object entry : entriesMissedInCache) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!entriesToAddOnCommit.containsKey(entry)) &#123;</span><br><span class="line">      delegate.putObject(entry, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="整合Ecache"><a href="#整合Ecache" class="headerlink" title="整合Ecache"></a>整合Ecache</h1><p>1、导入第三方包<br>2、导入适配包<br>3、mapper.xml中引用缓存</p><p>xml 注解优先级</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
            <tag> cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis:通用Mapper入口解析</title>
      <link href="/2017/11/24/aa_category/framework/mybatis/Mybatis-%E9%80%9A%E7%94%A8Mapper%E5%85%A5%E5%8F%A3%E8%A7%A3%E6%9E%90/"/>
      <url>/2017/11/24/aa_category/framework/mybatis/Mybatis-%E9%80%9A%E7%94%A8Mapper%E5%85%A5%E5%8F%A3%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>通用Mapper是怎么适配Mybatis的</p><a id="more"></a><h1 id="mapperHelper-registerMapper分析"><a href="#mapperHelper-registerMapper分析" class="headerlink" title="mapperHelper.registerMapper分析"></a>mapperHelper.registerMapper分析</h1><ul><li>tk.mybatis.mapper.mapperhelper.MapperHelper.registerMapper(Class&lt;?&gt;)</li><li>tk.mybatis.mapper.mapperhelper.MapperHelper.fromMapperClass(Class&lt;?&gt;)，注册Mapper 和 MapperTemplate之间的映射关系</li><li>如果有父接口递归调用MapperHelper.registerMapper</li></ul><h1 id="mapperHelper-processConfiguration-分析"><a href="#mapperHelper-processConfiguration-分析" class="headerlink" title="mapperHelper.processConfiguration 分析"></a>mapperHelper.processConfiguration 分析</h1><ul><li>tk.mybatis.mapper.mapperhelper.MapperHelper.processConfiguration(Configuration)</li><li>tk.mybatis.mapper.mapperhelper.MapperHelper.processConfiguration(Configuration, Class&lt;?&gt;)</li><li>tk.mybatis.mapper.mapperhelper.MapperHelper.setSqlSource(MappedStatement)</li><li>tk.mybatis.mapper.mapperhelper.MapperTemplate.setSqlSource(MappedStatement)</li><li>tk.mybatis.mapper.mapperhelper.MapperTemplate.createSqlSource(MappedStatement, String)</li><li>tk.mybatis.mapper.mapperhelper.MapperTemplate.setSqlSource(MappedStatement, SqlSource)</li></ul><h2 id="MapperTemplate-setSqlSource-MappedStatement-分析"><a href="#MapperTemplate-setSqlSource-MappedStatement-分析" class="headerlink" title="MapperTemplate.setSqlSource(MappedStatement)分析"></a>MapperTemplate.setSqlSource(MappedStatement)分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSource</span><span class="params">(MappedStatement ms)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//根据方法名找到方法类对象</span></span><br><span class="line">       Method method = methodMap.get(getMethodName(ms));</span><br><span class="line">       <span class="keyword">try</span> &#123;   <span class="comment">//调用MapperTemplate的对应方法，返回XML形式的sql</span></span><br><span class="line">               String xmlSql = (String) method.invoke(<span class="keyword">this</span>, ms);</span><br><span class="line"><span class="comment">// 根据XML形式的sql生成SqlSource对象</span></span><br><span class="line">               SqlSource sqlSource = createSqlSource(ms, xmlSql);</span><br><span class="line">               <span class="comment">//替换原有的SqlSource</span></span><br><span class="line">               setSqlSource(ms, sqlSource);</span><br><span class="line">           checkCache(ms);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> MapperException(e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="MapperTemplate-createSqlSource分析"><a href="#MapperTemplate-createSqlSource分析" class="headerlink" title="MapperTemplate.createSqlSource分析"></a>MapperTemplate.createSqlSource分析</h2><h3 id="对象持有关系"><a href="#对象持有关系" class="headerlink" title="对象持有关系"></a>对象持有关系</h3><ul><li>DocumentBuilderFactory-&gt;DocumentBuilder-&gt;Document</li><li>XMLLanguageDriver-&gt;XPathParser-&gt;XPath</li><li>XMLScriptBuilder-&gt;XNode</li></ul><h3 id="MapperTemplate生成的sql"><a href="#MapperTemplate生成的sql" class="headerlink" title="MapperTemplate生成的sql"></a>MapperTemplate生成的sql</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">"id_cache"</span> <span class="attr">value</span>=<span class="string">"id"</span>/&gt;</span>INSERT INTO <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"@tk.mybatis.mapper.util.OGNL@isDynamicParameter(_parameter) and dynamicTableName != null and dynamicTableName != ''"</span>&gt;</span></span></span></span><br><span class="line">$&#123;dynamicTableName&#125;</span><br><span class="line"><span class="actionscript">&lt;/<span class="keyword">if</span>&gt;</span></span><br><span class="line"><span class="actionscript">&lt;<span class="keyword">if</span> test=<span class="string">"@tk.mybatis.mapper.util.OGNL@isNotDynamicParameter(_parameter) or dynamicTableName == null or dynamicTableName == ''"</span>&gt;</span></span><br><span class="line">blog</span><br><span class="line"><span class="actionscript">&lt;/<span class="keyword">if</span>&gt; </span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"("</span> <span class="attr">suffix</span>=<span class="string">")"</span> <span class="attr">suffixOverrides</span>=<span class="string">","</span>&gt;</span>id,name,<span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"VALUES("</span> <span class="attr">suffix</span>=<span class="string">")"</span> <span class="attr">suffixOverrides</span>=<span class="string">","</span>&gt;</span></span></span></span><br><span class="line"><span class="vbscript"> &lt;<span class="keyword">if</span> test=<span class="string">"id_cache != null"</span>&gt;#&#123;id_cache,javaType=java.lang.<span class="built_in">String</span>&#125;,</span></span><br><span class="line"><span class="vbscript"> &lt;/<span class="keyword">if</span>&gt;&lt;<span class="keyword">if</span> test=<span class="string">"id_cache == null"</span>&gt;#&#123;id,javaType=java.lang.<span class="built_in">String</span>&#125;,</span></span><br><span class="line"><span class="vbscript"> &lt;/<span class="keyword">if</span>&gt;&lt;<span class="keyword">if</span> test=<span class="string">"name != null"</span>&gt;#&#123;name,javaType=java.lang.<span class="built_in">String</span>&#125;,&lt;/<span class="keyword">if</span>&gt;</span></span><br><span class="line"><span class="vbscript"> &lt;<span class="keyword">if</span> test=<span class="string">"name == null"</span>&gt;#&#123;name,javaType=java.lang.<span class="built_in">String</span>&#125;,&lt;/<span class="keyword">if</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h3><ul><li>org.apache.ibatis.scripting.xmltags.XMLLanguageDriver.createSqlSource(Configuration, String, Class&lt;?&gt;)</li><li>创建org.apache.ibatis.parsing.XPathParser(String, boolean, Properties, EntityResolver)对象</li><li>org.apache.ibatis.scripting.xmltags.XMLLanguageDriver.createSqlSource(Configuration, XNode, Class&lt;?&gt;)</li><li>org.apache.ibatis.scripting.xmltags.XMLScriptBuilder.parseScriptNode()</li><li>org.apache.ibatis.scripting.xmltags.XMLScriptBuilder.parseDynamicTags(XNode)</li></ul><h3 id="XMLScriptBuilder-parseScriptNode-分析"><a href="#XMLScriptBuilder-parseScriptNode-分析" class="headerlink" title="XMLScriptBuilder.parseScriptNode 分析"></a>XMLScriptBuilder.parseScriptNode 分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> SqlSource <span class="title">parseScriptNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   List&lt;SqlNode&gt; contents = parseDynamicTags(context);</span><br><span class="line">   MixedSqlNode rootSqlNode = <span class="keyword">new</span> MixedSqlNode(contents);</span><br><span class="line">   SqlSource sqlSource = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 根据isDynamic创建的SqlSource</span></span><br><span class="line">   <span class="keyword">if</span> (isDynamic) &#123;</span><br><span class="line">     sqlSource = <span class="keyword">new</span> DynamicSqlSource(configuration, rootSqlNode);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     sqlSource = <span class="keyword">new</span> RawSqlSource(configuration, rootSqlNode, parameterType);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> sqlSource;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="XMLScriptBuilder-parseDynamicTags-XNode"><a href="#XMLScriptBuilder-parseDynamicTags-XNode" class="headerlink" title="XMLScriptBuilder.parseDynamicTags(XNode)"></a>XMLScriptBuilder.parseDynamicTags(XNode)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;SqlNode&gt; <span class="title">parseDynamicTags</span><span class="params">(XNode node)</span> </span>&#123;</span><br><span class="line">  List&lt;SqlNode&gt; contents = <span class="keyword">new</span> ArrayList&lt;SqlNode&gt;();</span><br><span class="line">  NodeList children = node.getNode().getChildNodes();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.getLength(); i++) &#123;</span><br><span class="line">    XNode child = node.newXNode(children.item(i));</span><br><span class="line">    <span class="keyword">if</span> (child.getNode().getNodeType() == Node.CDATA_SECTION_NODE || child.getNode().getNodeType() == Node.TEXT_NODE) &#123;</span><br><span class="line">      String data = child.getStringBody(<span class="string">""</span>);</span><br><span class="line">      TextSqlNode textSqlNode = <span class="keyword">new</span> TextSqlNode(data);</span><br><span class="line">      <span class="keyword">if</span> (textSqlNode.isDynamic()) &#123;</span><br><span class="line">        contents.add(textSqlNode);</span><br><span class="line">        isDynamic = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        contents.add(<span class="keyword">new</span> StaticTextSqlNode(data));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getNode().getNodeType() == Node.ELEMENT_NODE) &#123; <span class="comment">// issue #628</span></span><br><span class="line">      String nodeName = child.getNode().getNodeName();</span><br><span class="line">      NodeHandler handler = nodeHandlers(nodeName);</span><br><span class="line">      handler.handleNode(child, contents);</span><br><span class="line">      isDynamic = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> contents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MapperTemplate-setSqlSource-MappedStatement-SqlSource-分析"><a href="#MapperTemplate-setSqlSource-MappedStatement-SqlSource-分析" class="headerlink" title="MapperTemplate.setSqlSource(MappedStatement, SqlSource)分析"></a>MapperTemplate.setSqlSource(MappedStatement, SqlSource)分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setSqlSource</span><span class="params">(MappedStatement ms, SqlSource sqlSource)</span> </span>&#123;</span><br><span class="line">      MetaObject msObject = SystemMetaObject.forObject(ms);</span><br><span class="line"><span class="comment">//通过反射替换sqlSource</span></span><br><span class="line">      msObject.setValue(<span class="string">"sqlSource"</span>, sqlSource);</span><br><span class="line">      <span class="comment">//如果是Jdbc3KeyGenerator，就设置为MultipleJdbc3KeyGenerator</span></span><br><span class="line">      KeyGenerator keyGenerator = ms.getKeyGenerator();</span><br><span class="line">      <span class="keyword">if</span> (keyGenerator <span class="keyword">instanceof</span> Jdbc3KeyGenerator) &#123;</span><br><span class="line"><span class="comment">//通过反射keyGenerator</span></span><br><span class="line">          msObject.setValue(<span class="string">"keyGenerator"</span>, <span class="keyword">new</span> MultipleJdbc3KeyGenerator());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>mapperHelper.registerMapper注册Mapper方法对于的MapperTemplate</li><li>mapperHelper.processConfiguration处理<ul><li>首先根据方法名找到对应MapperTemplate</li><li>执行MapperTemplate对应方法，创建SqlSource对象</li><li>替换原先的SqlSource对象对象</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
            <tag> mapper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis:Builder</title>
      <link href="/2017/11/24/aa_category/framework/mybatis/Mybatis-Builder/"/>
      <url>/2017/11/24/aa_category/framework/mybatis/Mybatis-Builder/</url>
      
        <content type="html"><![CDATA[<p>通过源码分析的构建过程</p><a id="more"></a><h1 id="Annotation-Builder"><a href="#Annotation-Builder" class="headerlink" title="Annotation Builder"></a>Annotation Builder</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>MapperMethod:MapperAnnotationBuilder:MapperBuilderAssistantMappedStatement.Builder:MappedStatement= 1:1：1:1:1</li><li>调用Configuration的添加Mapper的方法</li><li>Configuration-&gt;MapperRegistry-&gt;MapperAnnotationBuilder解析</li><li>解析方法所在Mapper全称对应的xml（loadXmlResource）</li><li>解析@CacheNamespace</li><li>解析@CacheNamespaceRef</li><li>构建MappedStatement<ul><li>获取LanguageDriver</li><li>构建SqlSource</li><li>解析Options</li><li>解析SelectKey</li><li>解析ResultMap</li><li>生成MappedStatement</li></ul></li></ul><h2 id="入口及传递"><a href="#入口及传递" class="headerlink" title="入口及传递"></a>入口及传递</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Configuration</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMappers</span><span class="params">(String packageName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMappers</span><span class="params">(String packageName, Class&lt;?&gt; superType)</span></span></span><br></pre></td></tr></table></figure><p>Configuration-&gt;MapperRegistry-&gt;MapperAnnotationBuilder解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String resource = type.toString();</span><br><span class="line">  <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">    loadXmlResource();</span><br><span class="line">    configuration.addLoadedResource(resource);</span><br><span class="line">    assistant.setCurrentNamespace(type.getName());</span><br><span class="line">    parseCache();</span><br><span class="line">    parseCacheRef();</span><br><span class="line">    Method[] methods = type.getMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!method.isBridge()) &#123;</span><br><span class="line">          parseStatement(method);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">        configuration.addIncompleteMethod(<span class="keyword">new</span> MethodResolver(<span class="keyword">this</span>, method));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  parsePendingMethods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解析方法所在Mapper全称对应的xml"><a href="#解析方法所在Mapper全称对应的xml" class="headerlink" title="解析方法所在Mapper全称对应的xml"></a>解析方法所在Mapper全称对应的xml</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadXmlResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Spring may not know the real resource name so we check a flag</span></span><br><span class="line">  <span class="comment">// to prevent loading again a resource twice</span></span><br><span class="line">  <span class="comment">// this flag is set at XMLMapperBuilder#bindMapperForNamespace</span></span><br><span class="line">  <span class="keyword">if</span> (!configuration.isResourceLoaded(<span class="string">"namespace:"</span> + type.getName())) &#123;</span><br><span class="line">    String xmlResource = type.getName().replace(<span class="string">'.'</span>, <span class="string">'/'</span>) + <span class="string">".xml"</span>;</span><br><span class="line">    InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      inputStream = Resources.getResourceAsStream(type.getClassLoader(), xmlResource);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="comment">// ignore, resource is not required</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">      XMLMapperBuilder xmlParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, assistant.getConfiguration(), xmlResource, configuration.getSqlFragments(), type.getName());</span><br><span class="line">      xmlParser.parse();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解析-CacheNamespace"><a href="#解析-CacheNamespace" class="headerlink" title="解析@CacheNamespace"></a>解析@CacheNamespace</h2><p>相关细节在缓存篇描述</p><h2 id="解析-CacheNamespaceRef"><a href="#解析-CacheNamespaceRef" class="headerlink" title="解析@CacheNamespaceRef"></a>解析@CacheNamespaceRef</h2><p>相关细节在缓存篇描述</p><h2 id="构建MappedStatement"><a href="#构建MappedStatement" class="headerlink" title="构建MappedStatement"></a>构建MappedStatement</h2><h3 id="获取LanguageDriver"><a href="#获取LanguageDriver" class="headerlink" title="获取LanguageDriver"></a>获取LanguageDriver</h3><p>默认的是XMLLanguageDriver</p><h3 id="构建SqlSource"><a href="#构建SqlSource" class="headerlink" title="构建SqlSource"></a>构建SqlSource</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSource <span class="title">getSqlSourceFromAnnotations</span><span class="params">(Method method, Class&lt;?&gt; parameterType, LanguageDriver languageDriver)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;? extends Annotation&gt; sqlAnnotationType = getSqlAnnotationType(method);</span><br><span class="line">    Class&lt;? extends Annotation&gt; sqlProviderAnnotationType = getSqlProviderAnnotationType(method);</span><br><span class="line">    <span class="keyword">if</span> (sqlAnnotationType != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sqlProviderAnnotationType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"You cannot supply both a static SQL and SqlProvider to method named "</span> + method.getName());</span><br><span class="line">      &#125;</span><br><span class="line">      Annotation sqlAnnotation = method.getAnnotation(sqlAnnotationType);</span><br><span class="line">      <span class="keyword">final</span> String[] strings = (String[]) sqlAnnotation.getClass().getMethod(<span class="string">"value"</span>).invoke(sqlAnnotation);</span><br><span class="line">      <span class="keyword">return</span> buildSqlSourceFromStrings(strings, parameterType, languageDriver);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sqlProviderAnnotationType != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Annotation sqlProviderAnnotation = method.getAnnotation(sqlProviderAnnotationType);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ProviderSqlSource(assistant.getConfiguration(), sqlProviderAnnotation);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Could not find value method on SQL annotation.  Cause: "</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析Options"><a href="#解析Options" class="headerlink" title="解析Options"></a>解析Options</h3><h3 id="解析SelectKey"><a href="#解析SelectKey" class="headerlink" title="解析SelectKey"></a>解析SelectKey</h3><h3 id="解析ResultMap"><a href="#解析ResultMap" class="headerlink" title="解析ResultMap"></a>解析ResultMap</h3><h3 id="生成MappedStatement"><a href="#生成MappedStatement" class="headerlink" title="生成MappedStatement"></a>生成MappedStatement</h3><p>MapperBuilderAssistant.addMappedStatement-&gt;MappedStatement.Builder-&gt;configuration.addMappedStatement</p><h1 id="XML-Builder"><a href="#XML-Builder" class="headerlink" title="XML Builder"></a>XML Builder</h1><ul><li>org.apache.ibatis.session.SqlSessionFactoryBuilder.build(InputStream)</li><li>org.apache.ibatis.session.SqlSessionFactoryBuilder.build(InputStream, String, Properties)</li><li>Configuration org.apache.ibatis.builder.xml.XMLConfigBuilder.parse()</li><li>org.apache.ibatis.session.SqlSessionFactoryBuilder.build(Configuration)</li></ul><h2 id="分析XMLConfigBuilder-parse"><a href="#分析XMLConfigBuilder-parse" class="headerlink" title="分析XMLConfigBuilder.parse()"></a>分析XMLConfigBuilder.parse()</h2><ul><li>XMLConfigBuilder-&gt;XPathParser-&gt;XPath</li><li>org.apache.ibatis.builder.xml.XMLConfigBuilder.parse()</li><li>org.apache.ibatis.builder.xml.XMLConfigBuilder.parseConfiguration(XNode)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    propertiesElement(root.evalNode(<span class="string">"properties"</span>));</span><br><span class="line">    Properties settings = settingsAsProperties(root.evalNode(<span class="string">"settings"</span>));</span><br><span class="line">    loadCustomVfs(settings);</span><br><span class="line">    typeAliasesElement(root.evalNode(<span class="string">"typeAliases"</span>));</span><br><span class="line">    pluginElement(root.evalNode(<span class="string">"plugins"</span>));</span><br><span class="line">    objectFactoryElement(root.evalNode(<span class="string">"objectFactory"</span>));</span><br><span class="line">    objectWrapperFactoryElement(root.evalNode(<span class="string">"objectWrapperFactory"</span>));</span><br><span class="line">    reflectorFactoryElement(root.evalNode(<span class="string">"reflectorFactory"</span>));</span><br><span class="line">    settingsElement(settings);</span><br><span class="line">    <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">    environmentsElement(root.evalNode(<span class="string">"environments"</span>));</span><br><span class="line">    databaseIdProviderElement(root.evalNode(<span class="string">"databaseIdProvider"</span>));</span><br><span class="line">    typeHandlerElement(root.evalNode(<span class="string">"typeHandlers"</span>));</span><br><span class="line">    mapperElement(root.evalNode(<span class="string">"mappers"</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing SQL Mapper Configuration. Cause: "</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析properties"><a href="#解析properties" class="headerlink" title="解析properties"></a>解析properties</h3><ul><li>属性url和resource不能同时存在</li><li>相同属性优先级由低到高 ChildrenProperties-&gt;resource(url)-&gt;Variables</li></ul><h3 id="注册别名"><a href="#注册别名" class="headerlink" title="注册别名"></a>注册别名</h3><ul><li>首先用xml中的alias</li><li>其次用@Alias的值</li><li>最后使用全限定类名</li><li>alias</li></ul><h3 id="package方式解析mappers"><a href="#package方式解析mappers" class="headerlink" title="package方式解析mappers"></a>package方式解析mappers</h3><ul><li>获取配置的包名</li><li>调用org.apache.ibatis.session.Configuration.addMappers(String)</li></ul><h3 id="class方式解析mapper"><a href="#class方式解析mapper" class="headerlink" title="class方式解析mapper"></a>class方式解析mapper</h3><ul><li>根据全限定接口名称获取对应的class对象</li><li>调用org.apache.ibatis.session.Configuration.addMapper(Class&lt;?&gt;)</li></ul><h3 id="resource-amp-url方式解析mapper"><a href="#resource-amp-url方式解析mapper" class="headerlink" title="resource&amp;url方式解析mapper"></a>resource&amp;url方式解析mapper</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">"file:///var/mappers/PostMapper.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"org/mybatis/builder/PostMapper.xml"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>根据配置获取输入流</li><li>构建XMLMapperBuilder</li><li>org.apache.ibatis.builder.xml.XMLMapperBuilder.parse()</li><li>重新解析的原因是某些依赖的元素还没有解析</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLMapperBuilder</span> <span class="keyword">extends</span> <span class="title">BaseBuilder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> XPathParser parser;</span><br><span class="line">  <span class="keyword">private</span> MapperBuilderAssistant builderAssistant;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, XNode&gt; sqlFragments;</span><br><span class="line">  <span class="keyword">private</span> String resource;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、把解析失败的对象放到没有完成的集合中</span></span><br><span class="line"><span class="comment"> * 2、解析完文件之后重新执行未完成集合的解析</span></span><br><span class="line"><span class="comment"> * 3、如果解析失败不做任何处理</span></span><br><span class="line"><span class="comment"> * 4、如果解析成功从集合中移除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">      <span class="comment">// 解析mapper</span></span><br><span class="line">      configurationElement(parser.evalNode(<span class="string">"/mapper"</span>));</span><br><span class="line">      configuration.addLoadedResource(resource);</span><br><span class="line">      <span class="comment">// 1、通过namespace找Mapper</span></span><br><span class="line">      <span class="comment">// 2、然后调用org.apache.ibatis.session.Configuration.addMapper(Class&lt;?&gt;)，具体下文请参考**Annotation Builder**</span></span><br><span class="line">      bindMapperForNamespace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重新解析，之前解析失败的 ResultMap</span></span><br><span class="line">    parsePendingResultMaps();</span><br><span class="line">    <span class="comment">// 重新解析，之前解析失败的  cache-ref</span></span><br><span class="line">    parsePendingCacheRefs();</span><br><span class="line">    <span class="comment">// 重新解析，之前解析失败的 Statements</span></span><br><span class="line">    parsePendingStatements();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>分析 configurationElement</p><ul><li>cache-ref和cache同时出现则使用cache</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configurationElement</span><span class="params">(XNode context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    String namespace = context.getStringAttribute(<span class="string">"namespace"</span>);</span><br><span class="line">    <span class="keyword">if</span> (namespace == <span class="keyword">null</span> || namespace.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Mapper's namespace cannot be empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">    <span class="comment">//解析cache-ref</span></span><br><span class="line">    cacheRefElement(context.evalNode(<span class="string">"cache-ref"</span>));</span><br><span class="line">    cacheElement(context.evalNode(<span class="string">"cache"</span>));</span><br><span class="line">    parameterMapElement(context.evalNodes(<span class="string">"/mapper/parameterMap"</span>));</span><br><span class="line">    resultMapElements(context.evalNodes(<span class="string">"/mapper/resultMap"</span>));</span><br><span class="line">    sqlElement(context.evalNodes(<span class="string">"/mapper/sql"</span>));</span><br><span class="line">    buildStatementFromContext(context.evalNodes(<span class="string">"select|insert|update|delete"</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing Mapper XML. Cause: "</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构建SqlSource-1"><a href="#构建SqlSource-1" class="headerlink" title="构建SqlSource"></a>构建SqlSource</h2><ul><li>org.apache.ibatis.builder.xml.XMLMapperBuilder.buildStatementFromContext(List<xnode>, String)</xnode></li><li>org.apache.ibatis.builder.xml.XMLStatementBuilder.parseStatementNode()</li><li>org.apache.ibatis.scripting.xmltags.XMLLanguageDriver.createSqlSource(Configuration, XNode, Class&lt;?&gt;)</li><li>org.apache.ibatis.scripting.xmltags.XMLScriptBuilder.parseScriptNode()</li><li>创建RawSqlSource</li><li>org.apache.ibatis.builder.SqlSourceBuilder.parse(String, Class&lt;?&gt;, Map&lt;String, Object&gt;)</li><li>org.apache.ibatis.parsing.GenericTokenParser.parse(String)</li></ul>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
            <tag> builder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis:主键生成</title>
      <link href="/2017/11/21/aa_category/framework/mybatis/Mybatis-%E4%B8%BB%E9%94%AE%E7%94%9F%E6%88%90/"/>
      <url>/2017/11/21/aa_category/framework/mybatis/Mybatis-%E4%B8%BB%E9%94%AE%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<p>主要分析mybatis默认的主键生成方式，以及我们怎么扩展</p><a id="more"></a><h1 id="XMLStatementBuilder"><a href="#XMLStatementBuilder" class="headerlink" title="XMLStatementBuilder"></a>XMLStatementBuilder</h1><p>通过一下分析指导MappedStatement是怎么构建KeyGenerator的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseStatementNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  KeyGenerator keyGenerator;</span><br><span class="line">    String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">    keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, <span class="keyword">true</span>);</span><br><span class="line">     <span class="comment">//根据key判断缓存中是否有对应的KeyGenerator</span></span><br><span class="line">    <span class="keyword">if</span> (configuration.hasKeyGenerator(keyStatementId)) &#123;</span><br><span class="line">      keyGenerator = configuration.getKeyGenerator(keyStatementId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果有属性useGeneratedKeys且是insert语句则使用Jdbc3KeyGenerator类</span></span><br><span class="line">      keyGenerator = context.getBooleanAttribute(<span class="string">"useGeneratedKeys"</span>,</span><br><span class="line">          configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType))</span><br><span class="line">          ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="KeyGenerator接口分析"><a href="#KeyGenerator接口分析" class="headerlink" title="KeyGenerator接口分析"></a>KeyGenerator接口分析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">KeyGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">processBefore</span><span class="params">(Executor executor, MappedStatement ms, Statement stmt, Object parameter)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">processAfter</span><span class="params">(Executor executor, MappedStatement ms, Statement stmt, Object parameter)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Mybatis自带的实现类Jdbc3KeyGenerator"><a href="#Mybatis自带的实现类Jdbc3KeyGenerator" class="headerlink" title="Mybatis自带的实现类Jdbc3KeyGenerator"></a>Mybatis自带的实现类Jdbc3KeyGenerator</h2><ul><li>是通过数据的某些特性或者自增序列实现的</li><li>对于processBefore没有处理</li></ul><h2 id="NoKeyGenerator分析"><a href="#NoKeyGenerator分析" class="headerlink" title="NoKeyGenerator分析"></a>NoKeyGenerator分析</h2><p>顾名思义，这个类不做任何处理，是空指针的一种解决方案</p><h2 id="实现自定义的KeyGenerator"><a href="#实现自定义的KeyGenerator" class="headerlink" title="实现自定义的KeyGenerator"></a>实现自定义的KeyGenerator</h2><ol><li>获取mapper对应的 MappedStatement</li><li>修改对应的 KeyGenerator属性</li></ol><h1 id="通用Mapper中对主键的扩展"><a href="#通用Mapper中对主键的扩展" class="headerlink" title="通用Mapper中对主键的扩展"></a>通用Mapper中对主键的扩展</h1><h2 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h2><h3 id="通过Java生成的方式"><a href="#通过Java生成的方式" class="headerlink" title="通过Java生成的方式　"></a>通过Java生成的方式　</h3><ul><li>@GeneratedValue(generator = “UUID”)</li><li>这种方式通过<bind> 标签实现，不能给对象设置对应的返回值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 如果generator = "UUID"，则设置uuid=true</span></span><br><span class="line"> GeneratedValue generatedValue = field.getAnnotation(GeneratedValue.class);</span><br><span class="line">            <span class="keyword">if</span> (generatedValue.generator().equals(<span class="string">"UUID"</span>)) &#123;</span><br><span class="line">                entityColumn.setUuid(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 如果列是uuid,则生成一个&lt;bind&gt;标签</span></span><br><span class="line">BaseInsertProvider.insert(MappedStatement)&#123;</span><br><span class="line"> <span class="keyword">if</span> (column.isUuid()) &#123;</span><br><span class="line">                <span class="comment">//uuid的情况，直接插入bind节点</span></span><br><span class="line">                sql.append(SqlHelper.getBindValue(column, getUUID()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></bind></li></ul><p>生成的xml,</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;bind name=<span class="string">"id_bind"</span></span><br><span class="line">value=<span class="string">'@java.util.UUID@randomUUID().toString().replace("-", "")'</span> /&gt;</span><br><span class="line">INSERT INTO blog</span><br><span class="line">&lt;trim prefix=<span class="string">"("</span> suffix=<span class="string">")"</span> suffixOverrides=<span class="string">","</span>&gt;id,name,&lt;/trim&gt;</span><br><span class="line">&lt;trim prefix=<span class="string">"VALUES("</span> suffix=<span class="string">")"</span> suffixOverrides=<span class="string">","</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="keyword">if</span> test=<span class="string">"id != null"</span>&gt;#&#123;id,javaType=java<span class="selector-class">.lang</span><span class="selector-class">.String</span>&#125;,&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">    <span class="comment">// 如果id==null,则会用id_bind的值插入数据库，但是不会给实体中返回对应的值</span></span><br><span class="line">&lt;<span class="keyword">if</span> test=<span class="string">"id == null"</span>&gt;#&#123;id_bind,javaType=java<span class="selector-class">.lang</span><span class="selector-class">.String</span>&#125;,&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;<span class="keyword">if</span> test=<span class="string">"name != null"</span>&gt;#&#123;name,javaType=java<span class="selector-class">.lang</span><span class="selector-class">.String</span>&#125;,&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;<span class="keyword">if</span> test=<span class="string">"name == null"</span>&gt;#&#123;name,javaType=java<span class="selector-class">.lang</span><span class="selector-class">.String</span>&#125;,&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;/trim&gt;</span><br></pre></td></tr></table></figure><h3 id="通过DB生成的方式"><a href="#通过DB生成的方式" class="headerlink" title="通过DB生成的方式"></a>通过DB生成的方式</h3><ul><li>@GeneratedValue(strategy = GenerationType.IDENTITY, generator = “selectreplace(uuid(), ‘-‘, ‘’)”)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (generatedValue.strategy() == GenerationType.IDENTITY) &#123;</span><br><span class="line">                    <span class="comment">//mysql的自动增长</span></span><br><span class="line">                   entityColumn.setIdentity(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!generatedValue.generator().equals(<span class="string">""</span>)) &#123;</span><br><span class="line">                        String generator = <span class="keyword">null</span>;</span><br><span class="line">                        IdentityDialect identityDialect = IdentityDialect.getDatabaseDialect(generatedValue.generator());</span><br><span class="line">                        <span class="keyword">if</span> (identityDialect != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            generator = identityDialect.getIdentityRetrievalStatement();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            generator = generatedValue.generator();</span><br><span class="line">                        &#125;</span><br><span class="line">                        entityColumn.setGenerator(generator);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">BaseInsertProvider.insert(MappedStatement)&#123;</span><br><span class="line"><span class="keyword">if</span> (column.isIdentity()) &#123;</span><br><span class="line">                newSelectKeyMappedStatement(ms, column);</span><br><span class="line">                hasIdentityKey = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//替换MappedStatement原有的keyGenerator</span></span><br><span class="line">MapperTemplate.newSelectKeyMappedStatement(MappedStatement, EntityColumn)&#123;</span><br><span class="line">   MappedStatement keyStatement = configuration.getMappedStatement(keyId, <span class="keyword">false</span>);</span><br><span class="line">            keyGenerator = <span class="keyword">new</span> tk.mybatis.mapper.mapperhelper.SelectKeyGenerator.SelectKeyGenerator(MappedStatement, <span class="keyword">boolean</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                configuration.addKeyGenerator(keyId, keyGenerator);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">//ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BaseStatementHandler.generateKeys(Object) &#123;</span><br><span class="line">    KeyGenerator keyGenerator = mappedStatement.getKeyGenerator();</span><br><span class="line">    ErrorContext.instance().store();</span><br><span class="line">    keyGenerator.processBefore(executor, mappedStatement, <span class="keyword">null</span>, parameter);</span><br><span class="line">    ErrorContext.instance().recall();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SelectKeyGenerator.processGeneratedKeys(Executor, MappedStatement, Object)&#123;</span><br><span class="line"><span class="keyword">if</span> (parameter != <span class="keyword">null</span> &amp;&amp; keyStatement != <span class="keyword">null</span> &amp;&amp; keyStatement.getKeyProperties() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    String[] keyProperties = keyStatement.getKeyProperties();</span><br><span class="line">    <span class="keyword">final</span> Configuration configuration = ms.getConfiguration();</span><br><span class="line">    <span class="keyword">final</span> MetaObject metaParam = configuration.newMetaObject(parameter);</span><br><span class="line">    <span class="keyword">if</span> (keyProperties != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Do not close keyExecutor.</span></span><br><span class="line">        <span class="comment">// The transaction will be closed by parent executor.</span></span><br><span class="line">        Executor keyExecutor = configuration.newExecutor(executor.getTransaction(), ExecutorType.SIMPLE);</span><br><span class="line">        List&lt;Object&gt; values = keyExecutor.query(keyStatement, parameter, RowBounds.DEFAULT, Executor.NO_RESULT_HANDLER);</span><br><span class="line">            MetaObject metaResult = configuration.newMetaObject(values.get(<span class="number">0</span>));</span><br><span class="line">             <span class="comment">// 给实体中对应的属性赋值</span></span><br><span class="line">   setValue(metaParam, keyProperties[<span class="number">0</span>], metaResult.getValue(keyProperties[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过Java给属性设置的方式"><a href="#通过Java给属性设置的方式" class="headerlink" title="通过Java给属性设置的方式"></a>通过Java给属性设置的方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeeMapperHelper</span> <span class="keyword">extends</span> <span class="title">MapperHelper</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConfiguration</span><span class="params">(Configuration configuration, Class&lt;?&gt; mapperInterface)</span> </span>&#123;</span><br><span class="line">String prefix;</span><br><span class="line"><span class="keyword">if</span> (mapperInterface != <span class="keyword">null</span>) &#123;</span><br><span class="line">prefix = mapperInterface.getCanonicalName();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">prefix = <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Object object : <span class="keyword">new</span> ArrayList&lt;Object&gt;(configuration.getMappedStatements())) &#123;</span><br><span class="line"><span class="keyword">if</span> (object <span class="keyword">instanceof</span> MappedStatement) &#123;</span><br><span class="line">MappedStatement ms = (MappedStatement) object;</span><br><span class="line"><span class="keyword">if</span> (ms.getId().startsWith(prefix) &amp;&amp; isMapperMethod(ms.getId())) &#123;</span><br><span class="line"><span class="keyword">if</span> (ms.getSqlSource() <span class="keyword">instanceof</span> ProviderSqlSource) &#123;</span><br><span class="line">setSqlSource(ms);</span><br><span class="line">MetaObject msObject = SystemMetaObject.forObject(ms);</span><br><span class="line"> <span class="comment">//通过反射修改KeyGenrator</span></span><br><span class="line">msObject.setValue(<span class="string">"keyGenerator"</span>, <span class="keyword">new</span> UUIDKeyGenerator());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KeyGenerator的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UUIDKeyGenerator</span> <span class="keyword">implements</span> <span class="title">KeyGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> executeBefore;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UUIDKeyGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.executeBefore = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processBefore</span><span class="params">(Executor executor, MappedStatement ms, Statement stmt, Object parameter)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (executeBefore) &#123;</span><br><span class="line">processGeneratedKeys(executor, ms, parameter);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processAfter</span><span class="params">(Executor executor, MappedStatement ms, Statement stmt, Object parameter)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!executeBefore) &#123;</span><br><span class="line">processGeneratedKeys(executor, ms, parameter);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processGeneratedKeys</span><span class="params">(Executor executor, MappedStatement ms, Object parameter)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">final</span> Configuration configuration = ms.getConfiguration();</span><br><span class="line"><span class="keyword">final</span> MetaObject metaParam = configuration.newMetaObject(parameter);</span><br><span class="line">String value = UUID.randomUUID().toString().replaceAll(<span class="string">"-"</span>, <span class="string">""</span>)+<span class="string">"lee"</span>;</span><br><span class="line">setValue(metaParam, <span class="string">"id"</span>, value);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(MetaObject metaParam, String property, Object value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (metaParam.hasSetter(property)) &#123;</span><br><span class="line"><span class="keyword">if</span> (metaParam.hasGetter(property)) &#123;</span><br><span class="line">Object defaultValue = metaParam.getValue(property);</span><br><span class="line"><span class="keyword">if</span> (defaultValue != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">metaParam.setValue(property, value);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"No setter found for the keyProperty '"</span> + property + <span class="string">"' in "</span></span><br><span class="line">+ metaParam.getOriginalObject().getClass().getName() + <span class="string">"."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MapperHelper mapperHelper = <span class="keyword">new</span> LeeMapperHelper();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
            <tag> id </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis：Others</title>
      <link href="/2017/11/16/aa_category/framework/mybatis/Mybatis-Others/"/>
      <url>/2017/11/16/aa_category/framework/mybatis/Mybatis-Others/</url>
      
        <content type="html"><![CDATA[<h1 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h1><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><a id="more"></a><h1 id="怎么根据接口生成实现类"><a href="#怎么根据接口生成实现类" class="headerlink" title="怎么根据接口生成实现类"></a>怎么根据接口生成实现类</h1><p>使用java自带的反射生成</p><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> MapperRegistry mapperRegistry = <span class="keyword">new</span> MapperRegistry(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MapperRegistry"><a href="#MapperRegistry" class="headerlink" title="MapperRegistry"></a>MapperRegistry</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperRegistry</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Configuration config;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MapperProxyFactory"><a href="#MapperProxyFactory" class="headerlink" title="MapperProxyFactory"></a>MapperProxyFactory</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxyFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;Method, MapperMethod&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="MapperProxy"><a href="#MapperProxy" class="headerlink" title="MapperProxy"></a>MapperProxy</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6424540398559729838L</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSession;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">    <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> MapperMethod <span class="title">cachedMapperMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    MapperMethod mapperMethod = methodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (mapperMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">      mapperMethod = <span class="keyword">new</span> MapperMethod(mapperInterface, method, sqlSession.getConfiguration());</span><br><span class="line">      methodCache.put(method, mapperMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mapperMethod;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MapperMethod"><a href="#MapperMethod" class="headerlink" title="MapperMethod"></a>MapperMethod</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">switch</span> (command.getType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> INSERT: &#123;</span><br><span class="line">    Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> UPDATE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> DELETE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> SELECT:</span><br><span class="line">        <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">          executeWithResultHandler(sqlSession, args);</span><br><span class="line">          result = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</span><br><span class="line">          result = executeForMany(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</span><br><span class="line">          result = executeForMap(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123;</span><br><span class="line">          result = executeForCursor(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">          result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FLUSH:</span><br><span class="line">        result = sqlSession.flushStatements();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Unknown execution method for: "</span> + command.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="怎么同时加载xml和接口"><a href="#怎么同时加载xml和接口" class="headerlink" title="怎么同时加载xml和接口"></a>怎么同时加载xml和接口</h1><h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure><h2 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Reader reader)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> build(reader, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Reader reader, String environment, Properties properties)</span> </span>&#123;</span><br><span class="line">     XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(reader, environment, properties);</span><br><span class="line">     <span class="keyword">return</span> build(parser.parse());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSessionFactory(config);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="XMLConfigBuilder"><a href="#XMLConfigBuilder" class="headerlink" title="XMLConfigBuilder"></a>XMLConfigBuilder</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">XMLConfigBuilder</span><span class="params">(InputStream inputStream, String environment, Properties props)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>(<span class="keyword">new</span> XPathParser(inputStream, <span class="keyword">true</span>, props, <span class="keyword">new</span> XMLMapperEntityResolver()), environment, props);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">XMLConfigBuilder</span><span class="params">(XPathParser parser, String environment, Properties props)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>(<span class="keyword">new</span> Configuration());</span><br><span class="line">   ErrorContext.instance().resource(<span class="string">"SQL Mapper Configuration"</span>);</span><br><span class="line">   <span class="keyword">this</span>.configuration.setVariables(props);</span><br><span class="line">   <span class="keyword">this</span>.parsed = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">this</span>.environment = environment;</span><br><span class="line">   <span class="keyword">this</span>.parser = parser;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Configuration <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (parsed) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Each XMLConfigBuilder can only be used once."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   parsed = <span class="keyword">true</span>;</span><br><span class="line">   parseConfiguration(parser.evalNode(<span class="string">"/configuration"</span>));</span><br><span class="line">   <span class="keyword">return</span> configuration;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">//issue #117 read properties first</span></span><br><span class="line">     propertiesElement(root.evalNode(<span class="string">"properties"</span>));</span><br><span class="line">     Properties settings = settingsAsProperties(root.evalNode(<span class="string">"settings"</span>));</span><br><span class="line">     loadCustomVfs(settings);</span><br><span class="line">     typeAliasesElement(root.evalNode(<span class="string">"typeAliases"</span>));</span><br><span class="line">     pluginElement(root.evalNode(<span class="string">"plugins"</span>));</span><br><span class="line">     objectFactoryElement(root.evalNode(<span class="string">"objectFactory"</span>));</span><br><span class="line">     objectWrapperFactoryElement(root.evalNode(<span class="string">"objectWrapperFactory"</span>));</span><br><span class="line">     reflectorFactoryElement(root.evalNode(<span class="string">"reflectorFactory"</span>));</span><br><span class="line">     settingsElement(settings);</span><br><span class="line">     <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">     environmentsElement(root.evalNode(<span class="string">"environments"</span>));</span><br><span class="line">     databaseIdProviderElement(root.evalNode(<span class="string">"databaseIdProvider"</span>));</span><br><span class="line">     typeHandlerElement(root.evalNode(<span class="string">"typeHandlers"</span>));</span><br><span class="line">     mapperElement(root.evalNode(<span class="string">"mappers"</span>));</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing SQL Mapper Configuration. Cause: "</span> + e, e);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="XMLMapperBuilder"><a href="#XMLMapperBuilder" class="headerlink" title="XMLMapperBuilder"></a>XMLMapperBuilder</h2><p>通过xml方式加载的时候会同时加载相关接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindMapperForNamespace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String namespace = builderAssistant.getCurrentNamespace();</span><br><span class="line">   boundType = Resources.classForName(namespace);</span><br><span class="line">    <span class="keyword">if</span> (boundType != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!configuration.hasMapper(boundType)) &#123;</span><br><span class="line">        <span class="comment">// Spring may not know the real resource name so we set a flag</span></span><br><span class="line">        <span class="comment">// to prevent loading again this resource from the mapper interface</span></span><br><span class="line">        <span class="comment">// look at MapperAnnotationBuilder#loadXmlResource</span></span><br><span class="line">        configuration.addLoadedResource(<span class="string">"namespace:"</span> + namespace);</span><br><span class="line">        configuration.addMapper(boundType);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MapperRegistry-1"><a href="#MapperRegistry-1" class="headerlink" title="MapperRegistry"></a>MapperRegistry</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (type.isInterface()) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> loadCompleted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      knownMappers.put(type, <span class="keyword">new</span> MapperProxyFactory&lt;T&gt;(type));</span><br><span class="line">      <span class="comment">// It's important that the type is added before the parser is run</span></span><br><span class="line">      <span class="comment">// otherwise the binding may automatically be attempted by the</span></span><br><span class="line">      <span class="comment">// mapper parser. If the type is already known, it won't try.</span></span><br><span class="line">      MapperAnnotationBuilder parser = <span class="keyword">new</span> MapperAnnotationBuilder(config, type);</span><br><span class="line">      parser.parse();</span><br><span class="line">      loadCompleted = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!loadCompleted) &#123;</span><br><span class="line">        knownMappers.remove(type);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过这段代码知道加载mapper的时候会加载相同包下对应的xml"><a href="#通过这段代码知道加载mapper的时候会加载相同包下对应的xml" class="headerlink" title="通过这段代码知道加载mapper的时候会加载相同包下对应的xml"></a>通过这段代码知道加载mapper的时候会加载相同包下对应的xml</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadXmlResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Spring may not know the real resource name so we check a flag</span></span><br><span class="line">  <span class="comment">// to prevent loading again a resource twice</span></span><br><span class="line">  <span class="comment">// this flag is set at XMLMapperBuilder#bindMapperForNamespace</span></span><br><span class="line">  <span class="keyword">if</span> (!configuration.isResourceLoaded(<span class="string">"namespace:"</span> + type.getName())) &#123;</span><br><span class="line">    String xmlResource = type.getName().replace(<span class="string">'.'</span>, <span class="string">'/'</span>) + <span class="string">".xml"</span>;</span><br><span class="line">    InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      inputStream = Resources.getResourceAsStream(type.getClassLoader(), xmlResource);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="comment">// ignore, resource is not required</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">      XMLMapperBuilder xmlParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, assistant.getConfiguration(), xmlResource, configuration.getSqlFragments(), type.getName());</span><br><span class="line">      xmlParser.parse();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>MapperAnnotationBuilder：Mapper  1:1<br>CacheNamespace  相当于 mapper  下面的cache<br>CacheNamespaceRef 相当于   mapper 下面的 <cache-ref namespace="'"> </cache-ref></p><p>当mybatis的xml和注解同时存在的时候首先解析xml</p><p>mybatisid生成策略</p><p>mybatis缓存</p><p>ParameterMapping  参数映射</p><p>默认的LanguageDrive是XMLLanguageDriver<br>SqlSource 是没有传入参数的sql对象<br>BoundSql  是传入参数的sql对象，是真正执行的对象<br>Build模式一般应用于设置多个属性，而工厂模式应用于以下生成</p><p>RawSqlSource 和  StaticSqlSource 差不多</p><p>1、构建sqlSource<br>主键<br>参数的解析<br>动态sql<br>缓存</p><p>foreach</p><p>executor, statementHandler,parameterHandler，resultHandler</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis:框架整理设计</title>
      <link href="/2017/11/15/aa_category/framework/mybatis/Mybatis-%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86%E8%AE%BE%E8%AE%A1/"/>
      <url>/2017/11/15/aa_category/framework/mybatis/Mybatis-%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h1><h2 id="加载配置并初始化"><a href="#加载配置并初始化" class="headerlink" title="加载配置并初始化"></a>加载配置并初始化</h2><p><strong>触发条件</strong>：加载配置文件<br>配置来源于两个地方，一处是配置文件，一处是Java代码的注解，将SQL的配置信息加载成为一个个MappedStatement对象（包括了传入参数映射配置、执行的SQL语句、结果映射配置）存储到内存中</p><h2 id="接收调用请求"><a href="#接收调用请求" class="headerlink" title="接收调用请求"></a>接收调用请求</h2><p><strong>触发条件</strong>：调用Mybatis提供的API<br><strong>传入参数</strong>：SQL的ID和传入参数对象<br><strong>处理过程</strong>：将请求传递给下层的请求处理层进行处理</p><h2 id="处理操作请求"><a href="#处理操作请求" class="headerlink" title="处理操作请求"></a>处理操作请求</h2><p>** 触发条件<strong>：API接口层传递请求过来<br>**传入参数</strong>：SQL的ID和传入参数对象<br><strong>处理过程</strong>：</p><ol><li>根据SQL的ID查找对应的MappedStatement对象</li><li>据传入参数对象解析MappedStatement对象，得到最终要执行的SQL和执行传入参数</li><li>获取数据库连接，根据得到的最终SQL语句和执行传入参数到数据库执行，并得到执行结果</li><li>根据MappedStatement对象中的结果映射配置对得到的执行结果进行转换处理，并得到最终的处理结果</li><li>释放连接资源</li></ol><h2 id="返回处理结果"><a href="#返回处理结果" class="headerlink" title="返回处理结果"></a>返回处理结果</h2><p>将最终的处理结果返回</p><a id="more"></a><p><img src="2.png" alt="2"></p><h2 id="Mybatis的几个主要部件"><a href="#Mybatis的几个主要部件" class="headerlink" title="Mybatis的几个主要部件"></a>Mybatis的几个主要部件</h2><ul><li>SqlSession：作为主要顶层API,表示和数据库交互的会话，完成必要的增删改查</li><li>Executor:Mybatis执行器，是核心的调度器，负责SQL语句的生成和查询缓存的维护</li><li>StatementHandler:封装了JDBC Statement的操作，如设置参数等</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StatementHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Statement <span class="title">prepare</span><span class="params">(Connection connection, Integer transactionTimeout)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">batch</span><span class="params">(Statement statement)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(Statement statement)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">  &lt;E&gt; <span class="function">Cursor&lt;E&gt; <span class="title">queryCursor</span><span class="params">(Statement statement)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">  <span class="function">BoundSql <span class="title">getBoundSql</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">ParameterHandler <span class="title">getParameterHandler</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ParameterHandler:负责将用户传递的参数转换成JDBC Stament所需要的参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ParameterHandler</span> </span>&#123;</span><br><span class="line">  <span class="function">Object <span class="title">getParameterObject</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ResultSetHandler:负责将JDBC返回的ResultSet结果集对象转换成List类型的集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResultSetHandler</span> </span>&#123;</span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">  &lt;E&gt; <span class="function">Cursor&lt;E&gt; <span class="title">handleCursorResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handleOutputParameters</span><span class="params">(CallableStatement cs)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>TypeHandler：负责Java数据类型和jdbc数据类型之间的映射和转换</li><li>Sqlsource:负责根据用户传递的parameterObject,动态生成SQL语句，将信息封装到BoundSql对象中</li><li>BoundSql：表示动态的SQL语句一级相应的参数信息</li><li>Configuration：维护所有的配置信息</li></ul>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis:从JDBC到Mybatis</title>
      <link href="/2017/11/14/aa_category/framework/mybatis/Mybatis-%E4%BB%8EJDBC%E5%88%B0Mybatis/"/>
      <url>/2017/11/14/aa_category/framework/mybatis/Mybatis-%E4%BB%8EJDBC%E5%88%B0Mybatis/</url>
      
        <content type="html"><![CDATA[<h1 id="JDBC实现查询分析"><a href="#JDBC实现查询分析" class="headerlink" title="JDBC实现查询分析"></a>JDBC实现查询分析</h1><ol><li>加载JDBC驱动</li><li>获取数据库连接</li><li>创建Statement对象</li><li>设置SQL语句的传入参数</li><li>执行SQL语句</li><li>处理返回结果</li><li>释放资源<a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">String url = <span class="string">"jdbc:mysql://localhost:3306/test?"</span> + <span class="string">"user=root&amp;password=&amp;useUnicode=true&amp;characterEncoding=UTF8"</span>;</span><br><span class="line">String sql;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 加载JDBC驱动</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);<span class="comment">//</span></span><br><span class="line">System.out.println(<span class="string">"成功加载MySQL驱动程序"</span>);</span><br><span class="line"><span class="comment">// 获取数据库连接</span></span><br><span class="line">conn = DriverManager.getConnection(url);</span><br><span class="line">stmt = conn.createStatement();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">sql = <span class="string">"drop table student"</span>;</span><br><span class="line">stmt.executeUpdate(sql);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">sql = <span class="string">"create table student(NO char(20),name varchar(20),primary key(NO))"</span>;</span><br><span class="line"></span><br><span class="line">stmt.executeUpdate(sql);<span class="comment">//</span></span><br><span class="line">System.out.println(<span class="string">"创建数据表成功能"</span>);</span><br><span class="line"></span><br><span class="line">sql = <span class="string">"insert into student(NO,name) values('2012001','测试1')"</span>;</span><br><span class="line">stmt.executeUpdate(sql);</span><br><span class="line"></span><br><span class="line">sql = <span class="string">"select * from student where NO= ? "</span>;</span><br><span class="line"><span class="comment">// 创建Statement对象（）</span></span><br><span class="line">PreparedStatement prepareStatement = conn.prepareStatement(sql);</span><br><span class="line"><span class="comment">// 设置传入参数</span></span><br><span class="line">prepareStatement.setString(<span class="number">1</span>, <span class="string">"2012001"</span>);</span><br><span class="line"><span class="comment">// 执行SQL语句</span></span><br><span class="line">rs = prepareStatement.executeQuery();</span><br><span class="line">System.out.println(<span class="string">"学号\t姓名"</span>);</span><br><span class="line"><span class="comment">// 处理查询结果</span></span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">System.out.println(rs.getString(<span class="number">1</span>) + <span class="string">"\t"</span> + rs.getString(<span class="number">2</span>));<span class="comment">// 入如果返回的是int类型可以用getInt()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">System.out.println(<span class="string">"MySQL操作错误"</span>);</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 关闭结果集</span></span><br><span class="line"><span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">rs.close();</span><br><span class="line">rs = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭执行</span></span><br><span class="line"><span class="keyword">if</span> (stmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">stmt.close();</span><br><span class="line">stmt = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line"><span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">conn.close();</span><br><span class="line">conn = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.43<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="JDBC演变到Mybatis过程"><a href="#JDBC演变到Mybatis过程" class="headerlink" title="JDBC演变到Mybatis过程"></a>JDBC演变到Mybatis过程</h1><h2 id="连接获取和释放"><a href="#连接获取和释放" class="headerlink" title="连接获取和释放"></a>连接获取和释放</h2><p>问题：数据库连接的频繁开启和关闭造成了资源的浪费<br>解决：通过资源池解决</p><p>问题：连接池多种多样，有可能是DBCP连接池，也有可能采用容器本身的JNDI数据库连接池<br>解决：可以通过DataSource进行隔离解耦，统一从DataSource里面获取数据库连接，DataSource具体由DBCP实现还是由容器的JNDI实现，由用户通过配置实现。</p><h2 id="SQL统一存储"><a href="#SQL统一存储" class="headerlink" title="SQL统一存储"></a>SQL统一存储</h2><p>问题：SQL语句散落在各个地方，有以下缺点</p><ul><li>可读性差</li><li>不利于取出SQL在数据库上执行<br>解决：SQL统一放置到配置文件或者数据库中</li></ul><h2 id="传入参数映射和动态SQL"><a href="#传入参数映射和动态SQL" class="headerlink" title="传入参数映射和动态SQL"></a>传入参数映射和动态SQL</h2><p>问题：查询条件是不固定的，怎么根据传入的条件的参数不同，动态生成对应的SQL呢？<br>解决：通过Freemarker或者OGNL实现</p><h2 id="结果映射和结果缓存"><a href="#结果映射和结果缓存" class="headerlink" title="结果映射和结果缓存"></a>结果映射和结果缓存</h2><p>问题：怎么把结果映射封装起来？<br>解决：返回的结果可能是不做任何处理，或者是一个JavaBean或者List或者Map。所以只要知道返回什么类型就可以找到对应的类型处理前返回对应的结果。对于同一sql多次执行进行缓存，sql+查询条件作为key,返回值作为value.</p><h2 id="解决重复SQL语句问题"><a href="#解决重复SQL语句问题" class="headerlink" title="解决重复SQL语句问题"></a>解决重复SQL语句问题</h2><p>问题：许多sql有相同的片段，如果改动的时候就要改许多地方？<br>解决:通过sql片段模块化，然后各个sql语句引用重复的模块。</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
            <tag> jdbc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis：入门</title>
      <link href="/2017/11/13/aa_category/framework/mybatis/Mybatis-%E5%85%A5%E9%97%A8/"/>
      <url>/2017/11/13/aa_category/framework/mybatis/Mybatis-%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>记录作者认为<img src="http://www.mybatis.org/mybatis-3/" alt="mybatis官网">中比较重要的片段。精简再精简</p><a id="more"></a><h1 id="XML-映射配置文件"><a href="#XML-映射配置文件" class="headerlink" title="XML 映射配置文件"></a>XML 映射配置文件</h1><h2 id="configuration"><a href="#configuration" class="headerlink" title="configuration"></a>configuration</h2><h3 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"org/mybatis/example/config.properties"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"dev_user"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"F2Fa3!33TYyg"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure><p>If a property exists in more than one of these places, MyBatis loads them in the following order:</p><ul><li>Properties specified in the body of the properties element are read first,</li><li>Properties loaded from the classpath resource or url attributes of the properties element are read second</li><li>Properties passed as a method parameter are read last.<h4 id="placeholder"><a href="#placeholder" class="headerlink" title="placeholder"></a>placeholder</h4>Since the MyBatis 3.4.2, your can specify a default value into placeholder as follow:<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"org/mybatis/example/config.properties"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"org.apache.ibatis.parsing.PropertyParser.enable-default-value"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span> <span class="comment">&lt;!-- Enable this feature --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username:ut_user&#125;"</span>/&gt;</span> <span class="comment">&lt;!-- If 'username' property not present, username become 'ut_user' --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="settings"><a href="#settings" class="headerlink" title="settings"></a>settings</h3><p>cacheEnabled<br>lazyLoadingEnabled<br>multipleResultSetsEnabled<br>useColumnLabel<br>useGeneratedKeys<br>autoMappingBehavior PARTIAL<br>autoMappingUnknownColumnBehavior NONE<br>?defaultExecutorType SIMPLE<br>defaultStatementTimeout<br>defaultFetchSize<br>?safeRowBoundsEnabled<br>safeResultHandlerEnabled<br>mapUnderscoreToCamelCase<br>localCacheScope SESSION<br>jdbcTypeForNull OTHER<br>lazyLoadTriggerMethods equals,clone,hashCode,toString<br>defaultScriptingLanguage  org.apache.ibatis.scripting.xmltags.XMLLanguageDriver<br>defaultEnumTypeHandler org.apache.ibatis.type.EnumTypeHandler<br>callSettersOnNulls<br>returnInstanceForEmptyRow<br>logPrefix<br>logImpl<br>proxyFactory JAVASSIST<br>vfsImpl<br>useActualParamName<br>configurationFactory</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"multipleResultSetsEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"useColumnLabel"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"useGeneratedKeys"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"autoMappingBehavior"</span> <span class="attr">value</span>=<span class="string">"PARTIAL"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"autoMappingUnknownColumnBehavior"</span> <span class="attr">value</span>=<span class="string">"WARNING"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"defaultExecutorType"</span> <span class="attr">value</span>=<span class="string">"SIMPLE"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"defaultStatementTimeout"</span> <span class="attr">value</span>=<span class="string">"25"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"defaultFetchSize"</span> <span class="attr">value</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"safeRowBoundsEnabled"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"mapUnderscoreToCamelCase"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"localCacheScope"</span> <span class="attr">value</span>=<span class="string">"SESSION"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"jdbcTypeForNull"</span> <span class="attr">value</span>=<span class="string">"OTHER"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadTriggerMethods"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">value</span>=<span class="string">"equals,clone,hashCode,toString"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="typeAliases"><a href="#typeAliases" class="headerlink" title="typeAliases"></a>typeAliases</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"Author"</span> <span class="attr">type</span>=<span class="string">"domain.blog.Author"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"Blog"</span> <span class="attr">type</span>=<span class="string">"domain.blog.Blog"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"domain.blog"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">@Alias("author")</span><br><span class="line">public class Author &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="typeHandlers"><a href="#typeHandlers" class="headerlink" title="typeHandlers"></a>typeHandlers</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">"org.mybatis.example.ExampleTypeHandler"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"org.mybatis.example"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="objectFactory"><a href="#objectFactory" class="headerlink" title="objectFactory"></a>objectFactory</h3><h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><p>MyBatis allows you to intercept calls to at certain points within the execution of a mapped statement. By default, MyBatis allows plug-ins to intercept method calls of:</p><ul><li>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</li><li>ParameterHandler (getParameterObject, setParameters)</li><li>ResultSetHandler (handleResultSets, handleOutputParameters)</li><li>StatementHandler (prepare, parameterize, batch, update, query)<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Intercepts(&#123;@Signature(</span><br><span class="line">  type= Executor.class,</span><br><span class="line">  method = "update",</span><br><span class="line">  args = &#123;MappedStatement.class,Object.class&#125;)&#125;)</span><br><span class="line">public class ExamplePlugin implements Interceptor &#123;</span><br><span class="line">  public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">    return invocation.proceed();</span><br><span class="line">  &#125;</span><br><span class="line">  public Object plugin(Object target) &#123;</span><br><span class="line">    return Plugin.wrap(target, this);</span><br><span class="line">  &#125;</span><br><span class="line">  public void setProperties(Properties properties) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"org.mybatis.example.ExamplePlugin"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"someProperty"</span> <span class="attr">value</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="environments"><a href="#environments" class="headerlink" title="environments"></a>environments</h3><h4 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"..."</span> <span class="attr">value</span>=<span class="string">"..."</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="transactionManager"><a href="#transactionManager" class="headerlink" title="transactionManager"></a>transactionManager</h5><p>There are two TransactionManager types (i.e. type=”[JDBC|MANAGED]”) that are included with MyBatis:</p><h5 id="dataSource"><a href="#dataSource" class="headerlink" title="dataSource"></a>dataSource</h5><p>There are three build-in dataSource types (i.e. type=”[UNPOOLED|POOLED|JNDI]”):</p><h3 id="databaseIdProvider"><a href="#databaseIdProvider" class="headerlink" title="databaseIdProvider"></a>databaseIdProvider</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">databaseIdProvider</span> <span class="attr">type</span>=<span class="string">"DB_VENDOR"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"SQL Server"</span> <span class="attr">value</span>=<span class="string">"sqlserver"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"DB2"</span> <span class="attr">value</span>=<span class="string">"db2"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"Oracle"</span> <span class="attr">value</span>=<span class="string">"oracle"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">databaseIdProvider</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="mappers"><a href="#mappers" class="headerlink" title="mappers"></a>mappers</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Using classpath relative resources --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"org/mybatis/builder/AuthorMapper.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Using mapper interface classes --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"org.mybatis.builder.AuthorMapper"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Register all interfaces in a package as mappers --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"org.mybatis.builder"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">"selectPerson"</span></span></span><br><span class="line"><span class="tag">  //<span class="attr">he</span> <span class="attr">fully</span> <span class="attr">qualified</span> <span class="attr">class</span> <span class="attr">name</span> <span class="attr">or</span> <span class="attr">alias</span> <span class="attr">for</span> <span class="attr">the</span> <span class="attr">parameter</span> <span class="attr">that</span> <span class="attr">will</span> <span class="attr">be</span> <span class="attr">passed</span> <span class="attr">into</span> <span class="attr">this</span> <span class="attr">statement.</span> <span class="attr">This</span> <span class="attr">attribute</span> <span class="attr">is</span> <span class="attr">optional</span> <span class="attr">because</span> <span class="attr">MyBatis</span> <span class="attr">can</span> <span class="attr">calculate</span> <span class="attr">the</span> <span class="attr">TypeHandler</span> <span class="attr">to</span> <span class="attr">use</span> <span class="attr">out</span> <span class="attr">of</span> <span class="attr">the</span> <span class="attr">actual</span> <span class="attr">parameter</span> <span class="attr">passed</span> <span class="attr">to</span> <span class="attr">the</span> <span class="attr">statement.</span> <span class="attr">Default</span> <span class="attr">is</span> <span class="attr">unset.</span></span></span><br><span class="line"><span class="tag">  <span class="attr">parameterType</span>=<span class="string">"int"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">resultType</span>=<span class="string">"hashmap"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">resultMap</span>=<span class="string">"personResultMap"</span></span></span><br><span class="line"><span class="tag">  // <span class="attr">Setting</span> <span class="attr">this</span> <span class="attr">to</span> <span class="attr">true</span> <span class="attr">will</span> <span class="attr">cause</span> <span class="attr">the</span> <span class="attr">local</span> <span class="attr">and</span> <span class="attr">2nd</span> <span class="attr">level</span> <span class="attr">caches</span> <span class="attr">to</span> <span class="attr">be</span> <span class="attr">flushed</span> <span class="attr">whenever</span> <span class="attr">this</span> <span class="attr">statement</span> <span class="attr">is</span> <span class="attr">called.</span> <span class="attr">Default:</span> <span class="attr">false</span> <span class="attr">for</span> <span class="attr">select</span> <span class="attr">statements.</span></span></span><br><span class="line"><span class="tag">  <span class="attr">flushCache</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">  //<span class="attr">Setting</span> <span class="attr">this</span> <span class="attr">to</span> <span class="attr">true</span> <span class="attr">will</span> <span class="attr">cause</span> <span class="attr">the</span> <span class="attr">results</span> <span class="attr">of</span> <span class="attr">this</span> <span class="attr">statement</span> <span class="attr">to</span> <span class="attr">be</span> <span class="attr">cached</span> <span class="attr">in</span> <span class="attr">2nd</span> <span class="attr">level</span> <span class="attr">cache.</span> <span class="attr">Default:</span> <span class="attr">true</span> <span class="attr">for</span> <span class="attr">select</span> <span class="attr">statements</span></span></span><br><span class="line"><span class="tag">  <span class="attr">useCache</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">timeout</span>=<span class="string">"10000"</span></span></span><br><span class="line"><span class="tag">  //<span class="attr">This</span> <span class="attr">is</span> <span class="attr">a</span> <span class="attr">driver</span> <span class="attr">hint</span> <span class="attr">that</span> <span class="attr">will</span> <span class="attr">attempt</span> <span class="attr">to</span> <span class="attr">cause</span> <span class="attr">the</span> <span class="attr">driver</span> <span class="attr">to</span> <span class="attr">return</span> <span class="attr">results</span> <span class="attr">in</span> <span class="attr">batches</span> <span class="attr">of</span> <span class="attr">rows</span> <span class="attr">numbering</span> <span class="attr">in</span> <span class="attr">size</span> <span class="attr">equal</span> <span class="attr">to</span> <span class="attr">this</span> <span class="attr">setting.</span> <span class="attr">Default</span> <span class="attr">is</span> <span class="attr">unset</span> (<span class="attr">driver</span> <span class="attr">dependent</span>)<span class="attr">.</span></span></span><br><span class="line"><span class="tag">  <span class="attr">fetchSize</span>=<span class="string">"256"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">statementType</span>=<span class="string">"PREPARED"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">resultSetType</span>=<span class="string">"FORWARD_ONLY"</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="insert-update-and-delete"><a href="#insert-update-and-delete" class="headerlink" title="insert, update and delete"></a>insert, update and delete</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">"insertAuthor"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">parameterType</span>=<span class="string">"domain.blog.Author"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">flushCache</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">statementType</span>=<span class="string">"PREPARED"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">keyProperty</span>=<span class="string">""</span></span></span><br><span class="line"><span class="tag">  <span class="attr">keyColumn</span>=<span class="string">""</span></span></span><br><span class="line"><span class="tag">  <span class="attr">useGeneratedKeys</span>=<span class="string">""</span></span></span><br><span class="line"><span class="tag">  <span class="attr">timeout</span>=<span class="string">"20"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">"updateAuthor"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">parameterType</span>=<span class="string">"domain.blog.Author"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">flushCache</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">statementType</span>=<span class="string">"PREPARED"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">timeout</span>=<span class="string">"20"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">"deleteAuthor"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">parameterType</span>=<span class="string">"domain.blog.Author"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">flushCache</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">statementType</span>=<span class="string">"PREPARED"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">timeout</span>=<span class="string">"20"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="statementType"><a href="#statementType" class="headerlink" title="statementType"></a>statementType</h3><p>Any one of STATEMENT, PREPARED or CALLABLE. This causes MyBatis to use Statement, PreparedStatement or CallableStatement respectively. Default: PREPARED.</p><h3 id="useGeneratedKeys"><a href="#useGeneratedKeys" class="headerlink" title="useGeneratedKeys"></a>useGeneratedKeys</h3><p>(insert and update only) This tells MyBatis to use the JDBC getGeneratedKeys method to retrieve keys generated internally by the database (e.g. auto increment fields in RDBMS like MySQL or SQL Server). Default: false</p><h3 id="keyProperty"><a href="#keyProperty" class="headerlink" title="keyProperty"></a>keyProperty</h3><p>(insert and update only) Identifies a property into which MyBatis will set the key value returned by getGeneratedKeys, or by a selectKey child element of the insert statement. Default: unset. Can be a comma separated list of property names if multiple generated columns are expected.</p><h3 id="keyColumn"><a href="#keyColumn" class="headerlink" title="keyColumn"></a>keyColumn</h3><p>(insert and update only) Sets the name of the column in the table with a generated key. This is only required in certain databases (like PostgreSQL) when the key column is not the first column in the table. Can be a comma separated list of columns names if multiple generated columns are expected.</p><h2 id="databaseId"><a href="#databaseId" class="headerlink" title="databaseId"></a>databaseId</h2><p>In case there is a configured databaseIdProvider, MyBatis will load all statements with no databaseId attribute or with a databaseId that matches the current one. If case the same statement if found with and without the databaseId the latter will be discarded.</p><h2 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#123;property,javaType=int,jdbcType=NUMERIC&#125;</span><br></pre></td></tr></table></figure><p><em>NOTE</em> The JDBC Type is required by JDBC for all <strong>nullable columns</strong>, if null is passed as a value. You can investigate this yourself by reading the JavaDocs for the PreparedStatement.setNull() method.</p><h3 id="customize-handling"><a href="#customize-handling" class="headerlink" title="customize handling"></a>customize handling</h3><p>To further customize type handling, you can also specify a specific TypeHandler class (or alias), for example:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#123;age,javaType=int,jdbcType=NUMERIC,typeHandler=MyTypeHandler&#125;</span><br></pre></td></tr></table></figure><h3 id="numericScale"><a href="#numericScale" class="headerlink" title="numericScale"></a>numericScale</h3><p>For numeric types there’s also a numericScale for determining how many decimal places are relevant.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#123;height,javaType=double,jdbcType=NUMERIC,numericScale=2&#125;</span><br></pre></td></tr></table></figure><h3 id="String-Substitution"><a href="#String-Substitution" class="headerlink" title="String Substitution"></a>String Substitution</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ORDER BY $&#123;columnName&#125;</span><br></pre></td></tr></table></figure><h2 id="Result-Maps"><a href="#Result-Maps" class="headerlink" title="Result Maps"></a>Result Maps</h2><h3 id="Advanced-Result-Maps"><a href="#Advanced-Result-Maps" class="headerlink" title="Advanced Result Maps"></a>Advanced Result Maps</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Very Complex Statement --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectBlogDetails"</span> <span class="attr">resultMap</span>=<span class="string">"detailedBlogResultMap"</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">       B.id as blog_id,</span><br><span class="line">       B.title as blog_title,</span><br><span class="line">       B.author_id as blog_author_id,</span><br><span class="line">       A.id as author_id,</span><br><span class="line">       A.username as author_username,</span><br><span class="line">       A.password as author_password,</span><br><span class="line">       A.email as author_email,</span><br><span class="line">       A.bio as author_bio,</span><br><span class="line">       A.favourite_section as author_favourite_section,</span><br><span class="line">       P.id as post_id,</span><br><span class="line">       P.blog_id as post_blog_id,</span><br><span class="line">       P.author_id as post_author_id,</span><br><span class="line">       P.created_on as post_created_on,</span><br><span class="line">       P.section as post_section,</span><br><span class="line">       P.subject as post_subject,</span><br><span class="line">       P.draft as draft,</span><br><span class="line">       P.body as post_body,</span><br><span class="line">       C.id as comment_id,</span><br><span class="line">       C.post_id as comment_post_id,</span><br><span class="line">       C.name as comment_name,</span><br><span class="line">       C.comment as comment_text,</span><br><span class="line">       T.id as tag_id,</span><br><span class="line">       T.name as tag_name</span><br><span class="line">  from Blog B</span><br><span class="line">       left outer join Author A on B.author_id = A.id</span><br><span class="line">       left outer join Post P on B.id = P.blog_id</span><br><span class="line">       left outer join Comment C on P.id = C.post_id</span><br><span class="line">       left outer join Post_Tag PT on PT.post_id = P.id</span><br><span class="line">       left outer join Tag T on PT.tag_id = T.id</span><br><span class="line">  where B.id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Very Complex Result Map --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"detailedBlogResultMap"</span> <span class="attr">type</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">idArg</span> <span class="attr">column</span>=<span class="string">"blog_id"</span> <span class="attr">javaType</span>=<span class="string">"int"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">constructor</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"title"</span> <span class="attr">column</span>=<span class="string">"blog_title"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"author"</span> <span class="attr">javaType</span>=<span class="string">"Author"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"author_id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"author_username"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"author_password"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"email"</span> <span class="attr">column</span>=<span class="string">"author_email"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"bio"</span> <span class="attr">column</span>=<span class="string">"author_bio"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"favouriteSection"</span> <span class="attr">column</span>=<span class="string">"author_favourite_section"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"posts"</span> <span class="attr">ofType</span>=<span class="string">"Post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"post_id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"subject"</span> <span class="attr">column</span>=<span class="string">"post_subject"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"author"</span> <span class="attr">javaType</span>=<span class="string">"Author"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"comments"</span> <span class="attr">ofType</span>=<span class="string">"Comment"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"comment_id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"tags"</span> <span class="attr">ofType</span>=<span class="string">"Tag"</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"tag_id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">"int"</span> <span class="attr">column</span>=<span class="string">"draft"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">resultType</span>=<span class="string">"DraftPost"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h3><h4 id="sub-elements"><a href="#sub-elements" class="headerlink" title="sub-elements"></a>sub-elements</h4><p>constructor、id、result、association、collection、discriminator </p><h4 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h4><p>id、type、autoMapping</p><h4 id="id-amp-result"><a href="#id-amp-result" class="headerlink" title="id &amp; result"></a>id &amp; result</h4><p>property、column、javaType、jdbcType、typeHandler</p><h3 id="association"><a href="#association" class="headerlink" title="association"></a>association</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"author"</span> <span class="attr">javaType</span>=<span class="string">"Author"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"author_id"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"author_username"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Nested-Select-for-Association"><a href="#Nested-Select-for-Association" class="headerlink" title="Nested Select for Association"></a>Nested Select for Association</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"blogResult"</span> <span class="attr">type</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"author"</span> <span class="attr">column</span>=<span class="string">"author_id"</span> <span class="attr">javaType</span>=<span class="string">"Author"</span> <span class="attr">select</span>=<span class="string">"selectAuthor"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectBlog"</span> <span class="attr">resultMap</span>=<span class="string">"blogResult"</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectAuthor"</span> <span class="attr">resultType</span>=<span class="string">"Author"</span>&gt;</span></span><br><span class="line">  SELECT * FROM AUTHOR WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>While this approach is simple, it will not perform well for large data sets or lists. This problem is known as the “N+1 Selects Problem”. In a nutshell, the N+1 selects problem is caused like this:</p><p>You execute a single SQL statement to retrieve a list of records (the “+1”).<br>For each record returned, you execute a select statement to load details for each (the “N”).</p><h5 id="column"><a href="#column" class="headerlink" title="column"></a>column</h5><p>The column name from the database, or the aliased column label that holds the value that will be passed to the nested statement as an input parameter. This is the same string that would normally be passed to resultSet.getString(columnName). Note: To deal with composite keys, you can specify multiple column names to pass to the nested select statement by using the syntax column=”{prop1=col1,prop2=col2}”. This will cause prop1 and prop2 to be set against the parameter object for the target nested select statement.</p><h5 id="select-1"><a href="#select-1" class="headerlink" title="select"></a>select</h5><p>The ID of another mapped statement that will load the complex type required by this property mapping. The values retrieved from columns specified in the column attribute will be passed to the target select statement as parameters. A detailed example follows this table. Note: To deal with composite keys, you can specify multiple column names to pass to the nested select statement by using the syntax column=”{prop1=col1,prop2=col2}”. This will cause prop1 and prop2 to be set against the parameter object for the target nested select statement.</p><h5 id="fetchType"><a href="#fetchType" class="headerlink" title="fetchType"></a>fetchType</h5><p>如果场景不是懒加载（lazy），最好不要用这种方式<br>Optional. Valid values are lazy and eager. If present, it supersedes the global configuration parameter lazyLoadingEnabled for this mapping.</p><h4 id="Nested-Results-for-Association"><a href="#Nested-Results-for-Association" class="headerlink" title="Nested Results for Association"></a>Nested Results for Association</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectBlog"</span> <span class="attr">resultMap</span>=<span class="string">"blogResult"</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    B.id            as blog_id,</span><br><span class="line">    B.title         as blog_title,</span><br><span class="line">    B.author_id     as blog_author_id,</span><br><span class="line">    A.id            as author_id,</span><br><span class="line">    A.username      as author_username,</span><br><span class="line">    A.password      as author_password,</span><br><span class="line">    A.email         as author_email,</span><br><span class="line">    A.bio           as author_bio</span><br><span class="line">  from Blog B left outer join Author A on B.author_id = A.id</span><br><span class="line">  where B.id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"blogResult"</span> <span class="attr">type</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"blog_id"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"title"</span> <span class="attr">column</span>=<span class="string">"blog_title"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"author"</span> <span class="attr">resultMap</span>=<span class="string">"authorResult"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"authorResult"</span> <span class="attr">type</span>=<span class="string">"Author"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"author_id"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"author_username"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"author_password"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"email"</span> <span class="attr">column</span>=<span class="string">"author_email"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"bio"</span> <span class="attr">column</span>=<span class="string">"author_bio"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"blogResult"</span> <span class="attr">type</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"blog_id"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"title"</span> <span class="attr">column</span>=<span class="string">"blog_title"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"author"</span> <span class="attr">javaType</span>=<span class="string">"Author"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"author_id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"author_username"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"author_password"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"email"</span> <span class="attr">column</span>=<span class="string">"author_email"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"bio"</span> <span class="attr">column</span>=<span class="string">"author_bio"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="resultMap-1"><a href="#resultMap-1" class="headerlink" title="resultMap"></a>resultMap</h5><p>This is the ID of a ResultMap that can map the nested results of this association into an appropriate object graph. </p><h5 id="columnPrefix"><a href="#columnPrefix" class="headerlink" title="columnPrefix"></a>columnPrefix</h5><p>When joining multiple tables, you would have to use column alias to avoid duplicated column names in the ResultSet.  Specifying columnPrefix allows you to map such columns to an external resultMap. Please see the example explained later in this section.</p><h5 id="notNullColumn"><a href="#notNullColumn" class="headerlink" title="notNullColumn"></a>notNullColumn</h5><p>By default a child object is created only if at least one of the columns mapped to the child’s properties is non null. </p><h5 id="autoMapping"><a href="#autoMapping" class="headerlink" title="autoMapping"></a>autoMapping</h5><p>If present, MyBatis will enable or disable automapping when mapping the result to this property.</p><h4 id="Multiple-ResultSets-for-Association"><a href="#Multiple-ResultSets-for-Association" class="headerlink" title="Multiple ResultSets for Association"></a>Multiple ResultSets for Association</h4><figure class="highlight plain"><figcaption><span>xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//getBlogsAndAuthors</span><br><span class="line">SELECT * FROM BLOG WHERE ID = #&#123;id&#125;</span><br><span class="line">SELECT * FROM AUTHOR WHERE ID = #&#123;id&#125;</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;selectBlog&quot; resultSets=&quot;blogs,authors&quot; resultMap=&quot;blogResult&quot; statementType=&quot;CALLABLE&quot;&gt;</span><br><span class="line">  &#123;call getBlogsAndAuthors(#&#123;id,jdbcType=INTEGER,mode=IN&#125;)&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;</span><br><span class="line">  &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;</span><br><span class="line">  &lt;result property=&quot;title&quot; column=&quot;title&quot;/&gt;</span><br><span class="line">  &lt;association property=&quot;author&quot; javaType=&quot;Author&quot; resultSet=&quot;authors&quot; column=&quot;author_id&quot; foreignColumn=&quot;id&quot;&gt;</span><br><span class="line">    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;</span><br><span class="line">    &lt;result property=&quot;username&quot; column=&quot;username&quot;/&gt;</span><br><span class="line">    &lt;result property=&quot;password&quot; column=&quot;password&quot;/&gt;</span><br><span class="line">    &lt;result property=&quot;email&quot; column=&quot;email&quot;/&gt;</span><br><span class="line">    &lt;result property=&quot;bio&quot; column=&quot;bio&quot;/&gt;</span><br><span class="line">  &lt;/association&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure><h5 id="column-1"><a href="#column-1" class="headerlink" title="column"></a>column</h5><p>When using multiple resultset this attribute specifies the columns (separated by commas) that will be correlated with the foreignColumn to identify the parent and the child of a relationship.</p><h5 id="foreignColumn"><a href="#foreignColumn" class="headerlink" title="foreignColumn"></a>foreignColumn</h5><p>Identifies the name of the columns that contains the foreign keys which values will be matched against the values of the columns specified in the column attibute of the parent type.</p><h5 id="resultSet"><a href="#resultSet" class="headerlink" title="resultSet"></a>resultSet</h5><p>Identifies the name of the result set where this complex type will be loaded from.</p><h3 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"posts"</span> <span class="attr">ofType</span>=<span class="string">"domain.blog.Post"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"post_id"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"subject"</span> <span class="attr">column</span>=<span class="string">"post_subject"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"body"</span> <span class="attr">column</span>=<span class="string">"post_body"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"></span><br><span class="line">private List<span class="tag">&lt;<span class="name">Post</span>&gt;</span> posts;</span><br></pre></td></tr></table></figure><h4 id="Nested-Select-for-Collection"><a href="#Nested-Select-for-Collection" class="headerlink" title="Nested Select for Collection"></a>Nested Select for Collection</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"blogResult"</span> <span class="attr">type</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"posts"</span> <span class="attr">javaType</span>=<span class="string">"ArrayList"</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">ofType</span>=<span class="string">"Post"</span> <span class="attr">select</span>=<span class="string">"selectPostsForBlog"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectBlog"</span> <span class="attr">resultMap</span>=<span class="string">"blogResult"</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectPostsForBlog"</span> <span class="attr">resultType</span>=<span class="string">"Post"</span>&gt;</span></span><br><span class="line">  SELECT * FROM POST WHERE BLOG_ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Nested-Results-for-Collection"><a href="#Nested-Results-for-Collection" class="headerlink" title="Nested Results for Collection"></a>Nested Results for Collection</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectBlog"</span> <span class="attr">resultMap</span>=<span class="string">"blogResult"</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">  B.id as blog_id,</span><br><span class="line">  B.title as blog_title,</span><br><span class="line">  B.author_id as blog_author_id,</span><br><span class="line">  P.id as post_id,</span><br><span class="line">  P.subject as post_subject,</span><br><span class="line">  P.body as post_body,</span><br><span class="line">  from Blog B</span><br><span class="line">  left outer join Post P on B.id = P.blog_id</span><br><span class="line">  where B.id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"blogResult"</span> <span class="attr">type</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"blog_id"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"title"</span> <span class="attr">column</span>=<span class="string">"blog_title"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"posts"</span> <span class="attr">ofType</span>=<span class="string">"Post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"post_id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"subject"</span> <span class="attr">column</span>=<span class="string">"post_subject"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"body"</span> <span class="attr">column</span>=<span class="string">"post_body"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Multiple-ResultSets-for-Collection"><a href="#Multiple-ResultSets-for-Collection" class="headerlink" title="Multiple ResultSets for Collection"></a>Multiple ResultSets for Collection</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//getBlogsAndPosts</span><br><span class="line">SELECT * FROM BLOG WHERE ID = #&#123;id&#125;</span><br><span class="line">SELECT * FROM POST WHERE BLOG_ID = #&#123;id&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectBlog"</span> <span class="attr">resultSets</span>=<span class="string">"blogs,posts"</span> <span class="attr">resultMap</span>=<span class="string">"blogResult"</span>&gt;</span></span><br><span class="line">  &#123;call getBlogsAndPosts(#&#123;id,jdbcType=INTEGER,mode=IN&#125;)&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"blogResult"</span> <span class="attr">type</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"title"</span> <span class="attr">column</span>=<span class="string">"title"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"posts"</span> <span class="attr">ofType</span>=<span class="string">"Post"</span> <span class="attr">resultSet</span>=<span class="string">"posts"</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">foreignColumn</span>=<span class="string">"blog_id"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"subject"</span> <span class="attr">column</span>=<span class="string">"subject"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"body"</span> <span class="attr">column</span>=<span class="string">"body"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="discriminator"><a href="#discriminator" class="headerlink" title="discriminator"></a>discriminator</h3><p>略</p><h2 id="Auto-mapping"><a href="#Auto-mapping" class="headerlink" title="Auto-mapping"></a>Auto-mapping</h2><p>Usually database columns are named using uppercase letters and underscores between words and java properties often follow the camelcase naming covention. To enable the auto-mapping between them set the setting <strong>mapUnderscoreToCamelCase</strong> to true.</p><p>Auto-mapping works even when there is an specific result map. When this happens, for each result map, all columns that are present in the ResultSet that have not a manual mapping will be auto-mapped, then manual mappings will be processed. In the following sample id and userName columns will be auto-mapped and hashed_password column will be mapped.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUsers"</span> <span class="attr">resultMap</span>=<span class="string">"userResultMap"</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    user_id             as "id",</span><br><span class="line">    user_name           as "userName",</span><br><span class="line">    hashed_password</span><br><span class="line">  from some_table</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userResultMap"</span> <span class="attr">type</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"hashed_password"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>There are three auto-mapping levels:</p><ul><li>NONE - disables auto-mapping. Only manually mapped properties will be set.</li><li>PARTIAL - will auto-map results except those that have nested result mappings defined inside (joins).</li><li>FULL - auto-maps everything.</li></ul><p>Regardless of the auto-mapping level configured you can enable or disable the automapping for an specific ResultMap by adding the attribute autoMapping to it:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userResultMap"</span> <span class="attr">type</span>=<span class="string">"User"</span> <span class="attr">autoMapping</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"hashed_password"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span></span></span><br><span class="line"><span class="tag">  <span class="attr">eviction</span>=<span class="string">"FIFO"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">flushInterval</span>=<span class="string">"60000"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">size</span>=<span class="string">"512"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">readOnly</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">...</span> <span class="attr">flushCache</span>=<span class="string">"false"</span> <span class="attr">useCache</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">...</span> <span class="attr">flushCache</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">...</span> <span class="attr">flushCache</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">...</span> <span class="attr">flushCache</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reflect</title>
      <link href="/2017/11/08/aa_category/se/reflect/reflect/"/>
      <url>/2017/11/08/aa_category/se/reflect/reflect/</url>
      
        <content type="html"><![CDATA[<ul><li>java.lang.reflect.Type：java语言中所有类型的公共父接口</li><li>java.lang.reflect.ParameterizedType 表示一种参数化的类型，比如Collection</li><li>java.lang.reflect.GenericArrayType 表示一种元素类型是参数化类型或者类型变量的数组类型</li><li>java.lang.reflectTypeVariable 是各种类型变量的公共父接口</li><li>java.lang.reflect.WildcardType 代表一种通配符类型表达式，比如?, ? extends Number, ? super Integer【wildcard是一个单词：就是“通配符”】</li></ul><a id="more"></a><h1 id="Type所有类型指代的有"><a href="#Type所有类型指代的有" class="headerlink" title="Type所有类型指代的有"></a>Type所有类型指代的有</h1><ol><li>原始类型 (raw types)【对应Class】</li><li>参数化类型 (parameterizedtypes)【对应ParameterizedType】</li><li>数组类型 (array types)【对应GenericArrayType】</li><li>类型变量 (type variables)【对应TypeVariable】</li><li>基本数据类型(primitivetypes)【仍然对应Class】</li></ol><h2 id="ParameterizedType"><a href="#ParameterizedType" class="headerlink" title="ParameterizedType"></a>ParameterizedType</h2><p>ParameterizedType represents a parameterized type such as Collection<string>.<br>【注意】无论&lt;&gt;中有几层&lt;&gt;嵌套，这个方法仅仅脱去最外层的&lt;&gt;之后剩下的内容就作为这个方法的返回值。</string></p><h2 id="GenericArrayType"><a href="#GenericArrayType" class="headerlink" title="GenericArrayType"></a>GenericArrayType</h2><h3 id="Type-getGenericComponentType"><a href="#Type-getGenericComponentType" class="headerlink" title="Type getGenericComponentType();"></a>Type getGenericComponentType();</h3><p>【注意】无论从左向右有几个[]并列，这个方法仅仅脱去最右边的[]之后剩下的内容就作为这个方法的返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">E <span class="title">methodV</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">String[] p1,</span></span></span><br><span class="line"><span class="function"><span class="params">E[] p2,</span></span></span><br><span class="line"><span class="function"><span class="params">ArrayList[] p3,</span></span></span><br><span class="line"><span class="function"><span class="params">E[][] p4)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TypeVariable"><a href="#TypeVariable" class="headerlink" title="TypeVariable"></a>TypeVariable</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Map &amp; Cloneable &amp; Serializable&gt; <span class="function">E <span class="title">methodVI</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WildcardType"><a href="#WildcardType" class="headerlink" title="WildcardType"></a>WildcardType</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodVI</span><span class="params">(List&lt;? extends String&gt; list)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reflect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis:源码分析之总体概述</title>
      <link href="/2017/10/31/aa_category/framework/mybatis/Mybatis-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%80%BB%E4%BD%93%E6%A6%82%E8%BF%B0/"/>
      <url>/2017/10/31/aa_category/framework/mybatis/Mybatis-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%80%BB%E4%BD%93%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="源码解读-mybatis3-44"><a href="#源码解读-mybatis3-44" class="headerlink" title="源码解读-mybatis3.44"></a>源码解读-mybatis3.44</h1><h2 id="org-apache-ibatis-cache"><a href="#org-apache-ibatis-cache" class="headerlink" title="org.apache.ibatis.cache"></a>org.apache.ibatis.cache</h2><h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span></span>;</span><br><span class="line"><span class="function">Object <span class="title">getObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line"><span class="function">Object <span class="title">removeObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ReadWriteLock <span class="title">getReadWriteLock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="org-apache-ibatis-cache-decorators"><a href="#org-apache-ibatis-cache-decorators" class="headerlink" title="org.apache.ibatis.cache.decorators"></a>org.apache.ibatis.cache.decorators</h3><p>装饰者模式</p><h2 id="org-apache-ibatis-builder-annotation"><a href="#org-apache-ibatis-builder-annotation" class="headerlink" title="org.apache.ibatis.builder.annotation"></a>org.apache.ibatis.builder.annotation</h2><p>注解包</p><h2 id="org-apache-ibatis-binding"><a href="#org-apache-ibatis-binding" class="headerlink" title="org.apache.ibatis.binding"></a>org.apache.ibatis.binding</h2><h2 id="org-apache-ibatis-builder"><a href="#org-apache-ibatis-builder" class="headerlink" title="org.apache.ibatis.builder"></a>org.apache.ibatis.builder</h2><h2 id="org-apache-ibatis-cursor"><a href="#org-apache-ibatis-cursor" class="headerlink" title="org.apache.ibatis.cursor"></a>org.apache.ibatis.cursor</h2><h3 id="Cursor"><a href="#Cursor" class="headerlink" title="Cursor"></a>Cursor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isConsumed</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getCurrentIndex</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="org-apache-ibatis-datasource"><a href="#org-apache-ibatis-datasource" class="headerlink" title="org.apache.ibatis.datasource"></a>org.apache.ibatis.datasource</h2><h3 id="DataSourceFactory"><a href="#DataSourceFactory" class="headerlink" title="DataSourceFactory"></a>DataSourceFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties props)</span></span>;</span><br><span class="line"> <span class="function">DataSource <span class="title">getDataSource</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="JndiDataSourceFactory"><a href="#JndiDataSourceFactory" class="headerlink" title="JndiDataSourceFactory"></a>JndiDataSourceFactory</h3><p>jndi:Java Naming and Directory Interface</p><h2 id="org-apache-ibatis-exceptions"><a href="#org-apache-ibatis-exceptions" class="headerlink" title="org.apache.ibatis.exceptions"></a>org.apache.ibatis.exceptions</h2><p>异常包</p><h2 id="org-apache-ibatis-executor"><a href="#org-apache-ibatis-executor" class="headerlink" title="org.apache.ibatis.executor"></a>org.apache.ibatis.executor</h2><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ResultHandler NO_RESULT_HANDLER = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey cacheKey, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="function">List&lt;BatchResult&gt; <span class="title">flushStatements</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="function">CacheKey <span class="title">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCached</span><span class="params">(MappedStatement ms, CacheKey key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearLocalCache</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deferLoad</span><span class="params">(MappedStatement ms, MetaObject resultObject, String property, CacheKey key, Class&lt;?&gt; targetType)</span></span>;</span><br><span class="line"><span class="function">Transaction <span class="title">getTransaction</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">boolean</span> forceRollback)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isClosed</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setExecutorWrapper</span><span class="params">(Executor executor)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="StatementHandler"><a href="#StatementHandler" class="headerlink" title="StatementHandler"></a>StatementHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Statement <span class="title">prepare</span><span class="params">(Connection connection, Integer transactionTimeout)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">batch</span><span class="params">(Statement statement)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(Statement statement)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&lt;E&gt; <span class="function">Cursor&lt;E&gt; <span class="title">queryCursor</span><span class="params">(Statement statement)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="function">BoundSql <span class="title">getBoundSql</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ParameterHandler <span class="title">getParameterHandler</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="ResultSetHandler"><a href="#ResultSetHandler" class="headerlink" title="ResultSetHandler"></a>ResultSetHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&lt;E&gt; <span class="function">Cursor&lt;E&gt; <span class="title">handleCursorResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleOutputParameters</span><span class="params">(CallableStatement cs)</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure><h3 id="ParameterHandler"><a href="#ParameterHandler" class="headerlink" title="ParameterHandler"></a>ParameterHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">getParameterObject</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure><h3 id="ProxyFactory"><a href="#ProxyFactory" class="headerlink" title="ProxyFactory"></a>ProxyFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line"> <span class="function">Object <span class="title">createProxy</span><span class="params">(Object target, ResultLoaderMap lazyLoader, Configuration configuration, ObjectFactory objectFactory, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="org-apache-ibatis-io"><a href="#org-apache-ibatis-io" class="headerlink" title="org.apache.ibatis.io"></a>org.apache.ibatis.io</h2><h3 id="ClassLoaderWrapper"><a href="#ClassLoaderWrapper" class="headerlink" title="ClassLoaderWrapper"></a>ClassLoaderWrapper</h3><p>A class to wrap access to multiple class loaders making them work as one</p><h3 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h3><p>A class to simplify access to resources through the classloader.</p><h3 id="VFS"><a href="#VFS" class="headerlink" title="VFS"></a>VFS</h3><p>Provides a very simple API for accessing resources within an application server.</p><h2 id="org-apache-ibatis-javassist"><a href="#org-apache-ibatis-javassist" class="headerlink" title="org.apache.ibatis.javassist"></a>org.apache.ibatis.javassist</h2><p>NONE<br>将编译时不存在的类动态创建并加载<br>动态生成二进制的字节码</p><h2 id="org-apache-ibatis-jdbc"><a href="#org-apache-ibatis-jdbc" class="headerlink" title="org.apache.ibatis.jdbc"></a>org.apache.ibatis.jdbc</h2><h2 id="org-apache-ibatis-lang"><a href="#org-apache-ibatis-lang" class="headerlink" title="org.apache.ibatis.lang"></a>org.apache.ibatis.lang</h2><p>表明使用哪个版本jdk的特性</p><h2 id="org-apache-ibatis-logging"><a href="#org-apache-ibatis-logging" class="headerlink" title="org.apache.ibatis.logging"></a>org.apache.ibatis.logging</h2><h2 id="org-apache-ibatis-mapping"><a href="#org-apache-ibatis-mapping" class="headerlink" title="org.apache.ibatis.mapping"></a>org.apache.ibatis.mapping</h2><h3 id="FetchType"><a href="#FetchType" class="headerlink" title="FetchType"></a>FetchType</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LAZY, EAGER, DEFAULT</span><br></pre></td></tr></table></figure><h3 id="SqlCommandType"><a href="#SqlCommandType" class="headerlink" title="SqlCommandType"></a>SqlCommandType</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNKNOWN, INSERT, UPDATE, DELETE, SELECT, FLUSH</span><br></pre></td></tr></table></figure><h3 id="ParameterMode"><a href="#ParameterMode" class="headerlink" title="ParameterMode"></a>ParameterMode</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IN, OUT, INOUT</span><br></pre></td></tr></table></figure><h3 id="StatementType"><a href="#StatementType" class="headerlink" title="StatementType"></a>StatementType</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STATEMENT, PREPARED, CALLABLE</span><br></pre></td></tr></table></figure><h3 id="ResultFlag"><a href="#ResultFlag" class="headerlink" title="ResultFlag"></a>ResultFlag</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ID, CONSTRUCTOR</span><br></pre></td></tr></table></figure><h3 id="ResultSetType"><a href="#ResultSetType" class="headerlink" title="ResultSetType"></a>ResultSetType</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FORWARD_ONLY,SCROLL_INSENSITIVE,SCROLL_SENSITIVE</span><br></pre></td></tr></table></figure><h3 id="SqlSource"><a href="#SqlSource" class="headerlink" title="SqlSource"></a>SqlSource</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="ParameterMapping"><a href="#ParameterMapping" class="headerlink" title="ParameterMapping"></a>ParameterMapping</h3><h3 id="DatabaseIdProvider-VendorDatabaseIdProvider"><a href="#DatabaseIdProvider-VendorDatabaseIdProvider" class="headerlink" title="DatabaseIdProvider  VendorDatabaseIdProvider"></a>DatabaseIdProvider  VendorDatabaseIdProvider</h3><p> Vendor DatabaseId provider</p><h2 id="org-apache-ibatis-ognl"><a href="#org-apache-ibatis-ognl" class="headerlink" title="org.apache.ibatis.ognl"></a>org.apache.ibatis.ognl</h2><p>NONE<br>ognl:Object-Graph Navigation Language</p><h2 id="org-apache-ibatis-parsing"><a href="#org-apache-ibatis-parsing" class="headerlink" title="org.apache.ibatis.parsing"></a>org.apache.ibatis.parsing</h2><h2 id="org-apache-ibatis-plugin"><a href="#org-apache-ibatis-plugin" class="headerlink" title="org.apache.ibatis.plugin"></a>org.apache.ibatis.plugin</h2><h2 id="org-apache-ibatis-reflection"><a href="#org-apache-ibatis-reflection" class="headerlink" title="org.apache.ibatis.reflection"></a>org.apache.ibatis.reflection</h2><h3 id="ParamNameResolver"><a href="#ParamNameResolver" class="headerlink" title="ParamNameResolver"></a>ParamNameResolver</h3><p>根据方法和配置获取方法的参数</p><h3 id="SystemMetaObject"><a href="#SystemMetaObject" class="headerlink" title="SystemMetaObject"></a>SystemMetaObject</h3><h3 id="TypeParameterResolver"><a href="#TypeParameterResolver" class="headerlink" title="TypeParameterResolver"></a>TypeParameterResolver</h3><p>类型解析</p><h3 id="ReflectorFactory"><a href="#ReflectorFactory" class="headerlink" title="ReflectorFactory"></a>ReflectorFactory</h3><p>通过反射生成对象的工厂</p><h3 id="MetaClass"><a href="#MetaClass" class="headerlink" title="MetaClass"></a>MetaClass</h3><p>类的原数据</p><h3 id="org-apache-ibatis-reflection-factory"><a href="#org-apache-ibatis-reflection-factory" class="headerlink" title="org.apache.ibatis.reflection.factory"></a>org.apache.ibatis.reflection.factory</h3><p>使用反射构建对象</p><h4 id="ObjectFactory"><a href="#ObjectFactory" class="headerlink" title="ObjectFactory"></a>ObjectFactory</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; type)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="org-apache-ibatis-reflection-invoker"><a href="#org-apache-ibatis-reflection-invoker" class="headerlink" title="org.apache.ibatis.reflection.invoker"></a>org.apache.ibatis.reflection.invoker</h3><p>使用反射调用方法</p><h3 id="org-apache-ibatis-reflection-property"><a href="#org-apache-ibatis-reflection-property" class="headerlink" title="org.apache.ibatis.reflection.property"></a>org.apache.ibatis.reflection.property</h3><p>使用操作属性</p><h4 id="PropertyCopier"><a href="#PropertyCopier" class="headerlink" title="PropertyCopier"></a>PropertyCopier</h4><p> 利用属性进行复制操作</p><h3 id="org-apache-ibatis-reflection-wrapper"><a href="#org-apache-ibatis-reflection-wrapper" class="headerlink" title="org.apache.ibatis.reflection.wrapper"></a>org.apache.ibatis.reflection.wrapper</h3><h4 id="ObjectWrapper"><a href="#ObjectWrapper" class="headerlink" title="ObjectWrapper"></a>ObjectWrapper</h4><p>对象的原数据</p><h2 id="org-apache-ibatis-scripting"><a href="#org-apache-ibatis-scripting" class="headerlink" title="org.apache.ibatis.scripting"></a>org.apache.ibatis.scripting</h2><h3 id="LanguageDriver"><a href="#LanguageDriver" class="headerlink" title="LanguageDriver"></a>LanguageDriver</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function">ParameterHandler <span class="title">createParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span></span>;</span><br><span class="line"><span class="function">SqlSource <span class="title">createSqlSource</span><span class="params">(Configuration configuration, XNode script, Class&lt;?&gt; parameterType)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="SqlNode"><a href="#SqlNode" class="headerlink" title="SqlNode"></a>SqlNode</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="org-apache-ibatis-session"><a href="#org-apache-ibatis-session" class="headerlink" title="org.apache.ibatis.session"></a>org.apache.ibatis.session</h2><h3 id="AutoMappingBehavior"><a href="#AutoMappingBehavior" class="headerlink" title="AutoMappingBehavior"></a>AutoMappingBehavior</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NONE,PARTIAL,FULL</span><br></pre></td></tr></table></figure><h3 id="ExecutorType"><a href="#ExecutorType" class="headerlink" title="ExecutorType"></a>ExecutorType</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SIMPLE, REUSE, BATCH</span><br></pre></td></tr></table></figure><h3 id="LocalCacheScope"><a href="#LocalCacheScope" class="headerlink" title="LocalCacheScope"></a>LocalCacheScope</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SESSION,STATEMENT</span><br></pre></td></tr></table></figure><h3 id="TransactionIsolationLevel"><a href="#TransactionIsolationLevel" class="headerlink" title="TransactionIsolationLevel"></a>TransactionIsolationLevel</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">NONE(Connection.TRANSACTION_NONE),</span><br><span class="line"><span class="comment">//读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。</span></span><br><span class="line">READ_COMMITTED(Connection.TRANSACTION_READ_COMMITTED),</span><br><span class="line"><span class="comment">// 读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。</span></span><br><span class="line">READ_UNCOMMITTED(Connection.TRANSACTION_READ_UNCOMMITTED),</span><br><span class="line"><span class="comment">//重复读，就是在开始读取数据（事务开启）时，不再允许修改操</span></span><br><span class="line">REPEATABLE_READ(Connection.TRANSACTION_REPEATABLE_READ),</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">SERIALIZABLE(Connection.TRANSACTION_SERIALIZABLE);</span><br></pre></td></tr></table></figure><h3 id="ResultContext"><a href="#ResultContext" class="headerlink" title="ResultContext"></a>ResultContext</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">getResultObject</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getResultCount</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isStopped</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="ResultHandler"><a href="#ResultHandler" class="headerlink" title="ResultHandler"></a>ResultHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleResult</span><span class="params">(ResultContext&lt;? extends T&gt; resultContext)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">T <span class="title">selectOne</span><span class="params">(String statement, Object parameter)</span></span>;</span><br><span class="line">&lt;K, V&gt; <span class="function">Map&lt;K, V&gt; <span class="title">selectMap</span><span class="params">(String statement, Object parameter, String mapKey)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(String statement)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(String statement, Object parameter)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(String statement, Object parameter)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> force)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(<span class="keyword">boolean</span> force)</span></span>;</span><br><span class="line"> <span class="function">List&lt;BatchResult&gt; <span class="title">flushStatements</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Configuration <span class="title">getConfiguration</span><span class="params">()</span></span>;</span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type)</span></span>;</span><br><span class="line"><span class="function">Connection <span class="title">getConnection</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SqlSession <span class="title">openSession</span><span class="params">(<span class="keyword">boolean</span> autoCommit)</span></span>;</span><br><span class="line"><span class="function">Configuration <span class="title">getConfiguration</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="org-apache-ibatis-transaction"><a href="#org-apache-ibatis-transaction" class="headerlink" title="org.apache.ibatis.transaction"></a>org.apache.ibatis.transaction</h2><h3 id="Transaction"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="function">Integer <span class="title">getTimeout</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure><h2 id="org-apache-ibatis-type"><a href="#org-apache-ibatis-type" class="headerlink" title="org.apache.ibatis.type"></a>org.apache.ibatis.type</h2><h3 id="TypeHandler"><a href="#TypeHandler" class="headerlink" title="TypeHandler"></a>TypeHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, T parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">getResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure><h3 id="TypeAliasRegistry"><a href="#TypeAliasRegistry" class="headerlink" title="TypeAliasRegistry"></a>TypeAliasRegistry</h3><p>和contain的概念差不多</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javadoc</title>
      <link href="/2017/10/21/aa_category/se/Javadoc/"/>
      <url>/2017/10/21/aa_category/se/Javadoc/</url>
      
        <content type="html"><![CDATA[<h1 id="link"><a href="#link" class="headerlink" title="@link"></a>@link</h1><p>引用当前类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Alias <span class="keyword">for</span> &#123;@link <span class="comment">#basePackages&#125;.</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="code"><a href="#code" class="headerlink" title="@code"></a>@code</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;@code @ComponentScan(basePackages = <span class="string">"org.my.pkg"</span>)&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javadoc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring</title>
      <link href="/2017/10/18/aa_category/framework/spring/spring/"/>
      <url>/2017/10/18/aa_category/framework/spring/spring/</url>
      
        <content type="html"><![CDATA[<p>spring 系列知识</p><h1 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h1><table><thead><tr><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center"><a href="http://spring4all.com/" target="_blank" rel="noopener">spring4all</a></td><td align="center"><a href="http://blog.didispace.com/" target="_blank" rel="noopener">翟永超</a></td><td align="center"><a href="http://www.ityouknow.com" target="_blank" rel="noopener">纯洁的微笑</a></td><td align="center"><a href="http://blog.csdn.net/liaokailin" target="_blank" rel="noopener">liaokailin的专栏</a></td><td align="center"></td></tr><tr><td align="center">## bean</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">## container</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">## Processor</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">## Factory</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">## Manager</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">## Wrapper</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">继承且持有</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">装饰模式</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">## Registry</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">## Context</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">## Resolver</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">## Listener</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">观察者模式</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">## Converter</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h2><p>适配器模式</p><a id="more"></a><h1 id="springboot"><a href="#springboot" class="headerlink" title="springboot"></a>springboot</h1><table><thead><tr><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center"><a href="http://blog.720ui.com/columns/springboot_all/" target="_blank" rel="noopener">梁桂钊</a></td><td align="center"><a href="http://blog.csdn.net/column/details/spring-boot.html" target="_blank" rel="noopener">catoop的专栏</a></td><td align="center"><a href="http://www.jianshu.com/c/f0cf6eae1754" target="_blank" rel="noopener">简书Spring Boot专题</a></td><td align="center"></td><td align="center"></td></tr></tbody></table><h1 id="springcloud"><a href="#springcloud" class="headerlink" title="springcloud"></a>springcloud</h1><table><thead><tr><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center"><a href></a></td><td align="center"><a href></a></td><td align="center"><a href></a></td><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>死磕自己</title>
      <link href="/2017/09/22/aa_category/se/%E6%AD%BB%E7%A3%95%E8%87%AA%E5%B7%B1/"/>
      <url>/2017/09/22/aa_category/se/%E6%AD%BB%E7%A3%95%E8%87%AA%E5%B7%B1/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><a id="more"></a><h1 id="SE"><a href="#SE" class="headerlink" title="SE"></a>SE</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>LinkedList，ArrayList<br>HashMap，TreeMap，ConcurrentHashMap、LinkedHashMap</p><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>thread.join 底层是调用的object的wait方法,线程结束的时候会调用notifyAll（hotspot的源码中）</p><h2 id="并发包"><a href="#并发包" class="headerlink" title="并发包"></a>并发包</h2><h2 id="NIO包"><a href="#NIO包" class="headerlink" title="NIO包"></a>NIO包</h2><h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><h2 id="CURD"><a href="#CURD" class="headerlink" title="CURD"></a>CURD</h2><h2 id="spring源码分析"><a href="#spring源码分析" class="headerlink" title="spring源码分析"></a>spring源码分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(T vo)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 子类前置处理</span></span><br><span class="line">subBeforeSave(vo);</span><br><span class="line"><span class="comment">// 父类的前置链处理</span></span><br><span class="line">beforeSave(vo);</span><br><span class="line"><span class="comment">// 子类处理</span></span><br><span class="line">subSave(vo);</span><br><span class="line"><span class="comment">// 父类的后置链处理</span></span><br><span class="line">afterSave(vo);</span><br><span class="line"><span class="comment">// 子类后置处理</span></span><br><span class="line">subAfterSave(vo);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">subBeforeSave</span><span class="params">(T vo)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 责任链</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeSave</span><span class="params">(T vo)</span> </span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 责任链</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterSave</span><span class="params">(T vo)</span> </span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">subSave</span><span class="params">(T vo)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">subAfterSave</span><span class="params">(T vo)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有代码  数据 、指令，返回地址</p><p>线程计数器</p><p>本地方法栈<br>虚拟机栈<br>局部变量表 32  ，所以long double需要占用两行<br>操作数栈，做计算运到的<br>动态连接<br>出口，正常，异常</p><p>方法去<br>堆</p><p>看源码<br>-猜想<br>-验证</p><p>重构  </p>]]></content>
      
      
      <categories>
          
          <category> 死磕 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>高效团队开发工具与方法读后感</title>
      <link href="/2017/09/07/aa_category/methodology/%E9%AB%98%E6%95%88%E5%9B%A2%E9%98%9F%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%B8%8E%E6%96%B9%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/09/07/aa_category/methodology/%E9%AB%98%E6%95%88%E5%9B%A2%E9%98%9F%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%B8%8E%E6%96%B9%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是团队开发"><a href="#1-什么是团队开发" class="headerlink" title="1.什么是团队开发"></a>1.什么是团队开发</h1><h1 id="2-团队开发中发生的问题（痛点）"><a href="#2-团队开发中发生的问题（痛点）" class="headerlink" title="2.团队开发中发生的问题（痛点）"></a>2.团队开发中发生的问题（痛点）</h1><p>重要的邮件太多，无法确定处理<br>没有能用于验证的环境<br>用别名目录管理分支<br>重新制作数据库比较困难<br>不运行系统就无法察觉问题<br>覆盖了其他组员修改的代码<br>无法自行地进行代码重构<br>不知道bug的修正日期，也不能追踪退化<br>没有灵活使用分支和标签<br>在测试环境、正式环境无法运行<br>发布太复杂，以至于需要发布手册</p><a id="more"></a><h1 id="3-版本管理"><a href="#3-版本管理" class="headerlink" title="3.版本管理"></a>3.版本管理</h1><h2 id="管理的对象"><a href="#管理的对象" class="headerlink" title="管理的对象"></a>管理的对象</h2><p>代码<br>需求资料、设计资料等文档<br>数据库模式、数据<br>配置文件</p><h2 id="使用Git顺利地推进并行开发"><a href="#使用Git顺利地推进并行开发" class="headerlink" title="使用Git顺利地推进并行开发"></a>使用Git顺利地推进并行开发</h2><p>分支的用法<br>标签的用法</p><h3 id="分支的策略"><a href="#分支的策略" class="headerlink" title="分支的策略"></a>分支的策略</h3><p>git-flow<br>github-flow</p><h2 id="数据库模式和数据的管理"><a href="#数据库模式和数据的管理" class="headerlink" title="数据库模式和数据的管理"></a>数据库模式和数据的管理</h2><h3 id="版本管理的必要条件"><a href="#版本管理的必要条件" class="headerlink" title="版本管理的必要条件"></a>版本管理的必要条件</h3><p>无论什么环境都能用相同的步骤<br>能够反复执行多次<br>文本文件</p><h2 id="数据库迁移的功能"><a href="#数据库迁移的功能" class="headerlink" title="数据库迁移的功能"></a>数据库迁移的功能</h2><p>管理SQL执行顺序和需要执行哪些SQL<br>管理模式定义编辑的冲突<br>提供回滚的机制<br>支持数据的加载</p><h2 id="数据迁移工具"><a href="#数据迁移工具" class="headerlink" title="数据迁移工具"></a>数据迁移工具</h2><p>Migration(Ruby on Rails)<br>south(Django)<br>Migration Plugin(CakePHP)<br>Evolution(Play Framework)</p><h3 id="java调用的数据迁移工具"><a href="#java调用的数据迁移工具" class="headerlink" title="java调用的数据迁移工具"></a>java调用的数据迁移工具</h3><p>Flyway<br>Liquibase<br>dbdeploy</p><h1 id="4-缺陷管理"><a href="#4-缺陷管理" class="headerlink" title="4.缺陷管理"></a>4.缺陷管理</h1><p>回答“那个bug是什么时候修正的”的问题　　<br>回答“为什么要这样修改”的问题</p><h2 id="OSS产品"><a href="#OSS产品" class="headerlink" title="OSS产品"></a>OSS产品</h2><p>Trac<br>Redmine<br>Bugzilla<br>Mantis</p><h2 id="商用产品"><a href="#商用产品" class="headerlink" title="商用产品"></a>商用产品</h2><p>JIRA<br>YouTRACK<br>Pivotal Tracker<br>Backlog<br>GitHub</p><h2 id="缺陷管理系统与版本管理系统的关联"><a href="#缺陷管理系统与版本管理系统的关联" class="headerlink" title="缺陷管理系统与版本管理系统的关联"></a>缺陷管理系统与版本管理系统的关联</h2><p>从提交链接到问题票<br>从问题票到链接</p><h1 id="5-CI-持续集成"><a href="#5-CI-持续集成" class="headerlink" title="5.CI(持续集成)"></a>5.CI(持续集成)</h1><h2 id="jenkins"><a href="#jenkins" class="headerlink" title="jenkins"></a>jenkins</h2><h3 id="能干什么"><a href="#能干什么" class="headerlink" title="能干什么"></a>能干什么</h3><p>checkout代码<br>自动build并执行测试<br>统计结果并制作报表<br>通知</p><h3 id="统计覆盖率"><a href="#统计覆盖率" class="headerlink" title="统计覆盖率"></a>统计覆盖率</h3><h4 id="覆盖率统计工具"><a href="#覆盖率统计工具" class="headerlink" title="覆盖率统计工具"></a>覆盖率统计工具</h4><p>Cobertura<br>Jacoco<br>Scct<br>SimpleCov<br>Rcov</p><h4 id="Jenkins插件的配置"><a href="#Jenkins插件的配置" class="headerlink" title="Jenkins插件的配置"></a>Jenkins插件的配置</h4><p>配置插件 Publish Cobertura coverage Report</p><h3 id="Jenkins中静态分析"><a href="#Jenkins中静态分析" class="headerlink" title="Jenkins中静态分析"></a>Jenkins中静态分析</h3><p>CheckStyle<br>PMD<br>FindBugs</p><h1 id="6-部署的自动化-持续交付"><a href="#6-部署的自动化-持续交付" class="headerlink" title="6.部署的自动化(持续交付)"></a>6.部署的自动化(持续交付)</h1><h2 id="引导（Bootstrapping）"><a href="#引导（Bootstrapping）" class="headerlink" title="引导（Bootstrapping）"></a>引导（Bootstrapping）</h2><h3 id="Kickstart"><a href="#Kickstart" class="headerlink" title="Kickstart"></a>Kickstart</h3><p>Kickstart是一种无人职守安装方式。KickStart的工作原理是通过记录典型的安装过程中所需人工干预填写的各种参数，并生成一个名为ks.cfg的文件</p><h3 id="Vagrant"><a href="#Vagrant" class="headerlink" title="Vagrant"></a>Vagrant</h3><p>Vagrant是一个基于Ruby的工具，用于创建和部署虚拟化开发环境。它 使用Oracle的开源VirtualBox虚拟化系统，使用 Chef创建自动化虚拟环境</p><h2 id="自动化配置工具"><a href="#自动化配置工具" class="headerlink" title="自动化配置工具"></a>自动化配置工具</h2><h3 id="chef"><a href="#chef" class="headerlink" title="chef"></a>chef</h3><p>只要准备好名为Cookbooks的服务器构建手册的配置文件，就能按照文件所记述的规则为服务其安装软件包并配置中间件</p><h3 id="serverspec"><a href="#serverspec" class="headerlink" title="serverspec"></a>serverspec</h3><p>对服务器的构成进行单元测试的测试框架</p><h1 id="7-回归测试"><a href="#7-回归测试" class="headerlink" title="7.回归测试"></a>7.回归测试</h1><p>以检查退化为目的的测试为回归测试<br>自动化测试工具：Fit、Selenium、Cucumber、Watir、Canoo WebTest</p><h2 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h2><p>关联Jenkins和Selenium</p><p>利用Jenkins的分布式构建实现测试的并行执行</p><h2 id="Selenium的组件"><a href="#Selenium的组件" class="headerlink" title="Selenium的组件"></a>Selenium的组件</h2><p>Selenium IDE<br>Selenium Remote Control（Selenium RC<br>Selenium WebDriver</p><h2 id="JMeter"><a href="#JMeter" class="headerlink" title="JMeter"></a>JMeter</h2>]]></content>
      
      
      <categories>
          
          <category> 方法论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring概述</title>
      <link href="/2017/07/12/aa_category/framework/spring/spring%E6%A6%82%E8%BF%B0/"/>
      <url>/2017/07/12/aa_category/framework/spring/spring%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h1><p>spring依赖的日志框架为commons-logging</p><p>commons-logging在启动的时候检查类路径下有没有对应的日志框架，如果有则用，如果没有直接用jdk自带的日志</p><h1 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h1><h1 id="Circular-dependencies"><a href="#Circular-dependencies" class="headerlink" title="Circular dependencies"></a>Circular dependencies</h1><ul><li>For example: Class A requires an instance of class B through constructor injection, and class B requires an instance of class A through constructor injection. If you configure beans for classes A and B to be injected into each other, the Spring IoC container detects this circular reference at runtime, and throws a BeanCurrentlyInCreationException </li><li>解决循环依赖的最好办法是通过属性注入，不用通过构造器注入</li></ul><h1 id="单例对象引用非单例对象"><a href="#单例对象引用非单例对象" class="headerlink" title="单例对象引用非单例对象"></a>单例对象引用非单例对象</h1><h1 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h1><h2 id="The-prototype-scope"><a href="#The-prototype-scope" class="headerlink" title="The prototype scope"></a>The prototype scope</h2><p>spring不负责完整的生命周期，只负责创建的回调函数，不负责销毁的回调函数To get the Spring container to release resources held by prototype-scoped beans, try using a custom bean post-processor, which holds a reference to beans that need to be cleaned up.<br>这个作用域设计的目的就是替换new,没有其他的功能</p><h2 id="Request-scope"><a href="#Request-scope" class="headerlink" title="Request scope"></a>Request scope</h2><p>基本和prototype一样，除了spring负责清理创建的对象</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot</title>
      <link href="/2017/07/12/aa_category/framework/spring/springboot/"/>
      <url>/2017/07/12/aa_category/framework/spring/springboot/</url>
      
        <content type="html"><![CDATA[<h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ContentNegotiatingViewResolver</span><br></pre></td></tr></table></figure><p>spring.mvc.message-codes-resolver.format=PREFIX_ERROR_CODE<br>spring.mvc.static-path-pattern=/resources/**</p><h2 id="Mustache"><a href="#Mustache" class="headerlink" title="Mustache"></a>Mustache</h2><h1 id="spring-boot-maven-plugin"><a href="#spring-boot-maven-plugin" class="headerlink" title="spring-boot-maven-plugin"></a>spring-boot-maven-plugin</h1><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/build-tool-plugins-maven-plugin.html" target="_blank" rel="noopener">相关连接</a></p><h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span>(classes = Application.class)</span><br></pre></td></tr></table></figure><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">BackgroundPreinitializer</span><br><span class="line">BasicErrorController</span><br><span class="line">SpringFactoriesLoader</span><br><span class="line"></span><br><span class="line">ConfigurableWebApplicationContext</span><br><span class="line">ApplicationContextInitializer</span><br><span class="line">ApplicationListener</span><br><span class="line"></span><br><span class="line">EventPublishingRunListener</span><br><span class="line"></span><br><span class="line">SpringBootBanner</span><br><span class="line"></span><br><span class="line">ApplicationContextAware</span><br><span class="line"></span><br><span class="line">AnnotationConfigEmbeddedWebApplicationContext</span><br></pre></td></tr></table></figure><h2 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">YamlPropertiesFactoryBean </span><br><span class="line">YamlMapFactoryBean </span><br><span class="line">YamlPropertySourceLoader</span><br></pre></td></tr></table></figure><h3 id="YAML-shortcomings"><a href="#YAML-shortcomings" class="headerlink" title="YAML shortcomings"></a>YAML shortcomings</h3><p>YAML files can’t be loaded via the @PropertySource annotation. So in the case that you need to load values that way, you need to use a properties file.</p><p>springApplication可以读取不同种类的源文件：</p><p>类- java类由AnnotatedBeanDefinitionReader加载。<br>Resource - xml资源文件由XmlBeanDefinitionReader读取, 或者groovy脚本由GroovyBeanDefinitionReader读取<br>Package - java包文件由ClassPathBeanDefinitionScanner扫描读取。<br>CharSequence - 字符序列可以是类名、资源文件、包名，根据不同方式加载。如果一个字符序列不可以解析程序到类，也不可以解析到资源文件，那么就认为它是一个包。</p><p>listener最终会被初始化为ParentContextCloserApplicationListener，FileEncodingApplicationListener，AnsiOutputApplicationListener，ConfigFileApplicationListener，DelegatingApplicationListener，LiquibaseServiceLocatorApplicationListener，ClasspathLoggingApplicationListener，LoggingApplicationListener这几个类的对象组成的list。</p><h2 id="ConfigFileApplicationListener"><a href="#ConfigFileApplicationListener" class="headerlink" title="ConfigFileApplicationListener"></a>ConfigFileApplicationListener</h2><p>‘spring.config.name’<br>‘spring.config.location’ </p><p><img src="1.png" alt></p><p>例如，使用java -jar运行应用时，你可以通过如下命令启用debug属性：</p><p>$ java -jar myproject-0.0.1-SNAPSHOT.jar –debug</p><h1 id="配置优先级顺序"><a href="#配置优先级顺序" class="headerlink" title="配置优先级顺序"></a>配置优先级顺序</h1><ol><li>Devtools global settings properties on your home directory (~/.spring-boot-1. 1. devtools.properties when devtools is active).</li><li>@TestPropertySource annotations on your tests.</li><li>@SpringBootTest#properties annotation attribute on your tests.</li><li>Command line arguments.</li><li>Properties from SPRING_APPLICATION_JSON (inline JSON embedded in an environment variable or system property)</li><li>ServletConfig init parameters.</li><li>ServletContext init parameters.</li><li>JNDI attributes from java:comp/env.</li><li>Java System properties (System.getProperties()).</li><li>OS environment variables.</li><li>A RandomValuePropertySource that only has properties in random.*.</li><li>Profile-specific application properties outside of your packaged jar (application-{profile}.properties and YAML variants)</li><li>Profile-specific application properties packaged inside your jar (application-{profile}.properties and YAML variants)</li><li>Application properties outside of your packaged jar (application.properties and YAML variants).</li><li>Application properties packaged inside your jar (application.properties and YAML variants).</li><li>@PropertySource annotations on your @Configuration classes.</li><li>Default properties (specified using SpringApplication.setDefaultProperties).</li></ol><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>属性文件是最常见的管理配置属性的方式。Spring Boot 提供的 SpringApplication 类会搜索并加载 application.properties 文件来获取配置属性值。SpringApplication 类会在下面位置搜索该文件。</p><p>当前目录的“/config”子目录。<br>当前目录。<br>classpath 中的“/config”包。<br>classpath</p><h1 id="actuator"><a href="#actuator" class="headerlink" title="actuator"></a>actuator</h1><p><a href="http://localhost:8881/health" target="_blank" rel="noopener">http://localhost:8881/health</a><br><a href="http://localhost:8881/autoconfig" target="_blank" rel="noopener">http://localhost:8881/autoconfig</a><br><a href="http://localhost:8881/beans" target="_blank" rel="noopener">http://localhost:8881/beans</a><br><a href="http://localhost:8881/configprops" target="_blank" rel="noopener">http://localhost:8881/configprops</a><br><a href="http://localhost:8881/mappings" target="_blank" rel="noopener">http://localhost:8881/mappings</a><br><a href="http://localhost:8881/metrics" target="_blank" rel="noopener">http://localhost:8881/metrics</a><br><a href="http://localhost:8881/dump" target="_blank" rel="noopener">http://localhost:8881/dump</a><br><a href="http://localhost:8881/trace" target="_blank" rel="noopener">http://localhost:8881/trace</a></p><a id="more"></a><h2 id="Spring-Boot应用启动器"><a href="#Spring-Boot应用启动器" class="headerlink" title="Spring Boot应用启动器"></a>Spring Boot应用启动器</h2><p>1）spring-boot-starter<br>这是Spring Boot的核心启动器，包含了自动配置、日志和YAML。</p><p>2）spring-boot-starter-actuator<br>帮助监控和管理应用。</p><p>3）spring-boot-starter-amqp<br>通过spring-rabbit来支持AMQP协议（Advanced Message Queuing Protocol）。</p><p>4）spring-boot-starter-aop<br>支持面向方面的编程即AOP，包括spring-aop和AspectJ。</p><p>5）spring-boot-starter-artemis<br>通过Apache Artemis支持JMS的API（Java Message Service API）。</p><p>6）spring-boot-starter-batch<br>支持Spring Batch，包括HSQLDB数据库。</p><p>7）spring-boot-starter-cache<br>支持Spring的Cache抽象。</p><p>8）spring-boot-starter-cloud-connectors<br>支持Spring Cloud Connectors，简化了在像Cloud Foundry或Heroku这样的云平台上连接服务。</p><p>9）spring-boot-starter-data-elasticsearch<br>支持ElasticSearch搜索和分析引擎，包括spring-data-elasticsearch。</p><p>10）spring-boot-starter-data-gemfire<br>支持GemFire分布式数据存储，包括spring-data-gemfire。</p><p>11）spring-boot-starter-data-jpa<br>支持JPA（Java Persistence API），包括spring-data-jpa、spring-orm、Hibernate。</p><p>12）spring-boot-starter-data-mongodb<br>支持MongoDB数据，包括spring-data-mongodb。</p><p>13）spring-boot-starter-data-rest<br>通过spring-data-rest-webmvc，支持通过REST暴露Spring Data数据仓库。</p><p>14）spring-boot-starter-data-solr<br>支持Apache Solr搜索平台，包括spring-data-solr。</p><p>15）spring-boot-starter-freemarker<br>支持FreeMarker模板引擎。</p><p>16）spring-boot-starter-groovy-templates<br>支持Groovy模板引擎。</p><p>17）spring-boot-starter-hateoas<br>通过spring-hateoas支持基于HATEOAS的RESTful Web服务。</p><p>18）spring-boot-starter-hornetq<br>通过HornetQ支持JMS。</p><p>19）spring-boot-starter-integration<br>支持通用的spring-integration模块。</p><p>20）spring-boot-starter-jdbc<br>支持JDBC数据库。</p><p>21）spring-boot-starter-jersey<br>支持Jersey RESTful Web服务框架。</p><p>22）spring-boot-starter-jta-atomikos<br>通过Atomikos支持JTA分布式事务处理。</p><p>23）spring-boot-starter-jta-bitronix<br>通过Bitronix支持JTA分布式事务处理。</p><p>24）spring-boot-starter-mail<br>支持javax.mail模块。</p><p>25）spring-boot-starter-mobile<br>支持spring-mobile。</p><p>26）spring-boot-starter-mustache<br>支持Mustache模板引擎。</p><p>27）spring-boot-starter-redis<br>支持Redis键值存储数据库，包括spring-redis。</p><p>28）spring-boot-starter-security<br>支持spring-security。</p><p>29）spring-boot-starter-social-facebook<br>支持spring-social-facebook</p><p>30）spring-boot-starter-social-linkedin<br>支持pring-social-linkedin</p><p>31）spring-boot-starter-social-twitter<br>支持pring-social-twitter</p><p>32）spring-boot-starter-test<br>支持常规的测试依赖，包括JUnit、Hamcrest、Mockito以及spring-test模块。</p><p>33）spring-boot-starter-thymeleaf<br>支持Thymeleaf模板引擎，包括与Spring的集成。</p><p>34）spring-boot-starter-velocity<br>支持Velocity模板引擎。</p><p>35）spring-boot-starter-web<br>S支持全栈式Web开发，包括Tomcat和spring-webmvc。</p><p>36）spring-boot-starter-websocket<br>支持WebSocket开发。</p><p>37）spring-boot-starter-ws<br>支持Spring Web Services。</p><p>Spring Boot应用启动器面向生产环境的还有2种，具体如下：</p><p>1）spring-boot-starter-actuator<br>增加了面向产品上线相关的功能，比如测量和监控。</p><p>2）spring-boot-starter-remote-shell<br>增加了远程ssh shell的支持。</p><p>最后，Spring Boot应用启动器还有一些替换技术的启动器，具体如下：</p><p>1）spring-boot-starter-jetty<br>引入了Jetty HTTP引擎（用于替换Tomcat）。</p><p>2）spring-boot-starter-log4j<br>支持Log4J日志框架。</p><p>3）spring-boot-starter-logging<br>引入了Spring Boot默认的日志框架Logback。</p><p>4）spring-boot-starter-tomcat<br>引入了Spring Boot默认的HTTP引擎Tomcat。</p><p>5）spring-boot-starter-undertow<br>引入了Undertow HTTP引擎（用于替换Tomcat）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="WebMvcConfigurerAdapter"><a href="#WebMvcConfigurerAdapter" class="headerlink" title="WebMvcConfigurerAdapter"></a>WebMvcConfigurerAdapter</h2><p>spring mvc 配置</p><h3 id="redis配置"><a href="#redis配置" class="headerlink" title="redis配置"></a>redis配置</h3><p>Redis数据库索引（默认为0）<br>spring.redis.database=0<br>Redis服务器地址<br>spring.redis.host=localhost<br>Redis服务器连接端口<br>spring.redis.port=6379<br>Redis服务器连接密码（默认为空）<br>spring.redis.password=<br>连接池最大连接数（使用负值表示没有限制）<br>spring.redis.pool.max-active=8<br>连接池最大阻塞等待时间（使用负值表示没有限制）<br>spring.redis.pool.max-wait=-1<br>连接池中的最大空闲连接<br>spring.redis.pool.max-idle=8<br>连接池中的最小空闲连接<br>spring.redis.pool.min-idle=0<br>连接超时时间（毫秒）<br>spring.redis.timeout=0</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven</title>
      <link href="/2017/07/12/aa_category/framework/netty/maven/"/>
      <url>/2017/07/12/aa_category/framework/netty/maven/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>groupId、artifactId、version、packaging</p><h2 id="Maven-仓库"><a href="#Maven-仓库" class="headerlink" title="Maven - 仓库"></a>Maven - 仓库</h2><p>在 Maven 的术语中，仓库是一个位置（place），例如目录，可以存储所有的工程 jar 文件、library jar 文件、插件或任何其他的工程指定的文件。<br>Maven 仓库有三种类型：<br>本地（local）<br>中央（central）<br>远程（remote）</p><h3 id="Maven-依赖搜索顺序"><a href="#Maven-依赖搜索顺序" class="headerlink" title="Maven 依赖搜索顺序"></a>Maven 依赖搜索顺序</h3><p>当我们执行 Maven 构建命令时，Maven 开始按照以下顺序查找依赖的库：<br>步骤 1 － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。<br>步骤 2 － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中已被将来引用。<br>步骤 3 － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。<br>步骤 4 － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库已备将来引用，否则 Maven 将停止处理并抛出错误（无法找到依赖的文件）。</p><h2 id="Maven-插件"><a href="#Maven-插件" class="headerlink" title="Maven - 插件"></a>Maven - 插件</h2><p>Maven 实际上是一个依赖插件执行的框架，每个任务实际上是由插件完成</p><h2 id="外部依赖"><a href="#外部依赖" class="headerlink" title="外部依赖"></a>外部依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ldapjdk<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ldapjdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;basedir&#125;\src\lib\ldapjdk.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="常用Maven插件"><a href="#常用Maven插件" class="headerlink" title="常用Maven插件"></a>常用Maven插件</h2><h3 id="maven-antrun-plugin"><a href="#maven-antrun-plugin" class="headerlink" title="maven-antrun-plugin"></a>maven-antrun-plugin</h3><p><a href="http://maven.apache.org/plugins/maven-antrun-plugin/" target="_blank" rel="noopener">http://maven.apache.org/plugins/maven-antrun-plugin/</a><br>maven-antrun-plugin能让用户在Maven项目中运行Ant任务。用户可以直接在该插件的配置以Ant的方式编写Target， 然后交给该插件的run目标去执行。在一些由Ant往Maven迁移的项目中，该插件尤其有用。此外当你发现需要编写一些自定义程度很高的任务，同时又觉 得Maven不够灵活时，也可以以Ant的方式实现之。maven-antrun-plugin的run目标通常与生命周期绑定运行</p><h3 id="maven-archetype-plugin"><a href="#maven-archetype-plugin" class="headerlink" title="maven-archetype-plugin"></a>maven-archetype-plugin</h3><p><a href="http://maven.apache.org/archetype/maven-archetype-plugin/" target="_blank" rel="noopener">http://maven.apache.org/archetype/maven-archetype-plugin/</a><br>Archtype指项目的骨架，Maven初学者最开始执行的Maven命令可能就是mvn archetype:generate，这实际上就是让maven-archetype-plugin生成一个很简单的项目骨架，帮助开发者快速上手。可能也有人看到一些文档写了mvn archetype:create， 但实际上create目标已经被弃用了，取而代之的是generate目标，该目标使用交互式的方式提示用户输入必要的信息以创建项目，体验更好。 maven-archetype-plugin还有一些其他目标帮助用户自己定义项目原型，例如你由一个产品需要交付给很多客户进行二次开发，你就可以为 他们提供一个Archtype，帮助他们快速上手。</p><h3 id="maven-assembly-plugin"><a href="#maven-assembly-plugin" class="headerlink" title="maven-assembly-plugin"></a>maven-assembly-plugin</h3><p><a href="http://maven.apache.org/plugins/maven-assembly-plugin/" target="_blank" rel="noopener">http://maven.apache.org/plugins/maven-assembly-plugin/</a><br>maven-assembly-plugin的用途是制作项目分发包，该分发包可能包含了项目的可执行文件、源代码、readme、平台脚本等等。 maven-assembly-plugin支持各种主流的格式如zip、tar.gz、jar和war等，具体打包哪些文件是高度可控的，例如用户可以 按文件级别的粒度、文件集级别的粒度、模块级别的粒度、以及依赖级别的粒度控制打包，此外，包含和排除配置也是支持的。maven-assembly- plugin要求用户使用一个名为assembly.xml的元数据文件来表述打包，它的single目标可以直接在命令行调用，也可以被绑定至生命周期。</p><h3 id="maven-dependency-plugin"><a href="#maven-dependency-plugin" class="headerlink" title="maven-dependency-plugin"></a>maven-dependency-plugin</h3><p><a href="http://maven.apache.org/plugins/maven-dependency-plugin/" target="_blank" rel="noopener">http://maven.apache.org/plugins/maven-dependency-plugin/</a><br>maven-dependency-plugin最大的用途是帮助分析项目依赖，dependency:list能够列出项目最终解析到的依赖列表，dependency:tree能进一步的描绘项目依赖树，dependency:analyze可以告诉你项目依赖潜在的问题，如果你有直接使用到的却未声明的依赖，该目标就会发出警告。maven-dependency-plugin还有很多目标帮助你操作依赖文件，例如dependency:copy-dependencies能将项目依赖从本地Maven仓库复制到某个特定的文件夹下面。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>properties  </p>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud</title>
      <link href="/2017/07/09/aa_category/framework/spring/springcloud/"/>
      <url>/2017/07/09/aa_category/framework/spring/springcloud/</url>
      
        <content type="html"><![CDATA[<h2 id="Srping-Cloud-Eureka"><a href="#Srping-Cloud-Eureka" class="headerlink" title="Srping Cloud Eureka"></a>Srping Cloud Eureka</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>@EnableEurekaServer<br>eureka.client.register-with-eureka=false<br>eureka.client.fetch-registry=false</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EurekaServerConfigBean</span><br><span class="line">com.netflix.appinfo.InstanceInfo</span><br></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>@EnableDiscoveryClient<br>eureka.client.serviceUrl.defaultZone=<a href="http://localhost:1111/eureka/" target="_blank" rel="noopener">http://localhost:1111/eureka/</a></p><h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><p>@EnableHystrix</p><h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><p>@EnableFeignClients</p><h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LoadBalancerAutoConfiguration 实现客户端负载均衡器的自动化配置类</span><br><span class="line">ILoadBalancer  客户端负载均衡需要的一系列抽象操作</span><br><span class="line">AbstractLoadBalancer</span><br><span class="line">RibbonClientConfiguration</span><br><span class="line">ZoneAwareLoadBalancer</span><br><span class="line"><span class="meta">@EurekaRibbonClientConfiguration</span></span><br><span class="line">DomainExtractingServerList</span><br></pre></td></tr></table></figure><h1 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="meta">@Order</span></span><br><span class="line"><span class="meta">@Import</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:/eureka/server.properties"</span>)</span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"eureka.dashboard"</span>)</span><br><span class="line"><span class="meta">@ConditionalOnBean</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line">LoadBalancerInterceptor-&gt;RibbonLoadBalancerClient</span><br><span class="line">InterceptingClientHttpRequest</span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="meta">@SpringCloudApplication</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@Order</span></span><br></pre></td></tr></table></figure><h2 id="SpringClientFactory"><a href="#SpringClientFactory" class="headerlink" title="SpringClientFactory"></a>SpringClientFactory</h2><p>A factory that creates client, load balancer and client configuration instances. It creates a Spring ApplicationContext per client name, and extracts the beans that it needs from there.</p><h2 id="RibbonLoadBalancerContext-extends-LoadBalancerContext"><a href="#RibbonLoadBalancerContext-extends-LoadBalancerContext" class="headerlink" title="RibbonLoadBalancerContext extends LoadBalancerContext"></a>RibbonLoadBalancerContext extends LoadBalancerContext</h2><p>存储一些被负载均衡使用的内容和API</p><p>Region Zone </p><p>Jersery</p><p>XStream</p><p>spring-cloud-archaius</p><p>RabbitProperties</p><h1 id="gateway"><a href="#gateway" class="headerlink" title="gateway"></a>gateway</h1><p>routes</p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>构建模式 Builder</p><h1 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ZuulConfiguration</span><br><span class="line">ZuulFilterInitializer</span><br><span class="line"></span><br><span class="line">SendErrorFilter</span><br><span class="line">ZuulServlet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"> <span class="keyword">private</span> Map&lt;String, ZuulFilter&gt; filters;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ZuulFilter</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The name of the Archaius property to disable this filter. by default it is zuul.[classname].[filtertype].disable</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">disablePropertyName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"zuul."</span> + <span class="keyword">this</span>.getClass().getSimpleName() + <span class="string">"."</span> + filterType() + <span class="string">".disable"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="核心过滤器"><a href="#核心过滤器" class="headerlink" title="核心过滤器"></a>核心过滤器</h2><p>spring-cloud-netflix-core</p><p>docker-maven-plugin</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乱码总结</title>
      <link href="/2017/05/30/aa_category/se/%E4%B9%B1%E7%A0%81%E6%80%BB%E7%BB%93/"/>
      <url>/2017/05/30/aa_category/se/%E4%B9%B1%E7%A0%81%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 类描述：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 作者：LIYONG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 创建时间：2016-10-25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@update</span> 修改时间：2016-10-25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncodeDecode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">String defaultStr = <span class="keyword">new</span> String(<span class="string">"my english name is lee,my age is 0,我热爱我的工作编程,123"</span>);</span><br><span class="line">method1(defaultStr);</span><br><span class="line">method2(defaultStr);</span><br><span class="line">method3(defaultStr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(String defaultStr)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] encodeByUtf8 = defaultStr.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">"===========method1  encodeByUtf8 "</span> + defaultStr + <span class="string">"=============="</span>);</span><br><span class="line">cmmonMethod(encodeByUtf8);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(String defaultStr)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] encodeByGbk = defaultStr.getBytes(<span class="string">"GBK"</span>);</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">"===========method2  encodeByGbk "</span> + defaultStr + <span class="string">"=============="</span>);</span><br><span class="line">cmmonMethod(encodeByGbk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(String defaultStr)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] encodeiso88591 = defaultStr.getBytes(<span class="string">"ISO8859-1"</span>);</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">"===========method3  encodeiso88591 "</span> + defaultStr + <span class="string">"=============="</span>);</span><br><span class="line">cmmonMethod(encodeiso88591);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cmmonMethod</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">String utf8 = <span class="keyword">new</span> String(bytes, <span class="string">"UTF-8"</span>);</span><br><span class="line">System.out.println(<span class="string">"utf8 :"</span> + utf8);</span><br><span class="line">String utf16 = <span class="keyword">new</span> String(bytes, <span class="string">"UTF-16"</span>);</span><br><span class="line">System.out.println(<span class="string">"utf16 :"</span> + utf16);</span><br><span class="line">String gbk = <span class="keyword">new</span> String(bytes, <span class="string">"GBK"</span>);</span><br><span class="line">System.out.println(<span class="string">"gbk :"</span> + gbk);</span><br><span class="line">String iso88591 = <span class="keyword">new</span> String(bytes, <span class="string">"ISO8859-1"</span>);</span><br><span class="line">System.out.println(<span class="string">"iso88591 :"</span> + iso88591);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><img src="https://liyong.ac.cn/pic/se/2.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb中涉及的编解码</title>
      <link href="/2017/05/30/aa_category/se/JavaWeb%E4%B8%AD%E6%B6%89%E5%8F%8A%E7%9A%84%E7%BC%96%E8%A7%A3%E7%A0%81/"/>
      <url>/2017/05/30/aa_category/se/JavaWeb%E4%B8%AD%E6%B6%89%E5%8F%8A%E7%9A%84%E7%BC%96%E8%A7%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>用户从浏览器发起一个HTTP请求，存在编码的地方是URL、Cookie、Paramiter。服务器端接收到HTTP请求后要解析HTTP协议，其中URL、Cookie和POST表单参数要解码，服务器端可能还需要读取硬盘数据（数据库、文件），这些数据都可能存在编码问题。当Servlet处理完所有请求的数据后，需要将这些数据再编码通过Socket发送到用户请求的浏览器里，再经过浏览器解码成为文本。这些过程用图表示如下：</p><a id="more"></a><p><img src="1.png" alt></p><h2 id="URL的编解码"><a href="#URL的编解码" class="headerlink" title="URL的编解码"></a>URL的编解码</h2><p><img src="2.png" alt><br>为了验证浏览器是怎么编码URL的，我们选择FireFox浏览器并通过HTTPFox插件观察请求的URL的实际内容：<br><img src="3.png" alt><br>从结果上看，PathInfo是UTF-8编码，而QueryString是GBK编码。至于为什么有%，是由URL的编码规范FRC3986规定：浏览器编码URL将非ASCII字符按照某种编码格式编码成16进制数字后将每个16进制表示的字节前加上“%”。<br>从上面的测试结果可知，浏览器对PathInfo和QueryString的编码是不一样的，不同的浏览器对PathInfo的编码也可能不一样。如Chrome会对请求“<a href="http://localhost:8080/中国?中国”转变为“http://localhost:8080/%E4%B8%AD%E5%9B%BD?%E4%B8%AD%E5%9B%BD”，这里PathInfo和QueryString的编码是一样的，都是UTF-8编码。" target="_blank" rel="noopener">http://localhost:8080/中国?中国”转变为“http://localhost:8080/%E4%B8%AD%E5%9B%BD?%E4%B8%AD%E5%9B%BD”，这里PathInfo和QueryString的编码是一样的，都是UTF-8编码。</a></p><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>解析请求的 URL 是在 org.apache.coyote.HTTP11.InternalInputBuffer 的 parseRequestLine 方法中，这个方法把传过来的 URL 的 byte[] 设置到 org.apache.coyote.Request 的相应的属性中。这里的 URL 仍然是 byte 格式，转成 char 是在 org.apache.catalina.connector.CoyoteAdapter 的 convertURI 方法中完成的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">convertURI</span><span class="params">(MessageBytes uri, Request request)</span> </span></span><br><span class="line"><span class="function">             <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">                    ByteChunk bc = uri.getByteChunk(); </span><br><span class="line">                    <span class="keyword">int</span> length = bc.getLength(); </span><br><span class="line">                    CharChunk cc = uri.getCharChunk(); </span><br><span class="line">                    cc.allocate(length, -<span class="number">1</span>); </span><br><span class="line">                    String enc = connector.getURIEncoding();     <span class="comment">//获取URI解码集</span></span><br><span class="line">                    <span class="keyword">if</span> (enc != <span class="keyword">null</span>) &#123; </span><br><span class="line">                        B2CConverter conv = request.getURIConverter(); </span><br><span class="line">                        <span class="keyword">try</span> &#123; </span><br><span class="line">                            <span class="keyword">if</span> (conv == <span class="keyword">null</span>) &#123; </span><br><span class="line">                                conv = <span class="keyword">new</span> B2CConverter(enc); </span><br><span class="line">                                request.setURIConverter(conv); </span><br><span class="line">                            &#125; </span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;...&#125; </span><br><span class="line">                        <span class="keyword">if</span> (conv != <span class="keyword">null</span>) &#123; </span><br><span class="line">                            <span class="keyword">try</span> &#123; </span><br><span class="line">                                conv.convert(bc, cc, cc.getBuffer().length - cc.getEnd()); </span><br><span class="line">                                uri.setChars(cc.getBuffer(), cc.getStart(), cc.getLength()); </span><br><span class="line">                                <span class="keyword">return</span>; </span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;...&#125; </span><br><span class="line">                        &#125; </span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="comment">// Default encoding: fast conversion </span></span><br><span class="line">                    <span class="keyword">byte</span>[] bbuf = bc.getBuffer(); </span><br><span class="line">                    <span class="keyword">char</span>[] cbuf = cc.getBuffer(); </span><br><span class="line">                    <span class="keyword">int</span> start = bc.getStart(); </span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123; </span><br><span class="line">                        cbuf[i] = (<span class="keyword">char</span>) (bbuf[i + start] &amp; <span class="number">0xff</span>); </span><br><span class="line">                    &#125; </span><br><span class="line">                    uri.setChars(cbuf, <span class="number">0</span>, length); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可知，对URI的解码操作是首先获取Connector的解码集，该配置在server.xml中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">URIEncoding</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>如果没有定义则会采用默认编码ISO-8859-1来解析.</p><h3 id="Query-String"><a href="#Query-String" class="headerlink" title="Query String"></a>Query String</h3><p>对于Query String部分，我们知道无论我们是通过get方式还是POST方式提交，所有的参数都是保存在Parameters，然后我们通过request.getParameter，解码工作就是在第一次调用getParameter方法时进行的。在getParameter方法内部它调用org.apache.catalina.connector.Request 的 parseParameters 方法，这个方法将会对传递的参数进行解码。下面代码只是parseParameters方法的一部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取编码</span></span><br><span class="line">   String enc = getCharacterEncoding();</span><br><span class="line">  <span class="comment">//获取ContentType 中定义的 Charset</span></span><br><span class="line">  <span class="keyword">boolean</span> useBodyEncodingForURI = connector.getUseBodyEncodingForURI();</span><br><span class="line">  <span class="keyword">if</span> (enc != <span class="keyword">null</span>) &#123;    <span class="comment">//如果设置编码不为空，则设置编码为enc</span></span><br><span class="line">      parameters.setEncoding(enc);</span><br><span class="line">      <span class="keyword">if</span> (useBodyEncodingForURI) &#123;   <span class="comment">//如果设置了Chartset，则设置queryString的解码为ChartSet</span></span><br><span class="line">          parameters.setQueryStringEncoding(enc);    </span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;     <span class="comment">//设置默认解码方式</span></span><br><span class="line">      parameters.setEncoding(org.apache.coyote.Constants.DEFAULT_CHARACTER_ENCODING);</span><br><span class="line">      <span class="keyword">if</span> (useBodyEncodingForURI) &#123;</span><br><span class="line">          parameters.setQueryStringEncoding(org.apache.coyote.Constants.DEFAULT_CHARACTER_ENCODING);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出对query String的解码格式要么采用设置的ChartSet要么采用默认的解码格式ISO-8859-1。注意这个设置的ChartSet是在 http Header中定义的ContentType，同时如果我们需要改指定属性生效，还需要进行如下配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">URIEncoding</span>=<span class="string">"UTF-8"</span> <span class="attr">useBodyEncodingForURI</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="POST表单的编解码"><a href="#POST表单的编解码" class="headerlink" title="POST表单的编解码"></a>POST表单的编解码</h2><p>POST表单参数传递方式与QueryString不同，它是通过HTTP的BODY传递到服务端的。当我们在页面上点击提交按钮时浏览器首先将根据页面的ContentType的Charset编码格式对表单填的参数进行编码，然后提交到服务器端。在服务器端同样也是用ContentType中的字符集进行解码。所以通过POST表单提交的参数一般不会出现问题，而且这个字符集编码可以通过HttpServletRequest.setCharacterEncoding设置，且一定要在第一次调用HttpServletRequest.getParameter之前设置。<br>另外，针对multipart/form-data类型的参数，也就是上传的文件编码，同样也使用ContentType定义的字符集编码。值得注意的地方是，上传文件是用字节流的方式传输到服务器的本地临时目录，这个过程并没有涉及字符编码，而真正编码是在将文件内容添加到parameters中时，如果用这个不能编码将会用默认编码ISO-8859-1来编码。</p><h2 id="HTTP-BODY的编解码"><a href="#HTTP-BODY的编解码" class="headerlink" title="HTTP BODY的编解码"></a>HTTP BODY的编解码</h2><p>当用户请求的资源服务端已经成功获取后，这些内容将通过Response返回给客户端浏览器，这个过程先要经过编码再到浏览器进行解码，浏览器根据HTML的<meta http-equiv="“Content-Type”" content="”text/html;" charset="GBK”">中的charset来解码。如果没有定义，那么浏览器将会使用默认的编码来解码。</p><h2 id="JS中的编解码"><a href="#JS中的编解码" class="headerlink" title="JS中的编解码"></a>JS中的编解码</h2><p>1、html文件本身中的js的编码和当前页面中的Content-Type保持一致。<br>2、对于采用<script src="”script.js”/">类型引入的js文件，浏览器就会以当前这个页面的默认字符集解析这个JS文件，如果外部的JS文件的编码格式与当前页面的编码格式一致，那么可以不设置这个charset。但是如果script.js文件的编码格式与当前页面的不一致，就必须要指定对应的字符集，要不然对于非ASCII字符就会出现乱码。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>  <span class="attr">src</span>=<span class="string">""</span> <span class="attr">charset</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="encodeURI-函数"><a href="#encodeURI-函数" class="headerlink" title="encodeURI()函数"></a>encodeURI()函数</h3><p>它着眼于对整个URL进行utf-8编码，因此除了常见的符号以外，对其他一些在网址中有特殊含义的符号“; / ? : @ & = + $ , #”，也不进行编码。编码后，它输出符号的形式，并且在每个字节前加上%。</p><h3 id="encodeURIComponent-函数"><a href="#encodeURIComponent-函数" class="headerlink" title="encodeURIComponent()函数"></a>encodeURIComponent()函数</h3><p>用于对URL的组成部分进行个别编码，而不用于对整个URL进行编码。<br>因此，“; / ? : @ & = + $ , #”，这些在encodeURI()中不被编码的符号，在encodeURIComponent()中统统会被编码。至于具体的编码方法，两者是一样。</p></script></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见编码格式</title>
      <link href="/2017/05/30/aa_category/se/%E5%B8%B8%E8%A7%81%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/"/>
      <url>/2017/05/30/aa_category/se/%E5%B8%B8%E8%A7%81%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么编码？"><a href="#为什么编码？" class="headerlink" title="为什么编码？"></a>为什么编码？</h2><p>1、计算机中最小存储单位为一个字节，即8个bit，所以能表示的范围为0-255<br>2、人类要表示的符号太多，无法用一个字节来完全表示<br>要解决这个矛盾就要新的数据结构char，从char到byte就需要编码</p><a id="more"></a><h2 id="ASCII编码"><a href="#ASCII编码" class="headerlink" title="ASCII编码"></a>ASCII编码</h2><p>ASCII码一共规定了128个字符的编码，比如空格”SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。</p><h2 id="ISO-8859-1编码"><a href="#ISO-8859-1编码" class="headerlink" title="ISO-8859-1编码"></a>ISO-8859-1编码</h2><p>单字节编码，向下兼容ASCII，其编码范围是0x00-0xFF，0x00-0x7F之间完全和ASCII一致，0x80-0x9F之间是控制字符，0xA0-0xFF之间是文字符号。此字符集主要支持欧洲使用的语言</p><h2 id="GB2312编码"><a href="#GB2312编码" class="headerlink" title="GB2312编码"></a>GB2312编码</h2><p>GB2312编码双字节编码，是第一个汉字编码国家标准</p><h2 id="GBK编码"><a href="#GBK编码" class="headerlink" title="GBK编码"></a>GBK编码</h2><p>GBK编码，是对GB2312编码的扩展，因此完全兼容GB2312-80标准。GBK编码依然采用双字节编码方案</p><h2 id="Unicode编码"><a href="#Unicode编码" class="headerlink" title="Unicode编码"></a>Unicode编码</h2><p>Unicode背后的想法非常简单，然而却被普遍的误解了。Unicode就像一个电话本，标记着字符和数字之间的映射关系。Joel称之为「神奇数字」，因为它们可能是随机指定的，而且不会给出任何解释。官方术语是码位(Code Point)，总是用U+开头。理论上每种语言中的每种字符都被Unicode协会指定了一个神奇数字。例如希伯来文中的第一个字母א，是U+2135，字母A是U+0061。<br>Unicode并不涉及字符是怎么在字节中表示的，它仅仅指定了字符对应的数字，仅此而已。<br>关于Unicode的其它误解包括：Unicode支持的字符上限是65536个，Unicode字符必须占两个字节。告诉你这些的人应该去换换脑子了。<br>记住，Unicode只是一个用来映射字符和数字的标准。它对支持字符的数量没有限制，也不要求字符必须占两个、三个或者其它任意数量的字节。</p><p>Unicode字符是怎样被编码成内存中的字节这是另外的话题，它是被UTF(Unicode Transformation Formats)定义的。</p><p>两个最流行的Unicode编码方案是UTF-8和UTF-16</p><h2 id="UTF-16编码"><a href="#UTF-16编码" class="headerlink" title="UTF-16编码"></a>UTF-16编码</h2><p>1、用固定的两个字节表示unicode<br>2、通常说的unicode编码就是指UTF-16编码</p><h2 id="UTF-8编码"><a href="#UTF-8编码" class="headerlink" title="UTF-8编码"></a>UTF-8编码</h2><p>采用了变长技术，每个编码区域有不同的字码长度<br>1、如果一个字节最高位为0，表示这是一个ASCII字符<br>2、如果一个字节以11开头，连续的1的个数暗示这个字符的字节数，例如110xxxxx，代表双字节字符的首字节。<br>3、如果以10开头，代表不是首字节，向前查找才能找到首字节</p>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾收集算法</title>
      <link href="/2017/05/30/aa_category/se/gc&amp;mem/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/"/>
      <url>/2017/05/30/aa_category/se/gc&amp;mem/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>垃圾收集器通常会假设大部分的对象的存活时间都非常短，只有少数对象的存活时间比较长。<br>垃圾收集算法在JVM中主要是复制算法（新生代GC）和标记/整理算法（老年代GC）。</p><a id="more"></a><h2 id="标记-清除（Mark-Sweep）算法"><a href="#标记-清除（Mark-Sweep）算法" class="headerlink" title="标记-清除（Mark-Sweep）算法"></a>标记-清除（Mark-Sweep）算法</h2><p>算法过程：</p><ol><li>先判定对象是否可回收，对其标记。</li><li>统一回收（简单地删除对垃圾对象的内存引用）。<br>优点：简单直观容易实现和理解。缺点：效率不高，内存空间碎片化。</li></ol><h2 id="复制（Copying）算法"><a href="#复制（Copying）算法" class="headerlink" title="复制（Copying）算法"></a>复制（Copying）算法</h2><p>将内存平均分成A、B两块，算法过程：<br>1.新生对象被分配到A块中未使用的内存当中。当A块的内存用完了， 把A块的存活对象对象复制到B块。<br>2.清理A块所有对象。<br>3.新生对象被分配的B块中未使用的内存当中。当B块的内存用完了， 把B块的存活对象对象复制到A块。<br>4.清理B块所有对象。<br>5.goto 1。<br>优点：简单高效。缺点：内存代价高，有效内存为占用内存的一半。</p><h3 id="对复制算法进一步优化：使用Eden-S0-S1三个分区"><a href="#对复制算法进一步优化：使用Eden-S0-S1三个分区" class="headerlink" title="对复制算法进一步优化：使用Eden/S0/S1三个分区"></a>对复制算法进一步优化：使用Eden/S0/S1三个分区</h3><p>平均分成A/B块太浪费内存，采用Eden/S0/S1三个区更合理，空间比例为Eden:S0:S1==8:1:1，有效内存（即可分配新生对象的内存）是总内存的9/10。<br>算法过程：<br>1.Eden+S0可分配新生对象；<br>2.对Eden+S0进行垃圾收集，存活对象复制到S1。清理Eden+S0。一次新生代GC结束。<br>3.Eden+S1可分配新生对象；<br>4.对Eden+S1进行垃圾收集，存活对象复制到S0。清理Eden+S1。二次新生代GC结束。<br>5.goto 1。</p><h2 id="标记-整理（Mark-Compact）"><a href="#标记-整理（Mark-Compact）" class="headerlink" title="标记-整理（Mark-Compact）"></a>标记-整理（Mark-Compact）</h2><p>算法过程：<br>1.标记：标记可回收对象（垃圾对象）和存活对象。<br>2.整理：将所有存活对象向一端移动，然后直接清理掉边界以外的内存。</p><h2 id="分代收集策略"><a href="#分代收集策略" class="headerlink" title="分代收集策略"></a>分代收集策略</h2><p>由于不同的对象适合使用不同的垃圾收集算法，所以引入“代”这个概念。不同的代有不同的分区，一般分为新生代区和老年代区。<br>新生代：适合采用复制算法进行垃圾收集，对象分布在Eden/S0/S1三个区。<br>老年代：适合采用标记-紧凑算法进行垃圾收集。</p><h2 id="Heap分区和分代概念"><a href="#Heap分区和分代概念" class="headerlink" title="Heap分区和分代概念"></a>Heap分区和分代概念</h2><h3 id="Heap分区的目的"><a href="#Heap分区的目的" class="headerlink" title="Heap分区的目的"></a>Heap分区的目的</h3><ol><li>为了分代：不同代的对象放到不同的内存分区中，实现“代提升”，也方便实现对不同分代采用不同的垃圾收集算法。</li><li>垃圾收集算法需要：新生代GC使用到复制算法，该算法需要将对应的分区划分成三个分区：Eden/S0/S1。</li></ol><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>Generation代</p><ul><li>YongGeneration/NewGeneration：新生代，在Eden/S0/S1的存活的对象。</li><li>OldGeneration：老年代，在Tenured区存活的对象。</li><li>PermanentGeneration：永久代。<br>Space 区</li><li>Eden：伊甸园区，是新生代的一个区。</li><li>Survivor：幸存区，属于新生代，为了复制算法的需要。一般分成大小相等的两个区（S0/S1或者From/To）。</li><li>Tenured：存放老年代的区域。</li><li>Permanent：终身区。<br><img src="1.png" alt="1"></li></ul><h3 id="Eden-S0-S1-新生代"><a href="#Eden-S0-S1-新生代" class="headerlink" title="Eden/S0/S1 新生代"></a>Eden/S0/S1 新生代</h3><p>S0/S1是大小相当的两个区域，共同组成Survivor区。<br>空间比例：Eden:S0==8:1。设定方法：-XX:SurvivorRatio=8。<br>新生对象在Eden/S0或者Eden/S1中分配，Eden区的对象量达到一个阈值后，发生一次新生代GC。</p><p>##Old 老年代<br>每个对象有“对象年龄计数器”。对象由Eden收集到Survivor区后，年龄+1。进行新生代GC后，年龄+1。依次，当年龄&gt;=15后进入老年代。<br>最大年龄阈值设定：-XX:MaxTenuringThreshold。<br>动态年龄：如果在Survivor中所有相同年龄对象占用了空间的一半多，大于等于上述年龄的对象直接进入老年代。<br>大对象（比如大的数组）直接进入老年代。阈值设定：-XX:PretenureSizeThreshold。</p><h3 id="Perm-永久代（PermanentGeneration）"><a href="#Perm-永久代（PermanentGeneration）" class="headerlink" title="Perm 永久代（PermanentGeneration）"></a>Perm 永久代（PermanentGeneration）</h3><p>用于存放不变对象，如类、方法、字符串等。<br>Java7把驻留字符串（intentd string）放到了老年代区。Java8中移除了Hotspot的永久代区</p><h2 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h2><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>从可达性分析中从GC Roots节点找引用为例，可作为GC Roots的节点主要是全局性的引用与执行上下文中，如果要逐个检查引用，必然消耗时间。<br>另外可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须在一个能确保一致性的快照中进行——这里的“一致性”的意思是指整个分析期间整个系统执行系统看起来就行被冻结在某个时间点，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果的准确性就无法得到保证。这点是导致GC进行时必须暂停所有Java执行线程的其中一个重要原因。<br>由于目前主流的Java虚拟机都是准确式GC，做一档执行系统停顿下来之后，并不需要一个不漏的检查执行上下文和全局的引用位置，虚拟机应当有办法得知哪些地方存放的是对象的引用。在HotSpot的实现中，是使用一组OopMap的数据结构来达到这个目的。 </p><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>在OopMap的协助下，HotSpot可以快速且准确的完成GC Roots的枚举，但可能导致引用关系变化的指令非常多，如果为每一条指令都生成OopMap，那将会需要大量的额外空间，这样GC的空间成本会变的很高。<br>实际上，HotSpot也的确没有为每条指令生成OopMap，只是在特定的位置记录了这些信息，这些位置被称为安全点（SafePoint）。SafePoint的选定既不能太少，以致让GC等待时间太久，也不能设置的太频繁以至于增大运行时负荷。所以安全点的设置是以让程序“是否具有让程序长时间执行的特征”为标准选定的。“长时间执行”最明显的特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生SafePoint。<br>对于SafePoint，另一个问题是如何在GC发生时让所有线程都跑到安全点在停顿下来。这里有两种方案：抢先式中断和主动式中断。抢先式中断不需要线程代码主动配合，当GC发生时，首先把所有线程中断，如果发现线程中断的地方不在安全点上，就恢复线程，让他跑到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程来响应GC。<br>而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单的设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起，轮询标志的地方和安全点是重合的另外再加上创建对象需要分配的内存的地方。 </p><h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>使用安全点似乎已经完美解决了如何进入GC的问题，但实际情况却并不一定，安全点机制保证了程序执行时，在不太长的时间内就会进入到可进入的GC的安全点。但是程序如果不执行呢？所谓的程序不执行就是没有分配cpu时间，典型的例子就是线程处于sleep状态或者blocked状态，这时候线程无法响应jvm中断请求，走到安全的地方中断挂起，jvm显然不太可能等待线程重新分配cpu时间，对于这种情况，我们使用安全区域来解决。<br>安全区域是指在一段代码片段之中，你用关系不会发生变化。在这个区域的任何地方开始GC都是安全的，我们可以把安全区域看做是扩展了的安全点。<br>当线程执行到安全区域中的代码时，首先标识自己已经进入了安全区，那样当在这段时间里，JVM要发起GC时，就不用管标识自己为安全区域状态的线程了。当线程要离开安全区域时，他要检查系统是否完成了根节点枚举，如果完成了，那线程就继续执行，否则他就必须等待，直到收到可以安全离开安全区域的信号为止。</p><p><a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" title="参考" target="_blank" rel="noopener">http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html</a></p>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> memory </tag>
            
            <tag> gc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象已死吗</title>
      <link href="/2017/05/30/aa_category/se/gc&amp;mem/%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB%E5%90%97/"/>
      <url>/2017/05/30/aa_category/se/gc&amp;mem/%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB%E5%90%97/</url>
      
        <content type="html"><![CDATA[<h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。<br>主流的java虚拟机里面没有选用这个算法来管理内存，主要原因是它很难解决对象之间相互循环引用的问题。</p><a id="more"></a><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。<br>在Java语言中，可作为GC Roots的对象包括下面几种：<br>1）虚拟机栈（帧栈中的本地变量表）中引用的对象。<br>2）方法区中类静态属性引用的对象。<br>3）方法区中常量引用的对象。<br>4）本地方法栈中JNI（即一般说的Native对象）引用的对象。</p><h2 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h2><p>在JDK1.2以前，Java中的引用的定义很传统：如果Reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。<br>在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为：<br>1）强引用（Strong Reference）<br>2）软引用（Soft Reference）<br>3）弱引用（Weak Reference）<br>4）虚引用（Phantom Reference）<br>这四种引用强度依次逐渐减弱。<br>1）强引用就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。<br>2）软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了SoftReference类来实现软引用。<br>3）弱引用也是用来描述非必须对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用。<br>4）虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantomReference类来实现虚引用。</p><h2 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h2><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候他们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。<br>如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端情况），将很可能会导致F-Queue队列中其它对象永久处于等待，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己–只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那么在第二次标记时它将被移除出“即将回收”的集合，如果对象这时候还没有逃脱，那基本上它就真的被回收了。<br><img src="1.png" alt="1"><br>从下面代码中我们可以看到一个对象的finalize()被执行，但是它仍然可以存活，一次对象自我拯救的演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此代码演示了两点： 1.对象可以在被GC时自我拯救。 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"yes, i am still alive :)"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.finalize();</span><br><span class="line">System.out.println(<span class="string">"finalize mehtod executed!"</span>);</span><br><span class="line">FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象第一次成功拯救自己</span></span><br><span class="line">SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br><span class="line"><span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">Thread.sleep(<span class="number">500</span>);</span><br><span class="line"><span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">SAVE_HOOK.isAlive();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"no, i am dead :("</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br><span class="line"><span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">Thread.sleep(<span class="number">500</span>);</span><br><span class="line"><span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">SAVE_HOOK.isAlive();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"no, i am dead :("</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">finalize mehtod executed!</span><br><span class="line">yes, i am still alive :)</span><br><span class="line">no, i am dead :(</span><br></pre></td></tr></table></figure><p>执行结果一次成功，一次失败，这是因为任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。<br>特别说明：不建议使用finalize方法，因为它的运行代价高，不确定性大，无法保证各个对象的调用顺序。finalize()方法能做的所有工作，使用try-finally或者其它方式都可以做得更好、更及时。</p><h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>在方法区中进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而永久代的垃圾收集效率远低于此。<br>永久代的垃圾收集主要回收两部分内容：<br>  1）废弃的常量<br>  2）无用的类<br>回收废弃的常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象叫做“abc”的，换句话说,就是没有任何String对象引用常量池中的“abc”常量，也没有其它地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个“abc”常量就会被系统清理出常量池。常量池中的其它类（接口）、方法、字段的符号引用也与此类似。<br>类需要同时满足下面3个条件才能算是“无用的类”：<br>1）该类所有的实例都已经被回收了，也就是Java堆中不存在该类的任何实例。<br>2）加载该类的ClassLoader已经被回收。<br>3）该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。<br>虚拟机可以对满足上述3各条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot虚拟机提供了:<br> 1）-Xnoclassgc参数控制是否对类进行回收<br> 2）-verbose:class以及-XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类加载和卸载信息。其中-verbose:class和-XX:+TraceClassLoading可以在Product版的虚拟机中使用，-XX:+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。</p>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> memory </tag>
            
            <tag> gc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HotSpot虚拟机对象探秘</title>
      <link href="/2017/05/29/aa_category/se/gc&amp;mem/HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98/"/>
      <url>/2017/05/29/aa_category/se/gc&amp;mem/HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98/</url>
      
        <content type="html"><![CDATA[<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过的。如果没有，那必须先执行相应的类加载过程</p><a id="more"></a><p>在类加载通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务具体便等同于一块确定大小的内存从Java堆中划分出来</p><p>内存分配完成之后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB的话，这一个工作也可以提前至TLAB分配时进行。<br>除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内<br>存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存。解决这个问题有两个方案，一种是对分配内存空间的动作进行同步——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性；另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲，（TLAB ，Thread Local Allocation Buffer），哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完，分配新的TLAB时才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。</p><p>接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中</p><p>在上面工作都完成之后，在虚拟机的视角来看，一个新的对象已经产生了。但是在Java程序的视角看来，对象创建才刚刚开始——<init>方法还没有执行，所有的字段都为零呢。所以一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之后会接着就是执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</init></init></p><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，这部分数据的长度在32位和64位的虚拟机（暂不考虑开启压缩指针的场景）中分别为32个和64个Bits，官方称它为“Mark Word”。考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如在32位的HotSpot虚拟机中对象未被锁定的状态下，Mark Word的32个Bits空间中的25Bits用于存储对象哈希码（HashCode），4Bits用于存储对象分代年龄，2Bits用于存储锁标志位，1Bit固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下表所示。<br><img src="1.png" alt="1"></p><p>对象头的另外一部分是类型指针，即是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说查找对象的元数据信息并不一定要经过对象本身。另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中无法确定数组的大小。</p><h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>实例数据部分是对象真正存储的有效信息，也既是我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的都需要记录袭来。这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果CompactFields参数值为true（默认为true），那子类之中较窄的变量也可能会插入到父类变量的空隙之中。</p><h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。对象头部分正好似8字节的倍数（1倍或者2倍），因此当对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范里面只规定了是一个指向对象的引用，并没有定义这个引用应该通过什么种方式去定位、访问到堆中的对象的具体位置，对象访问方式也是取决于虚拟机实现而定的。主流的访问方式有使用句柄和直接指针两种。</p><p>如果使用句柄访问的话，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据的具体各自的地址信息。<br><img src="2.png" alt="2"><br>如果使用直接指针访问的话，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址。<br><img src="3.png" alt="3"></p><p>使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</p><p>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问的在Java中非常频繁，因此这类开销积小成多也是一项非常可观的执行成本。<br>就虚拟机HotSpot而言，它是使用第二种方式进行对象访问</p>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运行时数据区域</title>
      <link href="/2017/05/29/aa_category/se/gc&amp;mem/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/"/>
      <url>/2017/05/29/aa_category/se/gc&amp;mem/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<p> <img src="1.jpg" alt="1"></p><a id="more"></a><h2 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）　　　　　"></a>程序计数器（Program Counter Register）　　　　　</h2><p>程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。<br>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。<br>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）</p><h2 id="Java虚拟机栈（Java-Virtual-Machine-Stacks）"><a href="#Java虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="Java虚拟机栈（Java Virtual Machine Stacks）"></a>Java虚拟机栈（Java Virtual Machine Stacks）</h2><p>Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。<br>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型），它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。<br>其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈动态扩展时，无法申请到足够的内存时会抛出OutOfMemoryError异常。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则是为虚拟机使用到的Native方法服务</p><h2 id="Java堆（Java-Heap）"><a href="#Java堆（Java-Heap）" class="headerlink" title="Java堆（Java Heap）"></a>Java堆（Java Heap）</h2><p>Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。<br>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”（Garbage Collected Heap，幸好国内没翻译成“垃圾堆”）。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。如果从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。<br>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><h2 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h2><p>是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。<br>对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9等）来说是不存在永久代的概念的。即使是HotSpot虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”至Native Memory来实现方法区的规划了。<br>Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的<br>根据Java虚拟机规范的规定，当方法区无法满足内存分配</p><p>需求时，将抛出OutOfMemoryError异常。</p><h2 id="运行时常量池（Runtime-Constant-Pool）"><a href="#运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="运行时常量池（Runtime Constant Pool）"></a>运行时常量池（Runtime Constant Pool）</h2><p>运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。<br>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。<br> 既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> se </tag>
            
            <tag> memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM中锁优化，偏向锁、自旋锁、锁消除、锁粗化</title>
      <link href="/2017/05/29/aa_category/se/gc&amp;mem/JVM%E4%B8%AD%E9%94%81%E4%BC%98%E5%8C%96/"/>
      <url>/2017/05/29/aa_category/se/gc&amp;mem/JVM%E4%B8%AD%E9%94%81%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>锁削除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行削除（主要判定依据来源于逃逸分析的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行）</p><a id="more"></a><h2 id="锁粗化-膨胀"><a href="#锁粗化-膨胀" class="headerlink" title="锁粗化(膨胀)"></a>锁粗化(膨胀)</h2><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。 如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（膨胀）到整个操作序列的外部（由多次加锁编程只加锁一次）。</p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。</p><p>偏向锁会偏向于第一个获得它的线程（Mark Word中的偏向线程ID信息），如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p><p>假设当前虚拟机启用了偏向锁（启用参数-XX:+UseBiasedLocking，JDK 1.6的默认值），当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如Locking、Unlocking及对Mark Word的Update等）。当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>轻量级锁并不是用来代替重量级锁（传统锁机制，如互斥等）的，目的是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。<br>HotSpot虚拟机的对象头（Object Header）分为两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄（Generational GC Age）等，这部分数据的长度在32位和64位的虚拟机中分别为32个和64个Bits，官方称它为“Mark Word”，它是实现轻量级锁和偏向锁的关键。另外一部分用于存储指向方法区对象类型数据的指针，如果是数组对象的话，还会有一个额外的部分用于存储数组长度。<br>Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如在32位的HotSpot虚拟机中对象未被锁定的状态下，Mark Word的32个Bits空间中的25Bits用于存储对象哈希码（HashCode），4Bits用于存储对象分代年龄，2Bits用于存储锁标志位，1Bit固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下Mark Word的存储内容<br> <img src="1.png" alt="1"></p><h3 id="加锁过程"><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h3><p>在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）,然后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。<br>如果这个更新动作成功，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位（Mark Word的最后两个Bits）将转变为“00”，即表示此对象处于轻量级锁定状态,<br>如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。</p><h3 id="解锁过程"><a href="#解锁过程" class="headerlink" title="解锁过程"></a>解锁过程</h3><p>解锁过程也是通过CAS操作来进行的，如果对象的Mark Word仍然指向着线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来，如果替换成功，整个同步过程就完成了。如果替换失败，说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。</p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力。而在很多应用上，共享数据的锁定状态只会持续很短的一段时间。若实体机上有多个处理器，能让两个以上的线程同时并行执行，我们就可以让后面请求锁的那个线程原地自旋（不放弃CPU时间），看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只须让线程执行一个忙循环（自旋），这项技术就是自旋锁。<br>如果锁长时间被占用，则浪费处理器资源，因此自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了（默认10次）。<br>JDK1.6引入自适应的自旋锁：自旋时间不再固定，由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。</p>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> concurrent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Future模式</title>
      <link href="/2017/05/14/aa_category/se/thread/Future%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/05/14/aa_category/se/thread/Future%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent.future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Data</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getResult</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent.future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealData</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Data</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> T result;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RealData</span><span class="params">(T pram)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">sb.append(pram + <span class="string">" "</span> + i + <span class="string">"  "</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1</span> * <span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">result = (T) sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent.future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureData</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Data</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isReady = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> RealData&lt;T&gt; realData = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"进入 FutureData getResult"</span>);</span><br><span class="line"><span class="keyword">while</span> (!isReady) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">wait();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"FutureData getResult  已经有数据"</span>);</span><br><span class="line"><span class="keyword">return</span> realData.getResult();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setRealData</span><span class="params">(RealData&lt;T&gt; realData)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isReady) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.realData = realData;</span><br><span class="line"><span class="keyword">this</span>.isReady = <span class="keyword">true</span>;</span><br><span class="line">notifyAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent.future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.poi.ss.formula.functions.T;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"hiding"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Data&lt;T&gt; <span class="title">request</span><span class="params">(<span class="keyword">final</span> T queryStr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> FutureData&lt;T&gt; futureData = <span class="keyword">new</span> FutureData&lt;T&gt;();</span><br><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">RealData&lt;T&gt; realData = <span class="keyword">new</span> RealData&lt;T&gt;(queryStr);</span><br><span class="line">futureData.setRealData(realData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;.start();</span><br><span class="line"><span class="keyword">return</span> futureData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Client&lt;String&gt; client = <span class="keyword">new</span> Client&lt;String&gt;();</span><br><span class="line">Data&lt;String&gt; data = client.request(<span class="string">" lee is good"</span>);</span><br><span class="line">System.out.println(System.currentTimeMillis() + <span class="string">" 请求完毕 "</span>);</span><br><span class="line">String result = data.getResult();</span><br><span class="line">System.out.println(System.currentTimeMillis() + <span class="string">" 结果 "</span> + result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK中的Future模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent.future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealData2</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">String pram;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RealData2</span><span class="params">(String pram)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.pram = pram;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">sb.append(pram + <span class="string">" "</span> + i + <span class="string">"  "</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1</span> * <span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">RealData2 data = <span class="keyword">new</span> RealData2(<span class="string">" lee is good"</span>);</span><br><span class="line">FutureTask&lt;String&gt; task = <span class="keyword">new</span> FutureTask&lt;String&gt;(data);</span><br><span class="line">ExecutorService service = Executors.newSingleThreadExecutor();</span><br><span class="line">service.submit(task);</span><br><span class="line">System.out.println(System.currentTimeMillis() + <span class="string">" 请求完毕 "</span>);</span><br><span class="line">String result = task.get();</span><br><span class="line">System.out.println(System.currentTimeMillis() + <span class="string">" 结果 "</span> + result);</span><br><span class="line">service.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> concurrent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Se小众语法</title>
      <link href="/2017/05/14/aa_category/se/Se%E5%B0%8F%E4%BC%97%E8%AF%AD%E6%B3%95/"/>
      <url>/2017/05/14/aa_category/se/Se%E5%B0%8F%E4%BC%97%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>介绍不常用，可能用得着的语法</p><a id="more"></a><h2 id="在多层嵌套循环中continue到任意层"><a href="#在多层嵌套循环中continue到任意层" class="headerlink" title="在多层嵌套循环中continue到任意层"></a>在多层嵌套循环中continue到任意层</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;V&gt; <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">lee: <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">System.out.println(<span class="string">"i = "</span> + i + <span class="string">" j= "</span> + j);</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"continue lee"</span>);</span><br><span class="line"><span class="keyword">continue</span> lee;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"再来一次 i = "</span> + i + <span class="string">" j= "</span> + j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"============"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">System.out.println(<span class="string">"i = "</span> + i + <span class="string">" j= "</span> + j);</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"continue "</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"再来一次 i = "</span> + i + <span class="string">" j= "</span> + j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentLinkedQueue</title>
      <link href="/2017/05/14/aa_category/se/thread/ConcurrentLinkedQueue/"/>
      <url>/2017/05/14/aa_category/se/thread/ConcurrentLinkedQueue/</url>
      
        <content type="html"><![CDATA[<p> ConcurrentLinkedQueue由head节点和tail节点组成，每个节点（Node）由节点元素（item）和指向下一个节点的引用(next)<br> 组成，节点与节点之间就是通过这个next关联起来，从而组成一张链表结构的队列。默认情况下head节点存储的元素为空，tail节点等于head节点</p><a id="more"></a><h2 id="入队列"><a href="#入队列" class="headerlink" title="入队列"></a>入队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the tail of this queue.</span></span><br><span class="line"><span class="comment"> * As the queue is unbounded, this method will never return &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Queue#offer&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// p is last node</span></span><br><span class="line">            <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) &#123;</span><br><span class="line">                <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                <span class="comment">// for e to become an element of this queue,</span></span><br><span class="line">                <span class="comment">// and for newNode to become "live".</span></span><br><span class="line">                <span class="keyword">if</span> (p != t) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">                    casTail(t, newNode);  <span class="comment">// Failure is OK.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Lost CAS race to another thread; re-read next</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">            <span class="comment">// We have fallen off list.  If tail is unchanged, it</span></span><br><span class="line">            <span class="comment">// will also be off-list, in which case we need to</span></span><br><span class="line">            <span class="comment">// jump to head, from which all live nodes are always</span></span><br><span class="line">            <span class="comment">// reachable.  Else the new tail is a better bet.</span></span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// Check for tail updates after two hops.</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = (t != (t = tail)) ? t : head;</span><br></pre></td></tr></table></figure><p>1、!=并不是原子操作<br>2、先取得t的值，再执行t = tail并取得新的t的值，最后比较这两个值是否相同<br>3、t!=t在单线程下并不会成立，但是在多线程下可能成立。<br><img src="1.png" alt="1"></p><h2 id="出队列"><a href="#出队列" class="headerlink" title="出队列"></a>出队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    restartFromHead:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            E item = p.item;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                <span class="comment">// for item to be removed from this queue.</span></span><br><span class="line">                <span class="keyword">if</span> (p != h) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">                    updateHead(h, ((q = p.next) != <span class="keyword">null</span>) ? q : p);</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> concurrent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程安全的Map</title>
      <link href="/2017/05/14/aa_category/se/thread/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84Map/"/>
      <url>/2017/05/14/aa_category/se/thread/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84Map/</url>
      
        <content type="html"><![CDATA[<h2 id="SynchronizedMap"><a href="#SynchronizedMap" class="headerlink" title="SynchronizedMap"></a>SynchronizedMap</h2><p>  通过给传入的map加synchronized实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;String, Object&gt;())</span><br></pre></td></tr></table></figure><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> concurrent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2017/05/14/aa_category/methodology/design-pattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/05/14/aa_category/methodology/design-pattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> designpatterns.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liyong</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> staus = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StaticSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">System.out.println(<span class="string">"StaticSingleton is create"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> StaticSingleton instance = <span class="keyword">new</span> StaticSingleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> StaticSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>以上代码的优点<br>1、getInstance() 方法没有锁，使得在高并发场景下性能卓越<br>2、getInstance()方法只有在第一次调用的时候实例才会被创建</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池</title>
      <link href="/2017/05/07/aa_category/se/reflect/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2017/05/07/aa_category/se/reflect/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么使用线程池？"><a href="#为什么使用线程池？" class="headerlink" title="为什么使用线程池？"></a>为什么使用线程池？</h2><p>1、虽然线程是一个轻量级工具，但是创建和销毁线程依然需要花费时间，如果为小任务创建线程，很有可能创建线程的时间都大于执行任务的时间<br>2、线程本身也占有内存空间，大量的线程会抢占宝贵的内存资源。</p><a id="more"></a><h2 id="线程池工厂方法"><a href="#线程池工厂方法" class="headerlink" title="线程池工厂方法"></a>线程池工厂方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Executors.newSingleThreadExecutor();</span><br><span class="line">Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">Executors.newCachedThreadPool();</span><br><span class="line">Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h2 id="固定大小的线程池"><a href="#固定大小的线程池" class="headerlink" title="固定大小的线程池"></a>固定大小的线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 类描述：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 作者：LIYONG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 创建时间：2017-5-7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@update</span> 修改时间：2017-5-7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println( <span class="string">"运行 Thread id :"</span> + Thread.currentThread().getId()+<span class="string">"  "</span>+System.currentTimeMillis());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">ExecutorService es = Executors.newFixedThreadPool(<span class="number">5</span>, <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line">System.out.println(<span class="string">"创建 Thread id :"</span> + thread.getId());</span><br><span class="line"><span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">MyTask task = <span class="keyword">new</span> MyTask();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">es.execute(task);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">es.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h2><p>会在指定的时间，对任务进行调度，类似linux下面的crontab</p><h3 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a>schedule</h3><p>给定的时间会对任务进行一次调度</p><h3 id="scheduleAtFixedRate"><a href="#scheduleAtFixedRate" class="headerlink" title="scheduleAtFixedRate"></a>scheduleAtFixedRate</h3><p>1、任务是按照一定频率调度<br>2、以上一个任务开始执行时间为起点，之后的period时间调度下一个任务<br>3、如果调度周期小于执行时间，不会多个任务堆叠在一起，上一个任务结束后，立即调用</p><h3 id="scheduleWithFixedDelay"><a href="#scheduleWithFixedDelay" class="headerlink" title="scheduleWithFixedDelay"></a>scheduleWithFixedDelay</h3><p>上一个任务结束后再经过period时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 类描述：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 作者：LIYONG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 创建时间：2017-5-7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@update</span> 修改时间：2017-5-7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledExecutorServiceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">ScheduledExecutorService ses = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">ses.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">System.out.println(Thread.currentThread().getId()+<span class="string">"   "</span>+System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="number">1L</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="核心实现"><a href="#核心实现" class="headerlink" title="核心实现"></a>核心实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                             TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                             BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                             ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                             RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><p>threadFactory:线程工厂</p><h3 id="workQueue-任务队列，被提交尚未执行的任务"><a href="#workQueue-任务队列，被提交尚未执行的任务" class="headerlink" title="workQueue:任务队列，被提交尚未执行的任务"></a>workQueue:任务队列，被提交尚未执行的任务</h3><p>1、直接提交队列<br>1)该功能由SynchronousQueue提供<br>2)SynchronousQueue没有容量，每一个插入操作都要等待一个删除操作，反之亦然。<br>3)如果使用SynchronousQueue提交的任务不会被真实的保存，而总是将任务提交给线程执行，如果没有线程则创建一个线程，如果超过最大线程数，则执行拒绝策略<br>2、有界的任务队列<br>1)该功能由ArrayBlockingQueue提供<br>2)如果线程数小于等于corePoolSize，则直接创建线程<br>3)如果大于corePoolSize小于maximumPoolSize则把任务放入任务队列<br>4)如果任务队列已满且线程数小于maximumPoolSize则创建新的线程完成任务<br>5)若线程数大于maximumPoolSize则执行拒绝策略<br>3、无界的任务队列<br>1)该功能有LinkedBlockingQueue提供<br>2)如果线程数小于等于corePoolSize，则直接创建线程<br>3)如果线程数大于corePoolSize，有新的任务则直接加入任务队列，直至资源耗尽<br>4、优先任务队列<br>1)该功能由PriorityBlockingQueue提供<br>2)控制任务的先后执行顺序，是一个特殊的无界队列</p><p><img src="%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt="核心线程池"></p><h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><p>1、AbortPolicy:直接抛出异常，阻止系统正常工作<br>2、DiscardPolicy：什么也不做<br>3、DiscardOldestPolicy：丢弃最老的请求，并重新尝试提交任务<br>4、CallerRunsPolicy：只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Creates a &lt;tt&gt;CallerRunsPolicy&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Executes task r in the caller's thread, unless the executor</span></span><br><span class="line"><span class="comment">       * has been shut down, in which case the task is discarded.</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">              r.run();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="自定义ThreadFactory"><a href="#自定义ThreadFactory" class="headerlink" title="自定义ThreadFactory"></a>自定义ThreadFactory</h2><p> 请看固定大小的线程池的Demo</p><h2 id="扩展线程池"><a href="#扩展线程池" class="headerlink" title="扩展线程池"></a>扩展线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 类描述：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 作者：LIYONG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 创建时间：2017-5-7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@update</span> 修改时间：2017-5-7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtThreadPoolDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">MyTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"运行 Thread id :"</span> + Thread.currentThread().getId() + <span class="string">"  "</span> + System.currentTimeMillis());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"准备执行 "</span> + ((MyTask) r).name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"执行完成"</span> + ((MyTask) r).name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"线程池结束"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">MyTask task = <span class="keyword">new</span> MyTask(<span class="string">"task "</span>+i);</span><br><span class="line">executor.execute(task);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">executor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池数量"><a href="#线程池数量" class="headerlink" title="线程池数量"></a>线程池数量</h2><p>Ncpu = CPU数量<br>Ucpu=目标 CPU 的使用率，0&lt;=Ucpu&lt;=1<br>W/C=等待时间与计算时间的比率<br>最优的池的大小等于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Nthreads=Ncpu*Ucpu*(1+W/C)</span><br></pre></td></tr></table></figure><p>获取CPU数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().availableProcessors();</span><br></pre></td></tr></table></figure><p>在线程池中寻找堆栈信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 类描述：让在调度任务之前，先保存一下提交任务线程的堆栈信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 作者：LIYONG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 创建时间：2017-5-13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@update</span> 修改时间：2017-5-13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TraceThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">   BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line"><span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.util.concurrent.ThreadPoolExecutor#execute(java.lang.Runnable)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>.execute(wrap(command, clentTrace(), Thread.currentThread().getName()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.submit(wrap(task, clentTrace(), Thread.currentThread().getName()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Exception <span class="title">clentTrace</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Exception(<span class="string">"Client stack trace"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">wrap</span><span class="params">(<span class="keyword">final</span> Runnable task, <span class="keyword">final</span> Exception clientStack, String clientThreadName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">task.run();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">clientStack.printStackTrace();</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 类描述：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 作者：LIYONG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 创建时间：2017-5-13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@update</span> 修改时间：2017-5-13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DivTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">DivTask</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.a = a;</span><br><span class="line"><span class="keyword">this</span>.b = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> re = a / b;</span><br><span class="line">System.out.println(re);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line"></span><br><span class="line">ExecutorService pool = <span class="keyword">new</span> TraceThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">DivTask task = <span class="keyword">new</span> DivTask(<span class="number">100</span>, i);</span><br><span class="line"><span class="comment">// pool.execute(task);</span></span><br><span class="line">pool.submit(task);</span><br><span class="line"><span class="comment">// future.get();</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"******************************************"</span>);</span><br><span class="line">ExecutorService threadPoolExecutor =</span><br><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">DivTask task = <span class="keyword">new</span> DivTask(<span class="number">100</span>, i);</span><br><span class="line"><span class="comment">// pool.execute(task);</span></span><br><span class="line">threadPoolExecutor.submit(task);</span><br><span class="line"><span class="comment">// future.get();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Exception: Client stack trace</span><br><span class="line">at concurrent.TraceThreadPoolExecutor.clentTrace(TraceThreadPoolExecutor.java:42)</span><br><span class="line">at concurrent.TraceThreadPoolExecutor.submit(TraceThreadPoolExecutor.java:37)</span><br><span class="line">at concurrent.DivTask.main(DivTask.java:39)</span><br><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">at concurrent.DivTask.run(DivTask.java:29)</span><br><span class="line">at concurrent.TraceThreadPoolExecutor<span class="variable">$1</span>.run(TraceThreadPoolExecutor.java:52)100.0</span><br><span class="line"></span><br><span class="line">at java.util.concurrent.Executors<span class="variable">$RunnableAdapter</span>.call(Executors.java:439)</span><br><span class="line">at java.util.concurrent.FutureTask<span class="variable">$Sync</span>.innerRun(FutureTask.java:303)</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:138)</span><br><span class="line">at concurrent.TraceThreadPoolExecutor<span class="variable">$1</span>.run(TraceThreadPoolExecutor.java:52)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor<span class="variable">$Worker</span>.runTask(ThreadPoolExecutor.java:895)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor<span class="variable">$Worker</span>.run(ThreadPoolExecutor.java:918)</span><br><span class="line">at java.lang.Thread.run(Thread.java:662)</span><br><span class="line">25.0</span><br><span class="line">33.0</span><br><span class="line">50.0</span><br><span class="line">******************************************</span><br><span class="line">100.0</span><br><span class="line">33.0</span><br><span class="line">25.0</span><br><span class="line">50.0</span><br></pre></td></tr></table></figure><h2 id="分而治之-Fork-Join-框架"><a href="#分而治之-Fork-Join-框架" class="headerlink" title="分而治之 Fork/Join 框架"></a>分而治之 Fork/Join 框架</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 类描述：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 作者：LIYONG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 创建时间：2017-5-13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@update</span> 修改时间：2017-5-13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> threshold = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> end;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountTask</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.start = start;</span><br><span class="line"><span class="keyword">this</span>.end = end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> canCpmpute = (end - start) &lt; threshold;</span><br><span class="line"><span class="keyword">if</span> (canCpmpute) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> step = (start + end) / <span class="number">100</span>;</span><br><span class="line">ArrayList&lt;CountTask&gt; subTasks = <span class="keyword">new</span> ArrayList&lt;CountTask&gt;();</span><br><span class="line"><span class="keyword">long</span> pos = start;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="keyword">long</span> lastOne = pos + step;</span><br><span class="line"><span class="keyword">if</span> (lastOne &gt; end)</span><br><span class="line">lastOne = end;</span><br><span class="line">CountTask subTask = <span class="keyword">new</span> CountTask(pos, lastOne);</span><br><span class="line">pos += step + <span class="number">1</span>;</span><br><span class="line">subTasks.add(subTask);</span><br><span class="line">subTask.fork();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (CountTask subTask : subTasks) &#123;</span><br><span class="line">sum += subTask.join();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line"><span class="keyword">long</span> forkStart = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">long</span> endNumber = <span class="number">99999L</span>;</span><br><span class="line">ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">CountTask task = <span class="keyword">new</span> CountTask(<span class="number">0</span>, endNumber);</span><br><span class="line">ForkJoinTask&lt;Long&gt; result = forkJoinPool.submit(task);</span><br><span class="line">Long sum = result.get();</span><br><span class="line">System.out.println(<span class="string">"ForkJoinPool调用 sum="</span> + sum);</span><br><span class="line"><span class="keyword">long</span> forkEnd = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"ForkJoinPool调用 花费时间:  "</span> + (forkEnd - forkStart));</span><br><span class="line">sum = <span class="number">0L</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt;= endNumber; i++) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"正常调用 sum="</span> + sum);</span><br><span class="line">System.out.println(<span class="string">"正常调用花费时间:  "</span> + (System.currentTimeMillis() - forkEnd));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool调用 sum=4999950000</span><br><span class="line">ForkJoinPool调用 花费时间:  4</span><br><span class="line">正常调用 sum=4999950000</span><br><span class="line">正常调用花费时间:  5</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> concurrent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java资源大全</title>
      <link href="/2017/05/06/aa_category/se/Java%E8%B5%84%E6%BA%90%E5%A4%A7%E5%85%A8/"/>
      <url>/2017/05/06/aa_category/se/Java%E8%B5%84%E6%BA%90%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/shanxiliyong/awesome-java-cn" title="Java资源大全" target="_blank" rel="noopener">https://github.com/shanxiliyong/awesome-java-cn</a></p><a id="more"></a><h1 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h1><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>Apache Log4j 2：使用强大的插件和配置架构进行完全重写。<a href="https://logging.apache.org/log4j/2.x/" target="_blank" rel="noopener">官网</a><br>SLF4J：日志抽象层，需要与具体的实现配合使用。<a href="https://www.slf4j.org/" target="_blank" rel="noopener">官网</a></p><h2 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h2><p>Apache Kafka：高吞吐量分布式消息系统。<a href="http://kafka.apache.org/" target="_blank" rel="noopener">官网</a><br>Apache ActiveMQ：实现JMS的开源消息代理（broker），可将同步通讯转为异步通讯。<a href="http://activemq.apache.org/" target="_blank" rel="noopener">官网</a></p><h2 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h2><p>构建及应用依赖关系处理工具。<br>Apache Maven：Maven是一款声明式构建及依赖管理工具，采用约定优于配置方式进行管理。相对<br>Gradle：使用Groovy（非XML）进行增量构建，可以很好地与Maven依赖管理配合工作。</p><h2 id="字节码操作"><a href="#字节码操作" class="headerlink" title="字节码操作"></a>字节码操作</h2><p><em>编程方式操作字节码的开发库。</em><br>Javassist：一个简化字节码编辑尝试。官网</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p><em>测量代码指标和质量工具。</em><br>Checkstyle：代码编写规范和标准静态分析工具。<br>FindBugs：通过字节码静态分析查找隐藏bug。<br>PMD：对源代码分析查找不良的编程习惯。官网<br>SonarQube：通过插件集成其它分析组件，对过去一段时间内的数据进行统计。官网</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><em>简化数据库交互的相关工具。</em><br>H2：小型SQL数据库，以可以作为内存数据库使用著称。</p><h2 id="时间日期工具库"><a href="#时间日期工具库" class="headerlink" title="时间日期工具库"></a>时间日期工具库</h2><p><em>处理时间和日期的开发库。</em><br>Joda-Time：在Java 8发布前，Joda-Time是实际使用的时间日期库标准。 </p><h2 id="文档处理工具"><a href="#文档处理工具" class="headerlink" title="文档处理工具"></a>文档处理工具</h2><p><em>处理Office文档的开发库。</em><br>Apache POI：支持OOXML规范（XLSX、DOCX、PPTX）以及OLE2规范（XLS、DOC、PPT）。官网<br>documents4j：使用第三方转换器进行文档格式转换，转成类似MS Word这样的格式。官网<br>jOpenDocument：处理OpenDocument格式（由Sun公司提出基于XML的文档格式）。官网<br>docx4：解压的docx包(docx本身是zip包)和解析WordprocessingML格式XML的Java库</p><p>##高性能计算<br><em>涵盖了从集合到特定开发库的高性能计算相关工具。</em><br>Disruptor：线程间消息传递开发库。官网</p><h2 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h2><p><em>创建、评价和操作图片的支持库。</em><br>Imgscalr：纯Java 2D实现，简单、高效、支持硬件加速的图像缩放开发库。官网<br>Thumbnailator：Thumbnailator是一个高质量Java缩略图开发库。官网<br>ZXing：支持多种格式的一维、二维条形码图片处理开发库。官网<br>im4java: 基于ImageMagick或GraphicsMagick命令行的图片处理开发库，基本上ImageMagick能够支持的图片格式和处理方式都能够处理。官网</p><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p><em>简化JSON处理的开发库。</em><br>Gson：谷歌官方推出的JSON处理库，支持在对象与JSON之间双向序列化，性能良好且可以实时调用。官网<br>Jackson：与GSON类似，在频繁使用时性能更佳。官网<br>Fastjson: 一个Java语言编写的高性能功能完善的JSON库。官网</p><h2 id="开发流程增强工具"><a href="#开发流程增强工具" class="headerlink" title="开发流程增强工具"></a>开发流程增强工具</h2><p><em>从最基本的层面增强开发流程。</em><br>ADT4J：针对代数数据类型的JSR-269代码生成器。官网<br>AspectJ：面向切面编程（AOP）的无缝扩展。官网<br>Auto：源代码生成器集合。官网<br>DCEVM：通过修改JVM在运行时支持对已加载的类进行无限次重定义。官网<br>HotswapAgent：支持无限次重定义运行时类与资源。官网<br>Immutables：类似Scala的条件类。官网<br>JHipster：基于Spring Boot与AngularJS应用程序的Yeoman源代码生成器。官网<br>JRebel：无需重新部署，可以即时重新加载代码与配置的商业软件。官网<br>Lombok：减少冗余的代码生成器。官网</p><h2 id="分布式应用"><a href="#分布式应用" class="headerlink" title="分布式应用"></a>分布式应用</h2><p><em>用来编写分布式容错应用的开发库和框架。</em><br>Akka：用来编写分布式容错并发事件驱动应用程序的工具和运行时。官网<br>Apache Storm：实时计算系统。官网<br>Apache ZooKeeper：针对大型分布式系统的协调服务，支持分布式配置、同步和名称注册。官网</p><h2 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h2><p><em>对应用程序而言，在分布式系统中的数据库看起来就像是只有一个数据源。</em><br>Apache Cassandra：列式数据库，可用性高且没有单点故障。官网<br>Apache HBase：针对大数据的Hadoop数据库。官网<br>Druid：实时和历史OLAP数据存储，在聚集查询和近似查询方面表现不俗。官网<br>Infinispan：针对缓存的高并发键值对数据存储。官网</p><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>Apache Hadoop：在商用硬件集群上用来进行大规模数据存储的开源软件框架。<a href="http://hadoop.apache.org/" target="_blank" rel="noopener">官网</a><br>Apache Spark：开源数据分析集群计算框架。<a href="http://spark.apache.org/" target="_blank" rel="noopener">官网</a></p><h2 id="古董级工具"><a href="#古董级工具" class="headerlink" title="古董级工具"></a>古董级工具</h2><p>Apache Ant：基于XML的构建管理工具。<br>cglib：字节码生成库<br>GlassFish：应用服务器，由Oracle赞助支持的Java EE参考实现。<br>Hudson：持续集成服务器，目前仍在活跃开发。</p><p>##应用监控工具<br><em>监控生产环境中应用程序的工具。</em><br>JavaMelody：性能监测和分析工具。官网<br>Kamon：Kamon用来监测在JVM上运行的应用程序。官网</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p><em>网络编程函数库。</em><br>Async Http Client：异步HTTP和WebSocket客户端函数库。官网<br>Netty：构建高性能网络应用程序开发框架。官网<br>OkHttp：一个Android和Java应用的HTTP+SPDY客户端。官网</p><h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><p><em>处理对象持久化的API。</em><br>Hibernate：广泛使用、强健的持久化框架。Hibernate的技术社区非常活跃。官网<br>MyBatis：带有存储过程或者SQL语句的耦合对象（Couples object）。官网</p><h2 id="PDF"><a href="#PDF" class="headerlink" title="PDF"></a>PDF</h2><p><em>用来帮助创建PDF文件的资源。</em><br>Apache FOP：从XSL-FO创建PDF。官网<br>Apache PDFBox：用来创建和操作PDF的工具集。官网<br>DynamicReports：JasperReports的精简版。官网<br>flyingsaucer：XML/XHTML和CSS 2.1渲染器。官网<br>iText：一个易于使用的PDF函数库，用来编程创建PDF文件。注意，用于商业用途时需要许可证。官网<br>JasperReports：一个复杂的报表引擎。官网</p><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p><em>性能分析、性能剖析及基准测试工具。</em><br>jHiccup：提供平台中JVM暂停的日志和记录。官网<br>JMH：JVM基准测试工具。官网<br>JProfiler：商业分析器。官网<br>LatencyUtils：测量和报告延迟的工具。官网<br>VisualVM：对运行中的应用程序信息提供了可视化界面。官网<br>YourKit Java Profiler：商业分析器。官网</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p><em>用于处理安全、认证、授权或会话管理的函数库。</em><br>Apache Shiro：执行认证、授权、加密和会话管理。官网<br>Bouncy Castle，涵盖了从基础的帮助函数到PGP/SMIME操作。官网：多途加密开发库。支持JCA提供者（JCA provider)<br>Cryptomator：在云上进行客户端跨平台透明加密。官网<br>Keycloak：为浏览器应用和RESTful Web Service集成SSO和IDM。目前还处于beta版本，但是看起来非常有前途。官网<br>PicketLink：PicketLink是一个针对Java应用进行安全和身份认证管理的大型项目（Umbrella Project）。官网</p><h2 id="应用服务器"><a href="#应用服务器" class="headerlink" title="应用服务器"></a>应用服务器</h2><p><em>用来部署应用程序的服务器。</em><br>Apache Tomcat：针对Servlet和JSP的应用服务器，健壮性好且适用性强。官网<br>Jetty：轻量级、小巧的应用服务器，通常会嵌入到项目中。官网</p><h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><p><em>在模板中替换表达式的工具。</em><br>Apache Velocity：提供HTML页面模板、email模板和通用开源代码生成器模板。官网<br>FreeMarker：通用模板引擎，不需要任何重量级或自己使用的依赖关系。官网<br>Thymeleaf：旨在替换JSP，支持XML文件的工具。官网</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><em>测试内容从对象到接口，涵盖性能测试和基准测试工具。</em><br>Cucumber：BDD测试框架。官网<br>JUnit：通用测试框架。官网<br>PowerMock： 支持模拟静态方法、构造函数、final类和方法、私有方法以及移除静态初始化器的模拟工具。官网<br>Selenium：为Web应用程序提供可移植软件测试框架。官网</p><h2 id="通用工具库"><a href="#通用工具库" class="headerlink" title="通用工具库"></a>通用工具库</h2><p><em>通用工具类函数库。</em><br>Apache Commons：提供各种用途的函数，比如配置、验证、集合、文件上传或XML处理等。官网<br>args4j：命令行参数解析器。官网<br>CRaSH：为运行进行提供CLI。官网<br>Guava：集合、缓存、支持基本类型、并发函数库、通用注解、字符串处理、I/O等。官网<br>JADE：构建、调试多租户系统的框架和环境。官网<br>Quartz：强大的任务调度库.官网</p><h2 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h2><p><em>用于分析网站内容的函数库。</em><br>Apache Nutch：可用于生产环境的高度可扩展、可伸缩的网络爬虫。官网<br>Crawler4j：简单的轻量级网络爬虫。官网<br>JSoup：刮取、解析、操作和清理HTML。官网</p>]]></content>
      
      
      <categories>
          
          <category> Java资源大全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java资源大全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大话UML</title>
      <link href="/2017/04/22/aa_category/tool/%E5%A4%A7%E8%AF%9DUML/"/>
      <url>/2017/04/22/aa_category/tool/%E5%A4%A7%E8%AF%9DUML/</url>
      
        <content type="html"><![CDATA[<p>结构型UML-Structure  Diagram<br>类图-Class Diagram<br>对象图-Object Diagram(不常用)<br>包图-Package Diagram<br>构建图-Component Diagram<br>部署图-Deployment Diagram</p><p>行为的UML-Behavior  Diagram<br>活动图-Activity Diagram<br>状态机图-State Machine Diagram<br>顺序图-Sequence Diagram<br>用例图-Use Case Diagram<br>通信图-Communication Diagram(不常用)<br>时序图-Timing Diagram(不常用)</p><a id="more"></a><h2 id="类图-Class-Diagram"><a href="#类图-Class-Diagram" class="headerlink" title="类图-Class Diagram"></a>类图-Class Diagram</h2><h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><p>1、直线<br>1）普通关系<br><img src="/pic/tool/uml/%E7%9B%B4%E7%BA%BF%E5%85%B3%E7%B3%BB.png" alt="大话UML"><br>2）一对一关系<br><img src="%E4%B8%80%E5%AF%B9%E4%B8%80.png" alt="大话UML"><br>3）一对多关系,*表示0到多个<br><img src="%E4%B8%80%E5%AF%B9%E5%A4%9A.png" alt="大话UML"><br>4）一对零到三关系<br><img src="%E4%B8%80%E5%AF%B9%E9%9B%B6%E5%88%B0%E4%B8%89%E5%85%B3%E7%B3%BB.png" alt="大话UML"><br>5）角色关系,+代表public -代表private<br>6）导航关系，通过A能找到B<br><img src="%E5%AF%BC%E8%88%AA%E5%85%B3%E7%B3%BB2.png" alt="大话UML"></p><p>2、包含<br>聚合-Aggregation-若包含-虚心棱<br>组合-Composition-强包含-实心棱<br>3、继承<br><img src="%E7%BB%A7%E6%89%BF.png" alt="大话UML"><br>4、依赖<br><img src="%E4%BE%9D%E8%B5%96.png" alt="大话UML"><br>5、递归关系<br><img src="%E9%80%92%E5%BD%92.png" alt="大话UML"><br>6、三角关系<br><img src="%E4%B8%89%E8%A7%92.png" alt="大话UML"></p><h2 id="活动图-Activity-Diagram"><a href="#活动图-Activity-Diagram" class="headerlink" title="活动图-Activity Diagram"></a>活动图-Activity Diagram</h2><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p>开始、结束、判断、合并</p><h3 id="泳道-分区"><a href="#泳道-分区" class="headerlink" title="泳道/分区"></a>泳道/分区</h3><p>1、开始、结束状态可以画在任意泳道<br>2、判读、合并也可以画在任何泳道，但如果判断由某角色负责的，则应将这个判断的工作抽离为一个活动，将这个活动画在合适的泳道上</p><h2 id="顺序图-Sequence-Diagram"><a href="#顺序图-Sequence-Diagram" class="headerlink" title="顺序图-Sequence Diagram"></a>顺序图-Sequence Diagram</h2><p> 适合没有分支，没有循环的场景<br><img src="%E9%A1%BA%E5%BA%8F%E5%9B%BE.png" alt="大话UML"></p><h3 id="基础语法-1"><a href="#基础语法-1" class="headerlink" title="基础语法"></a>基础语法</h3><p>1、角色<br>2、生命线-LifeLine：角色或者对象下面的那条虚线，就是生命线<br>3、激活框-Activation Box:激活框也叫会话框，就是生命线中的西高矩形<br>4、消息-Message:<br>1）指向别人<br>2）指向自己<br>3）返回值</p><h2 id="用例图-Use-Case-Diagram"><a href="#用例图-Use-Case-Diagram" class="headerlink" title="用例图-Use Case Diagram"></a>用例图-Use Case Diagram</h2><p>1、用于分析不同的角色对需求的不同<br>2、用于分析不同的测试场景<br><img src="%E7%94%A8%E4%BE%8B%E5%9B%BE.png" alt="大话UML"></p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>1、执行者（小人）<br>2、用例-Use Case（圈圈）<br>3、系统边界-System Boundary<br>4、关联-Association<br>5、Include<br>1)以树的方式组织各种用例<br><img src="include1.png" alt="大话UML"><br>2）某些用例的一部分可以抽离出来成为子用例<br><img src="include2.png" alt="大话UML"><br>6、Extend<br><img src="extend.png" alt="大话UML"></p><h2 id="活动图和状态图的区别"><a href="#活动图和状态图的区别" class="headerlink" title="活动图和状态图的区别"></a>活动图和状态图的区别</h2><p>1、活动图将流程分解为一个个活动，通过活动的先后顺序来展示活动<br>2、状态机图通过事务的的状态如何变化来展示流程</p><h2 id="状态机图"><a href="#状态机图" class="headerlink" title="状态机图"></a>状态机图</h2><p><img src="%E7%8A%B6%E6%80%81%E6%9C%BA%E5%9B%BE.png" alt="大话UML"></p><h2 id="构件图"><a href="#构件图" class="headerlink" title="构件图"></a>构件图</h2><p><img src="%E6%9E%84%E4%BB%B6%E5%9B%BE.png" alt="大话UML"></p><h2 id="部署图"><a href="#部署图" class="headerlink" title="部署图"></a>部署图</h2><p><img src="%E9%83%A8%E7%BD%B2%E5%9B%BE.png" alt="大话UML"></p>]]></content>
      
      
      <categories>
          
          <category> uml </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oracle常用语句</title>
      <link href="/2017/04/18/aa_category/db/oracle/oracle%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5/"/>
      <url>/2017/04/18/aa_category/db/oracle/oracle%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">--创建数据表空间</span><br><span class="line">create tablespace xxxxxx_data logging datafile <span class="string">'D:\02_tools\oracle\datafile\xxxxxx_data01.dbf'</span></span><br><span class="line">size 512m  </span><br><span class="line">autoextend on  </span><br><span class="line">next 50m maxsize 2048m;</span><br><span class="line">--创建索引表空间</span><br><span class="line">create tablespace xxxxxx_idx logging datafile <span class="string">'D:\02_tools\oracle\datafile\xxxxxx_idx01.dbf'</span></span><br><span class="line">size 512m  </span><br><span class="line">autoextend on  </span><br><span class="line">next 50m maxsize 2048m;</span><br><span class="line">--创建临时表空间</span><br><span class="line">create temporary tablespace xxxxxx_temp tempfile <span class="string">'D:\02_tools\oracle\datafile\xxxxxx_temp01.dbf'</span></span><br><span class="line">size 512m  </span><br><span class="line">autoextend on  </span><br><span class="line">next 50m maxsize 2048m;</span><br><span class="line"></span><br><span class="line">--创建用户语句</span><br><span class="line">create user xxxxxx</span><br><span class="line">  identified by xxxxxx</span><br><span class="line">  default tablespace xxxxxx_DATA</span><br><span class="line">  temporary tablespace xxxxxx_TEMP;</span><br><span class="line"></span><br><span class="line">--开发环境授权语句</span><br><span class="line">grant connect,resource,dba to xxxxxx;</span><br><span class="line"></span><br><span class="line">--创建dir语句</span><br><span class="line">create DIRECTORY dump_dir AS <span class="string">'E:\01_work\dump_dir'</span>;</span><br><span class="line"></span><br><span class="line">--授权dir语句</span><br><span class="line">GRANT READ, WRITE ON DIRECTORY dump_dir TO xxxxxx;</span><br><span class="line"></span><br><span class="line">--导出语句</span><br><span class="line">expdp xxxxxx/xxxxxx@ORCL DIRECTORY=dump_dir DUMPFILE=xxxxxx_v1_1_05.DMP</span><br><span class="line"></span><br><span class="line">--导入dmp</span><br><span class="line">impdp xxxxxx/xxxxxx@ORCL  dumpfile=xxxxxx_V1_0_02.dmp directory=DUMP_DIR REMAP_SCHEMA=from_user:to_user  remap_tablespace=from_tablespace:to_tablespace</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> db </tag>
            
            <tag> oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyclicBarrier</title>
      <link href="/2017/04/16/aa_category/se/thread/CyclicBarrier/"/>
      <url>/2017/04/16/aa_category/se/thread/CyclicBarrier/</url>
      
        <content type="html"><![CDATA[<p>一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 类描述：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 作者：LIYONG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 创建时间：2017-4-16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@update</span> 修改时间：2017-4-16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String soldierName;</span><br><span class="line"><span class="keyword">private</span> CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Soldier</span><span class="params">(String soldierName, CyclicBarrier barrier)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.soldierName = soldierName;</span><br><span class="line"><span class="keyword">this</span>.barrier = barrier;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">barrier.await();</span><br><span class="line">Thread.sleep(Math.abs(<span class="keyword">new</span> Random().nextInt() % <span class="number">1000</span>));</span><br><span class="line">System.out.println(<span class="string">"士兵"</span> + soldierName + <span class="string">"任务完成"</span>);</span><br><span class="line">barrier.await();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BarrierRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">BarrierRun</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">N = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">System.out.println(N + <span class="string">"个士兵完成任务"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(N + <span class="string">"个士兵集合完毕"</span>);</span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line">System.out.println(N + <span class="string">"开始完成任务"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">BarrierRun barrierRun = <span class="keyword">new</span> BarrierRun(n);</span><br><span class="line">CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(n, barrierRun);</span><br><span class="line">System.out.println(<span class="string">"开始集合队伍"</span>);</span><br><span class="line">ExecutorService service = Executors.newFixedThreadPool(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">service.submit(<span class="keyword">new</span> Soldier(<span class="string">"士兵 "</span> + i, barrier));</span><br><span class="line">System.out.println(<span class="string">"士兵 "</span> + i + <span class="string">"集合完毕"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> concurrent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReadWriteLock</title>
      <link href="/2017/04/16/aa_category/se/thread/ReadWriteLock/"/>
      <url>/2017/04/16/aa_category/se/thread/ReadWriteLock/</url>
      
        <content type="html"><![CDATA[<p>ReadWriteLock和ReentrantLock相比，在读多写少的场景下，性能有很多的提升</p><p>1、读读不互斥<br>2、读写互斥<br>3、写写互斥</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 类描述：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 作者：LIYONG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 创建时间：2017-4-16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@update</span> 修改时间：2017-4-16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">ReentrantReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">Lock readLock = readWriteLock.readLock();</span><br><span class="line">Lock writeLock = readWriteLock.writeLock();</span><br><span class="line"><span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(Lock lock)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">Thread.sleep(<span class="number">1</span> * <span class="number">1000</span>);</span><br><span class="line">System.out.println(<span class="string">"读到的值为 ："</span> + value);</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Lock lock, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">Thread.sleep(<span class="number">1</span> * <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line">System.out.println(<span class="string">"写入的值为 ："</span> + value);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> ReadWriteLockDemo demo = <span class="keyword">new</span> ReadWriteLockDemo();</span><br><span class="line"></span><br><span class="line">Runnable readRun = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lock lock = demo.lock;</span></span><br><span class="line">Lock lock = demo.readLock;</span><br><span class="line"><span class="keyword">int</span> value = demo.read(lock);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">Runnable writeRun = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lock lock = demo.lock;</span></span><br><span class="line">Lock lock = demo.writeLock;</span><br><span class="line">demo.write(lock, <span class="keyword">new</span> Random().nextInt());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">new</span> Thread(readRun, <span class="string">""</span> + i).start();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">new</span> Thread(writeRun, <span class="string">""</span> + i).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> concurrent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CountDownLatch</title>
      <link href="/2017/04/16/aa_category/se/thread/CountDownLatch/"/>
      <url>/2017/04/16/aa_category/se/thread/CountDownLatch/</url>
      
        <content type="html"><![CDATA[<p>一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。用给定的计数 初始化 CountDownLatch。由于调用了 countDown() 方法，所以在当前计数到达零之前，await 方法会一直受阻塞。之后，会释放所有等待的线程，await 的所有后续调用都将立即返回。这种现象只出现一次——计数无法被重置</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 类描述：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 作者：LIYONG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 创建时间：2017-4-16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@update</span> 修改时间：2017-4-16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"thread name is  "</span> + Thread.currentThread().getName());</span><br><span class="line">Thread.sleep(<span class="number">2</span> * <span class="number">1000</span>);</span><br><span class="line">latch.countDown();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">ExecutorService exec = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">CountDownLatchDemo demo = <span class="keyword">new</span> CountDownLatchDemo();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">exec.submit(demo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待检查</span></span><br><span class="line">latch.await();</span><br><span class="line">System.out.println(<span class="string">"火箭发射"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> concurrent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Semaphore</title>
      <link href="/2017/04/16/aa_category/se/thread/Semaphore/"/>
      <url>/2017/04/16/aa_category/se/thread/Semaphore/</url>
      
        <content type="html"><![CDATA[<p>Semaphore实现的功能就类似厕所有5个坑，假如有10个人要上厕所，那么同时只能有多少个人去上厕所呢？同时只能有5个人能够占用，当5个人中 的任何一个人让开后，其中等待的另外5个人中又有一个人可以占用了。另外等待的5个人中可以是随机获得优先机会，也可以是按照先来后到的顺序获得机会，这取决于构造Semaphore对象时传入的参数选项。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 类描述：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 作者：LIYONG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 创建时间：2017-4-16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@update</span> 修改时间：2017-4-16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaPhoreDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Semaphore se = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">se.acquire();</span><br><span class="line">System.out.println(Thread.currentThread().getName());</span><br><span class="line">Thread.sleep(<span class="number">4</span> * <span class="number">1000</span>);</span><br><span class="line">se.release();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">SemaPhoreDemo demo = <span class="keyword">new</span> SemaPhoreDemo();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(demo, <span class="string">""</span> + i);</span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> concurrent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Condition</title>
      <link href="/2017/04/16/aa_category/se/thread/Condition/"/>
      <url>/2017/04/16/aa_category/se/thread/Condition/</url>
      
        <content type="html"><![CDATA[<p>1、Condition 重入锁的好搭档<br>2、调用方法 await 和  signal 之前必须获持有相关的锁，调用之后必须释放锁。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 类描述：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 作者：LIYONG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 创建时间：2017-4-16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@update</span> 修改时间：2017-4-16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">" lock.lock();"</span>);</span><br><span class="line">condition.await();</span><br><span class="line">Thread.sleep(<span class="number">1</span> * <span class="number">1000</span>);</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">" lock.lock();"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">ConditionDemo test = <span class="keyword">new</span> ConditionDemo();</span><br><span class="line"></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(test, <span class="string">"aaaaaa"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(test, <span class="string">"bbbbbb"</span>);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">Thread.sleep(<span class="number">2</span> * <span class="number">1000</span>);</span><br><span class="line">test.lock.lock();</span><br><span class="line">test.condition.signal();</span><br><span class="line">        <span class="comment">//如果不释放锁则，被唤醒的线程由于无法获取锁而导致无法继续工作</span></span><br><span class="line">test.lock.unlock();</span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDKArrayBlockingQueue的部分源码"><a href="#JDKArrayBlockingQueue的部分源码" class="headerlink" title="JDKArrayBlockingQueue的部分源码"></a>JDKArrayBlockingQueue的部分源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 类描述：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 作者：LIYONG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 创建时间：2017-4-16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@update</span> 修改时间：2017-4-16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Main lock guarding all access */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">/** Condition for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"><span class="comment">/** Condition for waiting puts */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the tail of this queue, waiting</span></span><br><span class="line"><span class="comment"> * for space to become available if the queue is full.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment"> *             &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException</span></span><br><span class="line"><span class="comment"> *             &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">lock.lockInterruptibly();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (count == items.length)</span><br><span class="line">notFull.await();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">notFull.signal(); <span class="comment">// propagate to non-interrupted thread</span></span><br><span class="line"><span class="keyword">throw</span> ie;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  notEmpty.signal();</span></span><br><span class="line">insert(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">lock.lockInterruptibly();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">notEmpty.await();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">notEmpty.signal(); <span class="comment">// propagate to non-interrupted thread</span></span><br><span class="line"><span class="keyword">throw</span> ie;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// notFull.signal();</span></span><br><span class="line">E x = extract();</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> concurrent </tag>
            
            <tag> lock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LockSupport</title>
      <link href="/2017/04/16/aa_category/se/thread/LockSupport/"/>
      <url>/2017/04/16/aa_category/se/thread/LockSupport/</url>
      
        <content type="html"><![CDATA[<p>1、先执行unpark，后执行park不会导致线程永久挂起<br>2、可以响应中断<br>3、LockSupport采用类似信号量的机制，它为每个线程准备一个许可，执行park的时候，如果许可可用，则立即返回，如果许可不可用，则会阻塞线程。执行unpark则可让许可可用，多次执行upark不能累加(一个线程只能有一个许可)</p><a id="more"></a><h2 id="demo-证明先执行unpark，后执行park不会导致线程永久挂起"><a href="#demo-证明先执行unpark，后执行park不会导致线程永久挂起" class="headerlink" title="demo,证明先执行unpark，后执行park不会导致线程永久挂起"></a>demo,证明先执行unpark，后执行park不会导致线程永久挂起</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 类描述：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 作者：LIYONG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 创建时间：2017-4-16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@update</span> 修改时间：2017-4-16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportDemo1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">4</span> * <span class="number">1000</span>);</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">" park"</span>);</span><br><span class="line">LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">LockSupportDemo1 test = <span class="keyword">new</span> LockSupportDemo1();</span><br><span class="line"></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(test, <span class="string">" aaaaaa"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(test, <span class="string">" bbbbbb"</span>);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">LockSupport.unpark(t1);</span><br><span class="line">Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">LockSupport.unpark(t2);</span><br><span class="line">System.out.println(<span class="string">"has unpark"</span>);</span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="demo-可以响应中断"><a href="#demo-可以响应中断" class="headerlink" title="demo 可以响应中断"></a>demo 可以响应中断</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 类描述：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 作者：LIYONG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 创建时间：2017-4-16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@update</span> 修改时间：2017-4-16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportDemo2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">2</span> * <span class="number">1000</span>);</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">"   park"</span>);</span><br><span class="line">LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"被中断了"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"结束了"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">LockSupportDemo2 test = <span class="keyword">new</span> LockSupportDemo2();</span><br><span class="line"></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(test, <span class="string">"aaaaaa"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(test, <span class="string">"bbbbbb"</span>);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">LockSupport.unpark(t1);</span><br><span class="line">System.out.println(<span class="string">"线程"</span> + t1.getName() + <span class="string">" has unpark"</span>);</span><br><span class="line">Thread.sleep(<span class="number">4</span> * <span class="number">1000</span>);</span><br><span class="line">t2.interrupt();</span><br><span class="line">System.out.println(<span class="string">"线程 "</span> + t2.getName() + <span class="string">" 被中断了"</span>);</span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> concurrent </tag>
            
            <tag> lock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指令重排序</title>
      <link href="/2017/04/15/aa_category/se/thread/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F/"/>
      <url>/2017/04/15/aa_category/se/thread/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>1、对于一个线程来说，它看到的指令执行顺序是一致的。<br>2、线程writer的指令执行顺序在现场reader看来是没有保证的<br>3、下面的例子可能会出现flag=true的时候a=2还未执行，至于是否发生了指令重排序，如何重排序我们是无法预测的。</p><a id="more"></a><p><img src="https://liyong.ac.cn/pic/se/1.jpg" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 类描述：指令重排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 作者：LIYONG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 创建时间：2017-4-16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@update</span> 修改时间：2017-4-16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderExample</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">OrderExample</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.state = state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">a = <span class="number">10</span> / a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (state == <span class="number">0</span>) &#123;</span><br><span class="line">writer();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">reader();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">OrderExample writerOrder = <span class="keyword">new</span> OrderExample(<span class="number">0</span>);</span><br><span class="line">OrderExample readerOrder = <span class="keyword">new</span> OrderExample(<span class="number">1</span>);</span><br><span class="line">Thread writer = <span class="keyword">new</span> Thread(writerOrder, <span class="string">"writer"</span>);</span><br><span class="line">Thread reader = <span class="keyword">new</span> Thread(readerOrder, <span class="string">"reader"</span>);</span><br><span class="line">writer.start();</span><br><span class="line">reader.start();</span><br><span class="line">writer.join();</span><br><span class="line">reader.join();</span><br><span class="line">Thread.sleep(<span class="number">2</span> * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> concurrent </tag>
            
            <tag> 性能调优 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jstack</title>
      <link href="/2017/04/15/aa_category/se/gc&amp;mem/jstack/"/>
      <url>/2017/04/15/aa_category/se/gc&amp;mem/jstack/</url>
      
        <content type="html"><![CDATA[<p>jstack主要用来查看某个Java进程内的线程堆栈信息。语法格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstack [option] pid</span><br><span class="line">jstack [option] executable core</span><br><span class="line">jstack [option] [server-id@]remote-hostname-or-ip</span><br></pre></td></tr></table></figure><p> 命令行参数选项说明如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-l long listings，会打印出额外的锁信息，在发生死锁时可以用jstack -l pid来观察锁</span><br></pre></td></tr></table></figure><p>1、jstack定位到堆栈信息<br>2、根据堆栈信息可以堆栈信息可以定位到具体代码，所以在JVM性能调优中使用的的相当多</p><a id="more"></a><h2 id="Java代码查看堆栈信息"><a href="#Java代码查看堆栈信息" class="headerlink" title="Java代码查看堆栈信息"></a>Java代码查看堆栈信息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">Map&lt;Thread, StackTraceElement[]&gt; traces = Thread.getAllStackTraces();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Thread, StackTraceElement[]&gt; trace : traces.entrySet()) &#123;</span><br><span class="line">Thread thread = trace.getKey();</span><br><span class="line"><span class="keyword">if</span> (thread.equals(Thread.currentThread())) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">sb.append(<span class="string">"线程 "</span> + thread.getName() + <span class="string">"\r\n"</span>);</span><br><span class="line"><span class="keyword">for</span> (StackTraceElement element : trace.getValue()) &#123;</span><br><span class="line">sb.append(<span class="string">"--"</span> + element + <span class="string">"\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sb);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能调优 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadGoup</title>
      <link href="/2017/04/15/aa_category/se/thread/ThreadGoup/"/>
      <url>/2017/04/15/aa_category/se/thread/ThreadGoup/</url>
      
        <content type="html"><![CDATA[<p>分门别类的管理，线程组</p><a id="more"></a><h2 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 类描述：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 作者：LIYONG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 创建时间：2017-4-14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@update</span> 修改时间：2017-4-14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadGoupTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String groupName = Thread.currentThread().getThreadGroup().getName()+<span class="string">"&amp;&amp;"</span>+Thread.currentThread().getName();</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">System.out.println(groupName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">4</span>*<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ThreadGroup group = <span class="keyword">new</span> ThreadGroup(<span class="string">"group"</span>);</span><br><span class="line">ThreadGoupTest test = <span class="keyword">new</span> ThreadGoupTest();</span><br><span class="line"></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(group, test, <span class="string">"aaaaaa"</span>);</span><br><span class="line">t1.setPriority(<span class="number">10</span>);</span><br><span class="line">t1.start();</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(group, test, <span class="string">"bbbbbb"</span>);</span><br><span class="line">t2.setPriority(<span class="number">1</span>);</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> concurrent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReentrantLock</title>
      <link href="/2017/04/15/aa_category/se/thread/ReentrantLock/"/>
      <url>/2017/04/15/aa_category/se/thread/ReentrantLock/</url>
      
        <content type="html"><![CDATA[<h2 id="ReentrantLock比-synchronized的优势"><a href="#ReentrantLock比-synchronized的优势" class="headerlink" title="ReentrantLock比 synchronized的优势"></a>ReentrantLock比 synchronized的优势</h2><p>1、RenntrantLock性能远远好于synchronized，但从JDK 1.6 开始，JDK在synchronized做了大量的优化，使得两者性能差距并不大<br>2、RenntrantLock支持中断响应<br>3、ReentrantLock支持指定限时等待锁<br>4、ReenTrantLock支持公平锁</p><h2 id="ReentrantLock实现三要素"><a href="#ReentrantLock实现三要素" class="headerlink" title="ReentrantLock实现三要素"></a>ReentrantLock实现三要素</h2><ol><li>原子性，使用cas保证原子性</li><li>等待队列，没有请求道锁的线程会进入等待队列，如果某个线程释放锁，则从等待队列中唤醒一个线程，继续工作</li><li>阻塞 park,恢复unpark<a id="more"></a></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ReentrantLock lock1 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">static</span> ReentrantLock lock2 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lock = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ReentrantLockTest2</span><span class="params">(<span class="keyword">int</span> lock)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.lock = lock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (lock == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock1.lockInterruptibly();</span><br><span class="line">Thread.sleep(<span class="number">1</span> * <span class="number">1000</span>);</span><br><span class="line">System.out.println(<span class="string">"lock 1"</span>);</span><br><span class="line">lock2.lockInterruptibly();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (lock1.isHeldByCurrentThread()) &#123;</span><br><span class="line">lock1.unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (lock2.isHeldByCurrentThread()) &#123;</span><br><span class="line">lock2.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock2.lockInterruptibly();</span><br><span class="line">Thread.sleep(<span class="number">1</span> * <span class="number">1000</span>);</span><br><span class="line">System.out.println(<span class="string">"lock 0"</span>);</span><br><span class="line">lock1.lockInterruptibly();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (lock1.isHeldByCurrentThread()) &#123;</span><br><span class="line">lock1.unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (lock2.isHeldByCurrentThread()) &#123;</span><br><span class="line">lock2.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">ReentrantLockTest2 intLock1 = <span class="keyword">new</span> ReentrantLockTest2(<span class="number">1</span>);</span><br><span class="line">ReentrantLockTest2 intLock0 = <span class="keyword">new</span> ReentrantLockTest2(<span class="number">0</span>);</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(intLock0, <span class="string">"intLock0"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(intLock1, <span class="string">"intLock1"</span>);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">t2.interrupt();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> concurrent </tag>
            
            <tag> lock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式总结</title>
      <link href="/2017/03/10/aa_category/se/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2017/03/10/aa_category/se/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>先看如下两幅图片</p><p>设计模式之间的关系：<br><img src="1.png" alt="设计模式总结"></p><a id="more"></a><p> 设计模式总概况：<br><img src="2.png" alt="设计模式总结"></p><h1 id="一、设计原则"><a href="#一、设计原则" class="headerlink" title="一、设计原则"></a>一、设计原则</h1><h2 id="1、单一职责原则"><a href="#1、单一职责原则" class="headerlink" title="1、单一职责原则"></a>1、单一职责原则</h2><p>一个类，只有一个引起它变化的原因。应该只有一个职责。每一个职责都是变化的一个轴线，如果一个类有一个以上的职责，这些职责就耦合在了一起。这会导致脆弱的设计。当一个职责发生变化时，可能会影响其它的职责。另外，多个职责耦合在一起，会影响复用性。例如：要实现逻辑和界面的分离。from：百度百科</p><h2 id="2、开闭原则（Open-Close-Principle）"><a href="#2、开闭原则（Open-Close-Principle）" class="headerlink" title="2、开闭原则（Open Close Principle）"></a>2、开闭原则（Open Close Principle）</h2><p>开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p><h2 id="3、里氏代换原则（Liskov-Substitution-Principle）"><a href="#3、里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="3、里氏代换原则（Liskov Substitution Principle）"></a>3、里氏代换原则（Liskov Substitution Principle）</h2><p>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。from：百度百科</p><h2 id="4、依赖倒转原则（Dependence-Inversion-Principle）"><a href="#4、依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="4、依赖倒转原则（Dependence Inversion Principle）"></a>4、依赖倒转原则（Dependence Inversion Principle）</h2><p>所谓依赖倒置原则（Dependence Inversion Principle）就是要依赖于抽象，不要依赖于具体。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</p><p>实现开闭原则的关键是抽象化，并且从抽象化导出具体化实现，如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要手段。 from：百度百科</p><h2 id="5、接口隔离原则（Interface-Segregation-Principle）"><a href="#5、接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="5、接口隔离原则（Interface Segregation Principle）"></a>5、接口隔离原则（Interface Segregation Principle）</h2><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</p><h2 id="6、合成复用原则（Composite-Reuse-Principle）"><a href="#6、合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="6、合成复用原则（Composite Reuse Principle）"></a>6、合成复用原则（Composite Reuse Principle）</h2><p>合成复用原则就是指在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用其已有功能的目的。简言之：要尽量使用组合/聚合关系，少用继承。</p><h2 id="7、迪米特法则（最少知道原则）（Demeter-Principle）"><a href="#7、迪米特法则（最少知道原则）（Demeter-Principle）" class="headerlink" title="7、迪米特法则（最少知道原则）（Demeter Principle）"></a>7、迪米特法则（最少知道原则）（Demeter Principle）</h2><p>为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。也就是说一个软件实体应当尽可能少的与其他实体发生相互作用。这样，当一个模块修改时，就会尽量少的影响其他的模块，扩展会相对容易，这是对软件实体之间通信的限制，它要求限制软件实体之间通信的宽度和深度。</p><h1 id="适配器模式、代理模式、装饰模式"><a href="#适配器模式、代理模式、装饰模式" class="headerlink" title="适配器模式、代理模式、装饰模式"></a>适配器模式、代理模式、装饰模式</h1><ul><li>适配器模式，一个适配允许通常因为接口不<strong><em>兼容</em></strong>而不能在一起工作的类工作在一起，做法是将类自己的接口包裹在一个已存在的类中。</li><li>装饰器模式，原有的不能满足现有的需求，对原有的进行<strong>增强</strong></li><li>代理模式，同一个类而去调用另一个类的方法，不对这个方法进行直接操作，起到<strong>隔离</strong>效果</li><li>代理模式一定是自身持有这个对象，不需要从外部传入。而装饰模式的一定是从外部传入，并且可以没有顺序，按照代码的实际需求随意挑换顺序，就如你吃火锅先放白菜还是先放丸子都可以</li></ul>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何提高Java并行程序性能</title>
      <link href="/2017/03/10/aa_category/se/thread/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98Java%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/"/>
      <url>/2017/03/10/aa_category/se/thread/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98Java%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>在Java程序中，多线程几乎已经无处不在。与单线程相比，多线程程序的设计和实现略微困难，但通过多线程，我们却可以获得多核CPU带来的性能飞跃，从这个角度说，多线程是一种值得尝试的技术。那么如何写出高效的多线程程序呢？</p><a id="more"></a><h2 id="有关多线程的误区：线程越多，性能越好"><a href="#有关多线程的误区：线程越多，性能越好" class="headerlink" title="有关多线程的误区：线程越多，性能越好"></a>有关多线程的误区：线程越多，性能越好</h2><p>不少初学者可能认为，线程数量越多，那么性能应该越好。因为程序给我们的直观感受总是这样。一个两个线程可能跑的很难，线程一多可能就快了。但事实并非如此。因为一个物理CPU一次只能执行一个线程，多个线程则意味着必须进行线程的上下文切换，而这个代价是很高的。因此，线程数量必须适量，最好的情况应该是N个CPU使用N个线程，并且让每个CPU的占有率都达到100%，这种情况下，系统的吞吐量才发挥到极致。但现实中，不太可能让单线程独占CPU达到100%，一个普遍的愿意是因为IO操作，无论是磁盘IO还是网络IO都是很慢的。线程在执行中会等待，因此效率就下来了。这也就是为什么在一个物理核上执行多个线程会感觉效率高了，对于程序调度来说，一个线程等待时，也正是其它线程执行的大好机会，因此，CPU资源得到了充分的利用。</p><h2 id="尽可能不要挂起线程"><a href="#尽可能不要挂起线程" class="headerlink" title="尽可能不要挂起线程"></a>尽可能不要挂起线程</h2><p>多线程程序免不了要同步，最直接的方法就是使用锁。每次只允许一个线程进入临界区，让其它相关线程等待。等待有2种，一种是直接使用操作系统指令挂起线程，另外一种是自旋等待。在操作系统直接挂起，是一种简单粗暴的实现，性能较差，不太适用于高并发的场景，因为随之而来的问题就是大量的线程上下文切换。如果可以，尝试一下进行有限的自旋等待，等待不成功再去挂起线程也不迟。这样很有可能可以避免一些无谓的开销。JDK中ConcurrentHashMap的实现里就有一些自旋等待的实现。此外Java虚拟机层面，对synchronized关键字也有自旋等待的优化。</p><h2 id="善用“无锁”"><a href="#善用“无锁”" class="headerlink" title="善用“无锁”"></a>善用“无锁”</h2><p>阻塞线程会带来性能开销，因此，一种提供性能的方案就是使用无锁的CAS操作。JDK中的原子类，如AtomicInteger正是使用了这种方案。在高并发环境中，冲突较多的情况下，它们的性能远远好于传统的锁操作（《实战Java高并发程序设计》 P158）。</p><h2 id="处理好“伪共享”问题"><a href="#处理好“伪共享”问题" class="headerlink" title="处理好“伪共享”问题"></a>处理好“伪共享”问题</h2><p>大家知道，CPU有一个高速缓存Cache。在Cache中，读写数据的最小单位是缓存行，如果2个变量存在一个缓存行中，那么在多线程访问中，可能会相互影响彼此的性能。因此将变量存放于独立的缓存行中，也有助于变量在多线程访问是的性能提升（《实战Java高并发程序设计》 P200），大量的高并发库都会采用这种技术。</p>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> concurrent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中字符串内存位置浅析</title>
      <link href="/2017/03/09/aa_category/se/Java%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%85%E5%AD%98%E4%BD%8D%E7%BD%AE%E6%B5%85%E6%9E%90/"/>
      <url>/2017/03/09/aa_category/se/Java%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%85%E5%AD%98%E4%BD%8D%E7%BD%AE%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前面试被问，Java里面String存放的位置，之前只记得String是一个不变的量，应该是要存放在常量池里面的，但是后来问到new一个String出来应该是放到哪里的，这个应该是放到堆里面的，后来又问到String的引用是放在什么地方的，当时傻逼的说也是放在堆里面的，现在总结一下：基本类型的变量数据和对象的引用都是放在栈里面的，对象本身放在堆里面，显式的String常量放在常量池，String对象放在堆中。</p><a id="more"></a><h2 id="常量池的说明"><a href="#常量池的说明" class="headerlink" title="常量池的说明"></a>常量池的说明</h2><p>常量池之前是放在方法区里面的，也就是在永久代里面的，从JDK7开始移到了堆里面。这一改变我们可以从oracle的release version的notes里的 Important RFEs Addressed in JDK 7 看到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Area: HotSpot</span><br><span class="line">Synopsis: In JDK 7, interned strings are no longer allocated <span class="keyword">in</span> the permanent </span><br><span class="line">generation of the Java heap, but are instead allocated <span class="keyword">in</span> the main part of the </span><br><span class="line">Java heap (known as the young and old generations), along with the other </span><br><span class="line">objects created by the application. This change will result <span class="keyword">in</span> more data </span><br><span class="line">residing <span class="keyword">in</span> the main Java heap, and less data <span class="keyword">in</span> the permanent generation, and </span><br><span class="line">thus may require heap sizes to be adjusted. Most applications will see only </span><br><span class="line">relatively small differences <span class="keyword">in</span> heap usage due to this change, but larger </span><br><span class="line">applications that load many classes or make heavy use of the String.intern() </span><br><span class="line">method will see more significant differences.</span><br><span class="line">RFE: 6962931</span><br></pre></td></tr></table></figure><h2 id="String内存位置说明"><a href="#String内存位置说明" class="headerlink" title="String内存位置说明"></a>String内存位置说明</h2><p>1.显式的String常量</p><p>String a = “holten”;<br>String b = “holten”;<br>第一句代码执行后就在常量池中创建了一个值为holten的String对象；<br>第二句执行时，因为常量池中存在holten所以就不再创建新的String对象了。<br>此时该字符串的引用在虚拟机栈里面。<br>2.String对象</p><p>String a = new String(“holtenObj”);<br>String b = new String(“holtenObj”);<br>Class被加载时就在常量池中创建了一个值为holtenObj的String对象，第一句执行时会在堆里创建new String(“holtenObj”)对象；<br>第二句执行时，因为常量池中存在holtenObj所以就不再创建新的String对象了，直接在堆里创建new String(“holtenObj”)对象。</p><h2 id="验证一下"><a href="#验证一下" class="headerlink" title="验证一下"></a>验证一下</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String str1 = <span class="string">"高小天"</span>;</span><br><span class="line">        String str2 = <span class="string">"高小天"</span>;</span><br><span class="line">        System.out.println(str1==str2);<span class="comment">//true</span></span><br><span class="line">        </span><br><span class="line">        String str3 = <span class="keyword">new</span> String(<span class="string">"高大天"</span>);</span><br><span class="line">        String str4 = <span class="keyword">new</span> String(<span class="string">"高大天"</span>);</span><br><span class="line">        System.out.println(str3==str4);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存区域划分</title>
      <link href="/2017/03/09/aa_category/se/gc&amp;mem/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86/"/>
      <url>/2017/03/09/aa_category/se/gc&amp;mem/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>学习Java不可避免的要学习Java虚拟机，也就是JVM，Java虚拟机规范里面规定了程序运行期间会使用到的运行时数据区，这也是JVM的内存区域划分的模型，应该可以这么理解吧。</p><p>这其中有一些是随着虚拟机的启动和退出而创建和销毁的，这些区域是线程共享的，另外有一些是跟各个线程绑定的，随着线程的开始和结束而创建和销毁，我们可以称这些区域是线程私有的。</p><p>根据《Java虚拟机规范Java SE 7版》和《Java虚拟机规范Java SE 8版》的规定，我们可以划分出如下几个运行时数据区，如下图所示：</p><p><img src="1.png" alt="JVM内存区域划分"></p><a id="more"></a><h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>在Java虚拟机中，堆是可供各个线程共享的运行时内存区域，也是供所有类实例和数组对象分配内存的区域。这块区域随着虚拟机的启动而创建，它的唯一使命就是存放对象实例，这块区域也是GC主要关注的地方。</p><p>下面的就是我的笔记本上的JVM堆的划分情况，可以看到分为新生代、老年代和永久代，新生代里面有可以分为Eden Space、From Survivor Space和To Survivor Space。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 17301504 (16.5MB)</span><br><span class="line">   used     = 2483088 (2.3680572509765625MB)</span><br><span class="line">   free     = 14818416 (14.131942749023438MB)</span><br><span class="line">   14.351862127130682% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 2621440 (2.5MB)</span><br><span class="line">   used     = 2615312 (2.4941558837890625MB)</span><br><span class="line">   free     = 6128 (0.0058441162109375MB)</span><br><span class="line">   99.7662353515625% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 6291456 (6.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 6291456 (6.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = 44564480 (42.5MB)</span><br><span class="line">   used     = 13316368 (12.699478149414062MB)</span><br><span class="line">   free     = 31248112 (29.800521850585938MB)</span><br><span class="line">   29.88112505744485% used</span><br><span class="line">PS Perm Generation</span><br><span class="line">   capacity = 22020096 (21.0MB)</span><br><span class="line">   used     = 14907008 (14.2164306640625MB)</span><br><span class="line">   free     = 7113088 (6.7835693359375MB)</span><br><span class="line">   67.6972888764881% used</span><br></pre></td></tr></table></figure><p>根据虚拟机规范的规定，Java堆可以是固定的大小也可以是按照需求动态扩展的，而且不需要保证是连续的。</p><p>存放内容：所有的对象实例和数组。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区是一个线程共享的区域，它用于存储已被虚拟机加载的类信息、常量、静态变量。方法区是堆的逻辑组成部分，Hotspot用永久代实现了方法区。<br>方法区还包含运行时常量池(JDK1.7以后移到堆中)，用于存放编译时生成的各种字面量和符号引用，但是不要求常量一定是在编译时期产生的，运行期间也可以将新的常量放入池中，比如String的intern()方法便是利用了这一特性。</p><p>存放内容：类的结构信息，如类的字段、方法、接口、构造函数，还有运行时常量池等。</p><h2 id="程序计数寄存器"><a href="#程序计数寄存器" class="headerlink" title="程序计数寄存器"></a>程序计数寄存器</h2><p>这块区域是每个线程独立拥有的，也就是线程私有的，我们可以把它看作是当前线程所执行的字节码的行号指示器。</p><p>这块区域时虚拟机规范里面唯一一个没有规定任何OutOfMemoryError情况的区域。</p><p>存放内容：如果线程执行的是一个Java方法，那么寄存器里面记录的就是正在执行的虚拟机字节码指令的地址，如果线程执行的是一个native方法，那么寄存器记录的值为undefined。</p><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>虚拟机栈也是线程私有的内存区域。每个方法在执行的时候都会创建一个栈帧用于存储局部变量表、操作数栈、方法出口等信息，每一个方法从调用到执行完成就是一个栈帧入栈和出栈的过程。</p><p>局部变量表存放了编译时期可知的各种基本数据类型、对象引用和指向了一条字节码指令的地址。</p><p>存放内容：局部变量表、操作数栈、方法出口等信息。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>和虚拟机栈类似，存储Native方法的相关信息。<br>存放内容：局部变量表、操作数栈、方法出口等信息</p>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂方法模式</title>
      <link href="/2017/03/03/aa_category/se/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/03/03/aa_category/se/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="普通工厂模式"><a href="#普通工厂模式" class="headerlink" title="普通工厂模式"></a>普通工厂模式</h2><p>  就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。首先看下关系图：</p><p><img src="1.jpg" alt="工厂方法模式"></p><a id="more"></a><p>举例如下：（我们举一个发送邮件和短信的例子）</p><p>首先，创建二者的共同接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sender</span> </span>&#123;  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span></span>;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其次，创建实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"this is mailsender!"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"this is sms sender!"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，建工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produce</span><span class="params">(String type)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"mail"</span>.equals(type)) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MailSender();  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"sms"</span>.equals(type)) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            System.out.println(<span class="string">"请输入正确的类型!"</span>);  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        SendFactory factory = <span class="keyword">new</span> SendFactory();  </span><br><span class="line">        Sender sender = factory.produce(<span class="string">"sms"</span>);  </span><br><span class="line">        sender.Send();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：this is sms sender!</p><h2 id="多个工厂方法模式"><a href="#多个工厂方法模式" class="headerlink" title="多个工厂方法模式"></a>多个工厂方法模式</h2><p> 是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。关系图： </p><p><img src="2.jpg" alt="工厂方法模式"></p><p>将上面的代码做下修改，改动下SendFactory类就行，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Sender <span class="title">produceMail</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MailSender();  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produceSms</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        SendFactory factory = <span class="keyword">new</span> SendFactory();  </span><br><span class="line">        Sender sender = factory.produceMail();  </span><br><span class="line">        sender.Send();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：this is mailsender!</p><h2 id="静态工厂方法模式"><a href="#静态工厂方法模式" class="headerlink" title="静态工厂方法模式"></a>静态工厂方法模式</h2><p>   将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sender <span class="title">produceMail</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MailSender();  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sender <span class="title">produceSms</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;      </span><br><span class="line">        Sender sender = SendFactory.produceMail();  </span><br><span class="line">        sender.Send();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：this is mailsender!</p><p>总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。 </p>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KeyTool</title>
      <link href="/2017/03/01/aa_category/se/KeyTool/"/>
      <url>/2017/03/01/aa_category/se/KeyTool/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -<span class="built_in">alias</span> www.lee.com -keyalg RSA -keystore f:/keys/lee</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -<span class="built_in">export</span> -file f:/keys/lee.crt -<span class="built_in">alias</span> www.lee.com -keystore f:/keys/lee</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">keytool -import -keystore %JAVA_HOME%\jre\lib\security\cacerts -file f:/keys/mag.crt -<span class="built_in">alias</span> www.lee.com</span><br><span class="line">keytool -list -v -<span class="built_in">alias</span> www.lee.com -keystore %JAVA_HOME%\jre\lib\security\cacerts</span><br><span class="line">Keytool –delete –<span class="built_in">alias</span> s1as –keystore keystopre.jks –storepass changeit</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> se </category>
          
      </categories>
      
      
        <tags>
            
            <tag> plugins </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
